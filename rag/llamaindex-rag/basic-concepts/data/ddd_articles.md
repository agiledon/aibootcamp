# <font style="color:rgb(0,0,0);">作者简介</font>
![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703815845538-f3525ea8-841a-436e-8164-f0a380649aa3.png)

张逸，信通院应用现代化推进中心专家委员会委员，数字现代化首席顾问，微软最有价值专家，南京大学软件工程卓越技术讲堂讲师，四川大学软件工程硕士，K+全球软件研发行业创新峰会联席主席，<font style="color:rgb(0, 0, 0);">阿里研发效能峰会出品人，</font>DDD研修会创始人，DDD China社区卓越贡献者，2021年度影响力作者奖。

<font style="color:rgb(0,0,0);">先后担任DaoCloud应用现代化首席顾问，民航信息技术总监兼首席架构师，ThoughtWorks首席咨询师，HP GDCC解决方案架构师，中兴通讯高级工程师，并</font><font style="color:rgb(0, 0, 0);">先后在美国、澳大利亚、法国与中国香港为海外企业提供交付与咨询服务</font><font style="color:rgb(0,0,0);">。著译作包括《解构领域驱动设计》（包括简体版与繁体版）、《软件设计精要与模式》、《架构宝典》、《高可用可伸缩微服务架构》、《Java设计模式》、《恰如其分的软件架构》、《WCF服务编程》、《人件》。</font>

<font style="color:rgb(0, 0, 0);">咨询与培训内容包括数字化转型、应用现代化、领域驱动设计、分布式架构、设计模式、重构与测试驱动开发、高质量Java编码、敏捷项目转型等。咨询与培训客户包括工商银行、中国银行、花旗银行、中国银联、招商银行、浦发银行、平安集团、太平洋保险、太平人寿、国泰保险、华泰证券、安信证券、广发证券、深交所、上海期货交易所、郑州商品交易所、清算所、宝马、广汽丰田、普华永道、安永、京东、美团、酷狗音乐、斯伦贝谢、赛门铁克、可口可乐、摩托罗拉、华为、中兴通讯、中国电信、中国移动、电信盈科、中化集团、国家电网、中国体彩、顺丰速运、戴尔、TCL、浪潮、国航、中航信等近百余家国内外企业，服务的全球五百强企业达到二十余家，涉及到的行业与领域包括互联网、零售、金融、通信、制造、民航。</font>

<font style="color:rgb(0, 0, 0);">目前，主要致力于大型软件企业的数字化建设、分布式架构设计、领域驱动设计推广、大数据平台架构设计以及代码质量提升与敏捷项目转型。</font>

# 如何学习领域驱动设计
从战略到战术，DDD给出了诸多关于软件架构、设计、建模与编码的方法和模式，以用于应对业务复杂度。然而，许多开发人员对于DDD的价值仍然心存疑惑，相反，对于它的难以理解难以学习倒是确信不疑，甚至有人惊呼DDD是“反人类的难懂”。这正是现实给了DDD沉痛的当头一击啊！

从2004年Eric Evans出版《领域驱动设计》一书以来，已有十五余载。实事求是说，DDD的推进与项目落地真的是举步维艰。个中原因，难以说清。DDD是否真正反人类的难懂可以另说，但它是在反“早期的开发传统”，却是毋庸置疑。这一开发传统就是从技术实现出发，由数据驱动软件设计。软件开发人员往往擅长解决技术难题，却不善于（或者说不愿意）理清复杂的领域逻辑，对领域概念进行抽象。领域建模本身是一个主观思考的结果，这也带来优劣判定的不可衡量。

只要克服对DDD的畏难情绪（甚至是反感情绪），其实，DDD的学习并没有想象的那么困难。最大的挑战在于如何落地？

当一家企业或者一个团队希望选择DDD帮助他们提升软件设计与开发质量时，他们是否想过：

+ 团队有没有专门的业务分析师，或者领域专家？
+ 是否组建了特性团队，并以迭代的方式进行开发？
+ 是否愿意以可视化的工作坊形式沟通需求，确定统一语言？
+ 是否创造了足够的条件让特性团队的所有成员与角色能够面对面地高效沟通？
+ 是否愿意为打造高质量的核心领域模型而为成本买单？

这些问题并非DDD能解决的，但却是成功实施DDD时需要确保的场外因素！因此，DDD实施成败的关键，不仅在于DDD的本身，还在于企业或团队能力成熟度是否达到了实施DDD的要求！这也正是我为何在课程中提出“领域驱动设计能力评估模型（DDD Capability Assesment Model，DCAM）”的原因所在。

我眼中的DDD已经超越了软件设计技术的范畴，它更像是一门哲学！何谓“哲学”，可以理解为是对人生、世界乃至宇宙的智慧思考。而DDD就是对软件世界的一种思考形式，它提出以抽象的领域模型去反映混乱的现实需求世界，以有序、合规、演进的方式去打造满足业务需求的软件世界，并尽量将技术因素推出这个世界的大气层边界之外。简言之，DDD是我们观察软件世界的态度！

因此，对于学习DDD的开发人员而言，第一重要的不是掌握DDD的模式，而是要改变分析思维与设计思维的方式。将这种思维方式运用到软件项目开发过程中，就是我在课程中提到的“领域模型驱动设计”，它的核心内容可以通过层层推进的形式汇集为如下三句话：

+ 以领域为分析建模的驱动力
+ 以场景为设计建模的驱动力
+ 以任务为实现建模的驱动力

如何理解这三句话？

当你在开始领域模型驱动设计时，必须在分析建模阶段抛开实现技术对你的影响，与需求分析人员、测试人员一起单纯针对“领域”进行分析建模，即提炼与抽象领域概念，并以统一语言和模型的形式来表达。

在设计建模阶段，围绕着一个完整的“场景”开展设计工作。需求分析人员为“场景”编写用户故事，测试人员为“场景”编写验收标准，开发人员则开始解剖“场景”，将其分解为组合任务与原子任务，然后各自分配给不同的角色构造型。

到了实现建模，就针对这些任务定义测试用例，开始测试驱动开发，由内至外到达应用服务时，再将它们集成起来。

显然，领域模型驱动设计就是针对领域开展的“合而分、分而合”的解构过程。

同时，必须谨记：领域模型驱动设计的基础是限界上下文。在领域驱动设计的战略阶段，同样是一个“合而分、分而合”的解构过程：将领域分解为限界上下文，再通过上下文映射联合限界上下文共同实现多个领域场景。

以上内容正是我言犹未尽想要表达的精髓。学习领域驱动设计，就需要抓住DDD的根本和精髓。

你需要理解什么是限界上下文，它带来的价值是什么；你需要理解如何进行领域建模，统一语言在其中扮演了什么样的角色；你需要理解为何领域驱动设计提倡以领域为驱动力，为什么需要领域专家参与到项目开发中来。

提升了对这些内容的认识后，再去学习DDD给出的设计模式，学习我在课程中给出的固化设计过程，如场景驱动设计，然后找三两个不曾实施DDD的项目，寻两三个实施了DDD的项目，相互对比其模型与代码，你绝对会有一种醍醐灌顶的感觉。当然，这些都需要你沉下心来细心体会，认真思考，还需要你广泛涉猎更多软件设计与开发的知识，如此方能打通DDD的任督二脉。

至于团队实施DDD，则不仅在于你个人的DDD知识与能力，而在于我前面提及的“场外因素”。企业或团队若期望在项目中实施DDD，首先需要利用DCAM评估一下团队的能力成熟度，再来决策做不做DDD，怎么做DDD，并着手培养团队成员的DDD能力。

# 领域驱动设计概览
领域驱动设计（Domain Driven Design，DDD）是由Eric Evans最早提出的综合软件系统分析和设计的面向对象建模方法，如今已经发展为一种针对大型复杂系统的领域建模与分析方法。它完全改变了传统软件开发工程师针对数据库进行的建模方法，从而将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承、多态等设计要素，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。

## 领域驱动设计的开放性
领域驱动设计是一种方法论（Methodology）。根据维基百科的定义，方法论是一套运用到某个研究领域的系统与理论分析方法。领域驱动设计就是针对软件开发领域提出的一套系统与理论分析方法。Eric Evans在创造性地提出领域驱动设计时，实则是针对当时项目中聚焦在以数据以及数据样式为核心的系统建模方法的批判。面向数据的建模方法是关系数据库理论的延续，关注的是数据表以及数据表之间关系的设计。这是典型的面向技术实现的建模方法，面对日渐复杂的业务逻辑，这种设计方法欠缺灵活性与可扩展性，也无法更好地利用面向对象设计思想以及设计模式，建立可重用的、可扩展的代码单元。领域驱动设计的提出，是设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程。

由于领域驱动设计是一套方法论，它建立了以领域为核心驱动力的设计体系，因而具有一定的开放性。在这个体系中，你可以使用不限于领域驱动设计提出的任何一种方法来解决这些问题。例如，我们可以使用用例（Use Case）、测试驱动开发（TDD）、用户故事（User Story）帮助我们对领域建立模型；我们可以引入整洁架构思想以及六边形架构，以帮助我们建立一个层次分明、结构清晰的系统架构；我们可以引入函数式编程思想，利用纯函数与抽象代数结构的不变性以及函数的组合性来表达领域模型。这些实践方法与模型已经超越了Eric Evans最初提出的领域驱动设计范畴，但在体系上却是一脉相承的。这也是为什么在领域驱动设计社区，能够不断诞生诸如CQRS模式、事件溯源（Event Sourcing）模式与事件风暴（Event Storming）等新概念的原因；领域驱动设计也以开放的心态拥抱微服务（Micro Service），甚至能够将它的设计思想与原则运用到微服务架构设计中。

## 领域驱动设计过程
领域驱动设计当然不是架构方法，也并非设计模式。准确地说，它其实是“一种思维方式，也是一组优先任务，它旨在加速那些必须处理复杂领域的软件项目的开发”。领域驱动设计贯穿了整个软件开发的生命周期，包括对需求的分析，建模，架构，设计，甚至最终的编码实现，乃至对编码的测试与重构。

领域驱动设计强调领域模型的重要性，并通过模型驱动设计来保障领域模型与程序设计的一致。从业务需求中提炼出统一语言（Ubiquitous Language），再基于统一语言建立领域模型；这个领域模型会指导着程序设计以及编码实现；最后，又通过重构来发现隐式概念，并运用设计模式改进设计与开发质量。这个过程如下图所示：

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852032523-9b3f081e-604e-4d96-91e6-efb91fe17a64.png)

这个过程是一个覆盖软件全生命周期的设计闭环，每个环节的输出都可以作为下一个环节的输入，而在其中扮演重要指导作用的则是“领域模型”。这个设计闭环是一个螺旋上升的迭代设计过程，领域模型会在这个迭代过程中逐渐演进，在保证模型完整性与正确性的同时，具有新鲜的活力，使得领域模型能够始终如一的贯穿领域驱动设计过程，阐释着领域逻辑，指导着程序设计，验证着编码质量。

如果仔细审视这个设计闭环，我们发现在针对问题域和业务期望提炼统一语言，并通过统一语言进行领域建模时，可能会面临高复杂度的挑战。这是因为对于一个复杂的软件系统而言，我们要处理的问题域实在太庞大了。在为问题域寻求解决方案时，需要从宏观层次划分不同业务关注点的子领域，然后再深入到子领域中从微观层次对领域进行建模。宏观层次是战略的层面，微观层次是战术的层面，只有将战略设计与战术设计结合起来，才是完整的领域驱动设计。

### 战略设计阶段
领域驱动设计的战略设计阶段是从两个方面来考量的：

+ 问题域方面：针对问题域，引入限界上下文（Bounded Context）和上下文映射（Context Map）对问题域进行合理的分解，识别出核心领域（Core Domain）与子领域（SubDomain），并确定领域的边界以及它们之间的关系，维持模型的完整性。
+ 架构方面：通过分层架构来隔离关注点，尤其是将领域实现独立出来，可以更利于领域模型的单一性与稳定性；引入六边形架构清晰地表达领域与技术基础设施的边界；CQRS模式则分离了查询场景和命令场景，针对不同场景选择使用同步或异步操作，提高架构的低延迟性与高并发能力。

Eric Evans提出战略设计的初衷是要保持模型的完整性。限界上下文的边界可以保护上下文内部和其他上下文之间的领域概念互不冲突。然而，如果我们将领域驱动设计的战略设计模式引入到架构过程中，就会发现限界上下文不仅限于对领域模型的控制，而在于分离关注点之后，使得整个上下文可以成为独立部署的设计单元，这就是“微服务”的概念，上下文映射的诸多模式则对应了微服务之间的协作。因此在战略设计阶段，微服务扩展了领域驱动设计的内容，反过来领域驱动设计又能够保证良好的微服务设计。

一旦确立了限界上下文的边界，尤其是作为物理边界，则分层架构就不再针对整个软件系统，而仅仅针对粒度更小的限界上下文。此时，限界上下文定义了技术实现的边界，对当前上下文的领域与技术实现进行了封装，我们只需要关心对外暴露的接口与集成方式，形成了在服务层次的设计单元重用。

边界给了实现限界上下文内部的最大自由度。这也是战略设计在分治上起到的效用。我们可以在不同的限界上下文选择不同的架构模式，例如针对订单的查询与处理，选择CQRS模式来分别处理同步与异步场景；还可以针对核心领域与子领域重要性的不同，分别选择领域模型（Domain Model）和事务脚本（Transaction Script）模式，灵活地平衡开发成本与开发质量。在宏观层面，面对整个软件系统，我们可以采用前后端分离与基于REST的微服务架构，保证系统具有一致的架构风格。

### 战术设计阶段
整个软件系统被分解为多个限界上下文（或领域）后，我们就可以分而治之，对每个限界上下文进行战术设计。领域驱动设计并不牵涉到技术层面的实现细节，在战术层面，它主要应对的是领域的复杂性。领域驱动设计用以表示模型的主要要素包括：

+ 值对象（Value Object）
+ 实体（Entity）
+ 领域服务（Domain Service）
+ 领域事件（Domain Event）
+ 资源库（Repository）
+ 工厂（Factory）
+ 聚合（Aggregate）
+ 应用服务（Application Service）

Eric Evans通过下图勾勒了战术设计诸要素之间的关系：

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852097774-a083f323-d118-4463-a584-cae0c27efbf7.png)

领域驱动设计围绕着领域模型进行设计，通过分层架构（Layered Architecture）将领域独立出来。表示领域模型的对象包括：实体、值对象和领域服务。领域逻辑都应该封装在这些对象中。这一严格的设计原则可以避免业务逻辑渗透到领域层之外，导致技术实现与业务逻辑的混淆。在领域驱动设计的演进中，又引入了领域事件来丰富领域模型。

聚合是一种边界，它可以封装一到多个实体与值对象，并维持该边界范围之内的业务完整性。在聚合中，至少包含一个实体，且只有实体才能作为聚合根（Aggregate Root）。注意，在领域驱动设计中，没有任何一个类是单独的聚合，因为聚合代表的是边界概念，而非领域概念。极端情况下，一个聚合可能有且只有一个实体。

工厂和资源库都是对领域对象生命周期的管理。前者负责领域对象的创建，往往用于封装复杂或者可能变化的创建逻辑。后者则负责从存放资源的位置（数据库、内存或者其他Web资源）获取、添加、删除或者修改领域对象。领域模型中的资源库不应该暴露访问领域对象的技术实现细节。

## 演进的领域驱动设计过程
战略设计会控制和分解战术设计的边界与粒度，战术设计则以实证角度验证领域模型的有效性、完整性与一致性，进而以演进的方式对之前的战略设计阶段进行迭代，从而形成一种螺旋式上升的迭代设计过程，如下图所示：

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852119886-a8a8c13f-f5a8-4d31-9f97-6af9fe8711b5.png)



面对客户的业务需求，由领域专家与开发团队展开充分的交流，经过需求分析与知识提炼，获得清晰的问题域。通过对问题域进行分析和建模，识别限界上下文，利用它划分相对独立的领域，再通过上下文映射建立它们之间的关系，辅以分层架构与六边形架构划分系统的逻辑边界与物理边界，界定领域与技术之间的界限。之后，进入战术设计阶段，深入到限界上下文内对领域进行建模，并以领域模型指导程序设计与编码实现。若在实现过程中，发现领域模型存在重复、错位或缺失时，再进而对已有模型进行重构，甚至重新划分限界上下文。

两个不同阶段的设计目标是保持一致的，它们是一个连贯的过程，彼此之间又相互指导与规范，并最终保证一个有效的领域模型和一个富有表达力的实现同时演进。



2018年10月9日

# 领域驱动设计的价值


这一价值的总结起因，来自Eric Evans著作《领域驱动设计》的副标题，即Tackling Complexity in the Heart of Software——应对软件核心复杂度。



## 业务复杂度的成因


DDD要处理的复杂度主要为业务复杂度。业务复杂度的成因可以简单归纳为两点：

1.  规模 
2.  领域逻辑 



### 规模带来的复杂度


软件系统要达到什么样的规模，方可称为业务复杂度高？目前业界并无准确可量化的客观标准。正如梅拉妮·米歇尔《复杂》一书所述：“复杂性难以定义/度量，佐证了它的复杂性”。

![](https://mmbiz.qpic.cn/mmbiz_jpg/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjprKkNjIxg0icia5W1n3HhIR8LxHXXoEWD2zrDpiaiaticgjV75PBvXeWsljA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1&wx_co=1)



关于软件复杂性的度量，可以另起文章专项解读。单从业务复杂度讲，大约可用业务单元的**宽度**来衡量。所谓“业务单元”，可以是用例、用户故事等，我的书《解构领域驱动设计》则将其定义为**业务服务**。



业务单元的宽度其实就是它的数量。



那么，数量要达到多少，才可称之为规模足够大，才会引起较高的业务复杂度呢？很不幸，这也没有客观标准。但我们知道，解决规模复杂度的最有效手段是“分而治之”，于是可以勉强得到一个不是标准的标准：**当一个系统需要通过分解才能控制规模带来的复杂度时，就认为它的规模够大了**。



### 领域逻辑带来的复杂度


什么样的领域逻辑才需控制复杂度？与宽度相对，**可用业务单元的深度来衡量**。按照我书中的说法，就是对业务单元进行任务分解，构成由组合任务和原子任务形成的一棵任务树。计算从树根到最底层叶的层级，就是业务单元的深度。

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjp0V2rlnZguu5RHAqg2WUJlicJ0HRUbV2t9UYv3NS4LMSbDmfOUCk5lOA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



如果不定义原子任务的衡量标准，任务就可以不断拆分，对深度的度量就缺乏客观标准。故而，我给出两条标准，只要当前任务满足以下标准的任何一条，就可以不再拆分：

+  该任务需要的领域知识是一个聚合拥有的，可识别为原子任务 
+  该任务访问了外部资源，可识别为原子任务 



## 领域驱动设计的价值


DDD提出了诸多重要的设计模式，社区也提炼了实施DDD的基本原则。这些模式与原则，其根本目的是与软件复杂度做斗争。它们也充分体现了DDD的价值。



### 子领域的划分


DDD通过引入子领域划分问题空间。一方面，子领域形成的边界可以有效地控制因为问题空间规模过大带来的业务复杂度；另一方面，DDD根据价值高低将子领域分为核心、通用和支撑，团队就可从RoI（投资回报率）的角度，对不同子领域选择不同的解决方案。

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjpo25ARkajkZnChWlibyB9SpmlnU39RSU95KydJL9lrmY39VHzt4ZAYww/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



划分子领域后，系统的业务蓝图也随之建立，并清晰地界定了系统范围，以明确问题空间的边界。

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjpQgYUENnXMXWcYXEzgIIu7tc2SFwMjOlqCsvlpuClxTrKvBkzdibibtqw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



### 限界上下文的划分


与子领域对问题空间的划分相同，DDD通过限界上下文划分解空间，即可有效控制解空间规模过大带来的复杂度。



子领域和限界上下文控制复杂度的道理相同，就是“分而治之”，只是它们应对的目标不同罢了。



划分限界上下文时，可以先对问题空间获得的业务蓝图进行一对一映射，即系统范围映射为系统上下文，子领域映射为限界上下文，业务服务映射为服务契约，然后，再根据解决方案与技术决策的不同诉求，对限界上下文的边界进行调整，并以限界上下文为目标，提炼出更多的服务契约。

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjp0Ut0h6wqSYsRu2HZFuPXFHCe7zPYAVpmDib099jBPfexueyiaic866sow/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



我将限界上下文视为应用架构的基本单元。它是DDD最重要的模式。



限界上下文不仅界定了应用架构更小粒度的边界，它同时还是领域模型的边界。一个规模庞大的业务系统，往往意味着数以百计乃至数以千计的领域类。在引入限界上下文之后，数量庞大的领域类也随之分配到各个限界上下文，类的数量级得到有效控制，降低了领域模型的复杂度。



### 控制领域对象的大小与架构单元的依赖


限界上下文不是模块，不是组件，也不是服务，它就是限界上下文，如前所述，它是DDD最重要的模式。



我对限界上下文的解读，可以总结为下图：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjpJl6HdVrBoiamqZ38CK5aZMeQwZrOqjfb3N72sGRSzwBAhTVp0RSBCQQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



因为它体现了领域模型的知识语境，故而它可以有效地控制领域对象的粒度。如下图所示，根据不同的语境，将Product类分配到5个限界上下文，分别定义Product类，如此即可避免定义出过于庞大而臃肿的上帝类：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjpTx0Yrsu3zQDVicRVM9pbj8jtEB8ibIeTWkDFNQprbAT0eth1maYwNiaWg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



业务能力的纵向切分使得限界上下文成为相对独立完整的自治架构单元，与领域模型的知识语境相结合，它既拥有最小完备的领域知识，又具备自我履行的业务能力（纵向切分得到的限界上下文自己拥有支撑业务运行的基础设施与数据），如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjp9pAvmWKicEfA2ibIVLhW7SkOpIMeFDT4gJA4z8GkIfayib5nBG81EoHeA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



仍以Product为例，倘若不按照限界上下文的特征进行划分，很可能定义出一个庞大的Product类，并将其放到商品模块。这个庞大的类像一块巨型的磁铁，把其他模块紧紧地吸附在商品模块上：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjpYXKXwtm26HJNFflmxmF7icfpjW4wfoEx27pzHCp1WU83owf9H96DwdA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



相反，领域知识与业务能力的合理划分，使得限界上下文能够更好地履行职责，从而减少限界上下文之间不必要的依赖。



以运输上下文为例，如果希望知道商品是否放在集装箱（属性为inShippingBox），由于运输上下文定义了拥有inShippingBox属性的Product类，对应的数据也存储在运输数据库中，它就不必再去调用商品上下文，也就减少了依赖。



无疑，当领域类的规模变小，架构单元之间的依赖变少，解空间的复杂度自然也得到了一定程度的控制。



### 业务与技术的正交


DDD推荐业务和技术之间保持正交分离，只是如下图所示的DDD分层架构似乎不能清晰地表达正交分离的“态度”：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjp5Yt9ZFCvMsU94vWMicsp38B1nkQ65icic6qPRfvNmpWvbqFibBMgluar3Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



我提出的菱形对称架构脱胎于整洁架构与六边形架构，通过定义更加清晰的领域层与网关层，直观地表达了业务与技术正交分离的”态度“：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjp5jkr41uaDK0GfBBOgm6LpxB8OVibTibnEDtLDHmCLXbW8uGMWsdpVZ6A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



这样的结构可以让开发者更清晰地判断：

+  如果发现网关层包含领域逻辑，则说明违背正交原则 
+  如果发现领域层包含技术实现，则说明违背正交原则 



如此可界定业务与技术的界限，从而有效隔离业务复杂度与技术复杂度，使得二者互不干扰，整体降低了复杂度。



### 一致的代码模型


倘若整个目标系统的所有开发团队都能遵循菱形对称架构，定义统一的代码模型，就能保证代码模型的一致性。下图是菱形对称架构推荐的代码模型：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjpB53teCiclMJttZxZxpfKGCAFr9w9cWtHpQP79gbam9jJamibxpsLRS7Q/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



正如Blaauw的论断：“好的架构应该是直接的，人们掌握了部分系统后就可以推测出其他部分”，即所谓”窥一斑而知全豹“。菱形对称架构规定了诸如远程服务、本地服务、领域服务、聚合、端口等角色构造型，且它们之间的协作关系总是如下图所示：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjpBgrFfxQkj7qXcsMmup27voEf2RJO5ic7eZRGn8IDibH3bfUCmWXK2nxw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



如前面代码模型图所示，当订单团队在编写订单上下文的代码时，开发人员遵循菱形对称架构定义其代码模型。同理，库存上下文也定义同样的代码模型。当库存团队的开发人员想要了解订单上下文的实现机制时，由于代码结构与角色协作的机制是一致的，代码阅读变得没有障碍，也就变相地降低了实现逻辑的复杂度，降低了维护成本。



### 聚合对领域逻辑的抽象


在开展领域建模时，需遵循面向对象的设计思想，一切皆为对象，领域概念无论大小，都应该抽象为领域类，即使是基础概念如姓名、邮箱、地址、重量等，也应尽量避免定义为基础类型，而应定义为所谓的”基础领域对象（primitive domain object）“。



如此一来，构成领域模型的类数量就会显著增多。虽然限界上下文的引入已经减少了领域类的数量，但细粒度领域类的定义，还是增加了领域逻辑的复杂度。



此外，如果不加控制，还可能导致各个领域类之间产生大量的依赖，组成一张如下图所示的复杂对象网：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjpdOq8QScBbzkZ8JKH7bI0ZvA4PGJun8p7P95ZBodgiacrHCvXnje1qxw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



DDD通过聚合对领域逻辑进行抽象，合理的聚合设计可以形成合理粒度单元的领域模型。DDD为聚合建立了约束条件：

+  聚合之间只能通过聚合根建立关系 
+  根实体是聚合唯一的入口和出口 



如此一来，领域类之间就不能自由自在地建立关联。当聚合通过根实体对内部进行封装时，非根的实体与值对象被聚合边界隐藏起来，既然聚合的调用者看不到，就相当于领域类的数量变少了，如前面所示的对象网就构成了由聚合组成的领域模型：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakBibM3xqcZ7ibhZbgbKUPJicjpNLD8CYBYSnJym7QRgRoTOfGjyfhU19MWm1icOzzh3AycFKVv0wnoz3w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



这样的领域模型自然更加简单。



聚合可以将领域逻辑封装在其边界内，同时也就有效地控制了领域逻辑深度带来的复杂度。



### 战略与战术的隔离


DDD引入的战略设计可以应对业务单元宽度带来的复杂度，战术设计则应对业务单元深度带来的复杂度。



**战略设计与战术设计可以独立选择。**



如果解空间规模复杂度高，可引入限界上下文对其分而治之。完成分解后，倘若限界上下文内部的领域逻辑深度并未达到一定的复杂度，则不必一定要采用DDD的聚合来控制领域逻辑复杂度；反之亦然。



这给了团队更加灵活而自由的选择。



2023年7月17日

# <font style="color:rgba(0, 0, 0, 0.9);">构建领域驱动设计知识体系</font>
<font style="color:rgba(0, 0, 0, 0.9);">本次演讲是我创作GitChat课程「领域驱动战略设计实践」和「领域驱动战术设计实践」这两年来，随着对领域驱动设计的深度理解，结合自身项目经验总结的领域驱动设计知识体系。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">本次演讲内容分为四个部分：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计的历史回顾</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">对领域驱动设计的新定位</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计参考过程模型</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计能力评估模型  
</font>

## <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计的历史回顾</font>
<font style="color:rgba(0, 0, 0, 0.9);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">从2004年Eric Evans的经典著作《领域驱动设计》出版开始，在这十五年间，我个人认为有四个重要的里程碑值得重视。  
</font>

### <font style="color:rgba(0, 0, 0, 0.9);">里程碑之一：领域驱动设计的诞生  
</font>
![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852181795-7362bb8e-b139-4aec-b876-0d50d2db5e48.jpeg)

### <font style="color:rgba(0, 0, 0, 0.9);">里程碑之二：领域事件的引入  
</font>
<font style="color:rgba(0, 0, 0, 0.9);">它的重要意义在于拓宽了领域驱动设计的建模范式，引入了以“事件”和“函数”为核心的新的领域驱动设计模式，如Event Store、Event Sourcing、Pure Function等：</font><font style="color:rgba(0, 0, 0, 0.9);">  
</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852181721-d7a76808-9300-4cfb-a8e8-117ea4a94b2c.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">架构模式也发生了变化：  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852181769-3749f406-e97f-4ae2-962a-edf0abe631ec.png)

### <font style="color:rgba(0, 0, 0, 0.9);">里程碑之三：微服务的引入  
</font>
<font style="color:rgba(0, 0, 0, 0.9);">毫无疑问，微服务概念以及该架构模式的产生与发展，对领域驱动设计产生了深远的影响。它的引入对企业应用系统的设计与开发带来了各方面的影响。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">首先是设计理念的改变。传统的数据模型驱动设计并不适合微服务架构。例如，那种以数据库SQL或存储过程操作数据的方式，在微服务架构下已经不具备优势：</font>

<font style="color:rgba(0, 0, 0, 0.9);">  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852181761-fe107190-0dc6-4e73-8333-5815f585bd97.png)

<font style="color:rgba(0, 0, 0, 0.9);">  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">其次，领域驱动设计引入的限界上下文边界与聚合边界更适合微服务架构：</font>

<font style="color:rgba(0, 0, 0, 0.9);">  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852181754-bd72758e-031c-43e8-9d50-867eaeda549c.png)<font style="color:rgba(0, 0, 0, 0.9);">  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">通过防腐层（ACL）与开放主机服务（OHS）维护好限界上下文的边界，有利于单体架构向微服务架构的迁移：  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852182377-89578819-cb5d-4c43-9ff8-7440683a42c2.png)

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计强调领域模型与数据模型的分离，在从单库单表的数据结构迁移到多库多表时，领域模型受到的影响较小，同样有利于单体架构到微服务架构的迁移。  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852182458-187d229b-e91d-4ec0-87aa-43693cfa4baa.png)

<font style="color:rgba(0, 0, 0, 0.9);">  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">在2017年的DDD中国峰会，我对肖然笑称是“微服务拯救了领域驱动设计”，但这个说法其实比较过分，因为领域驱动设计并没有岌岌可危，只是并未成为国内软件开发的主流而已，因而我改为一个更加温柔的说法：微服务让领域驱动设计焕发了青春。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">但是，到了2019年的今天，我却要改变这一说法：不是微服务让领域驱动设计焕发青春，而是微服务“爱上了”领域驱动设计，二者其实是</font>**<font style="color:rgba(0, 0, 0, 0.9);">天作之合</font>**<font style="color:rgba(0, 0, 0, 0.9);">。</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852182433-6a788aae-4a84-4844-a7d6-85b3ed6d2829.png)

### <font style="color:rgba(0, 0, 0, 0.9);">里程碑之四：中台战略的引入</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">ThoughtWorks的王健将微服务定义为：企业级能力复用平台。我很认同这一定义，如果仔细分析这九个字的定义，也可以从领域驱动设计中找到映射。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">首先，领域驱动设计中问题空间的子领域和解决方案空间的限界上下文就体现了企业级能力：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852182462-5bfa18c3-379c-468d-b146-9ff2537d868d.png)

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">其次，领域驱动设计强调将领域层独立出来，即可形成对领域模型的复用：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852182479-7696ca92-182e-42ea-81a0-7487b0213c4c.png)

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计的四重边界与整洁架构思想的遵循，可以帮助我们更好地完成平台的沉淀：</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852183064-db77e0a5-56fc-41b3-9ace-1aa21c16badf.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);">中台战略（Zhongtai Strategy）是否能够更好地与领域驱动设计结合，或许答案还未可知，但我们可以对其进行探索。</font>

## <font style="color:rgba(0, 0, 0, 0.9);">对领域驱动设计的新定位</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">我认为领域驱动设计从最初的一种技术体系，到现在已经发展成了一种设计哲学：  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852183037-9f06a2d8-aa01-4a78-afbc-9fb267690f6c.png)

<font style="color:rgba(0, 0, 0, 0.9);">为此，我建立了</font>**<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计魔方</font>**<font style="color:rgba(0, 0, 0, 0.9);">，分别从X、Y、Z三个维度对领域驱动设计进行了梳理：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852183126-49ae9332-5ef1-4686-9484-2956ba83eb7b.png)

<font style="color:rgba(0, 0, 0, 0.9);">我基于Y轴划分的宏观层次、微观层次与纳米层次分别介绍了</font>**<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计魔方</font>**<font style="color:rgba(0, 0, 0, 0.9);">：</font><font style="color:rgba(0, 0, 0, 0.9);">  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852183104-5ee490fe-e83f-4939-b8cf-8049dfa6fb76.png)

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852183146-1054fc59-ed67-4948-8a13-0de3e35c1151.png)

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852183628-d2f6c426-8c39-472f-8263-b97196af0487.png)

<font style="color:rgba(0, 0, 0, 0.9);">在领域驱动设计魔方中，我引入了业务架构、系统上下文、事件风暴、整洁架构、RAID风暴、RUP 4+1视图、康威定律、精益需求管理、敏捷过程管理、场景驱动设计、测试驱动开发和测试战略。这些内容在PPT中都有介绍，这里就不再赘述。  
</font>

## <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计参考过程模型</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">固化领域驱动设计的过程，提供简单有效的实践方法，建立具有目的性和可操作性的研发过程。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">在全局分析阶段，参考过程模型的实践包括：  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852183667-bf1e5beb-9007-4fdb-871a-9c9f32bee16c.png)

<font style="color:rgba(0, 0, 0, 0.9);">在战略设计阶段，参考过程模型的实践包括：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852184859-38167941-4394-42a2-97ba-0165746fa263.png)

<font style="color:rgba(0, 0, 0, 0.9);">如果当前限界上下文属于核心子领域，则应该为该限界上下文开展领域模型驱动设计，这一阶段的参考过程模型包括：  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852183818-2028d706-39d3-4f9e-9c50-2723b4664911.png)

## <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计能力评估模型</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">借助领域驱动设计魔方与领域驱动设计参考过程模型引入的各种方法与模式，我建立了一套领域驱动设计能力评估模型。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计能力评估模型（Domain-driven design Capability Assesment Model， DCAM）是我个人对领域驱动设计经验的一个提炼，可以通过它指导团队进行能力的培养和提升。  
</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852183871-1c344b42-0a48-4138-971e-37766bc126d0.png)

<font style="color:rgba(0, 0, 0, 0.9);">DCAM并非一个标准或一套认证体系，更非事先制定和强制执行的评估框架。建立这套模型的目的仅仅是为了更好地实施领域驱动设计，它是一个能够不断演化的评估框架。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852184312-949838e7-772d-4ebb-91ea-8d2e4b8813d9.png)

<font style="color:rgba(0, 0, 0, 0.9);">该能力评估模型针对的能力维度包括：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">敏捷迭代能力</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">领域建模能力</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">架构设计能力</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">整洁编码能力  
</font>

### <font style="color:rgba(0, 0, 0, 0.9);">敏捷迭代能力  
</font>
![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852184333-e8a91d87-9f0e-40f5-b203-4cb3a5c638de.png)

### <font style="color:rgba(0, 0, 0, 0.9);">领域建模能力  
</font>
![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852184472-e4ace345-bc9f-4329-ba8f-6fda8cae2583.png)

### <font style="color:rgba(0, 0, 0, 0.9);">架构设计能力  
</font>
![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852184531-eb9d67f8-c757-47a4-9888-e3a9607e8485.png)

### <font style="color:rgba(0, 0, 0, 0.9);">整洁代码能力  
</font>
![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852185019-bd83667d-6a6d-429f-8324-d3b6d3765b96.png)

<font style="color:rgba(0, 0, 0, 0.9);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计的落地取决于一个成熟的领域驱动设计团队。利用DCAM对团队进行评估，在发现团队成员的能力短板后进行针对性的培训，一旦提升了整个团队的成熟度，在领域驱动设计的精髓指导下，距离领域驱动设计的成功就不远了！</font>

# <font style="color:rgba(0, 0, 0, 0.9);">软件系统中的模型</font>
从领域驱动的战略设计进入战术设计，简单说来，就是跨过系统视角的限界上下文边界进入它的内部，从分层架构的逻辑分层进入到每一层的内部。在思考内部的设计细节时，首先需要思考的问题就是：什么是模型（Model）？



还是来看看Eric Evans对模型的阐述：

> 为了创建真正能为用户活动所用的软件，开发团队必须运用一整套与这些活动有关的知识体系。所需知识的广度可能令人望而生畏，庞大而复杂的信息也可能超乎想象。模型正是解决此类信息超载问题的工具。模型这种知识形式对知识进行了选择性的简化和有意的结构化。适当的模型可以使人理解信息的意义，并专注于问题。
>



如何才能让“庞大而复杂的信息”变得更加简单，让分析人员的心智模型可以容纳这些复杂的信息呢？那就是利用抽象化繁为简，通过标准的结构来组织和传递信息，形成一致的可以进行推演的解决方案，这就是“模型”。模型反应了现实问题，表达了真实世界存在的概念，但它并不是现实问题与真实世界本身，而是分析人员对它们的一种加工与提炼。这就好比真实世界中的各种物质可以用化学元素来表达一般，例如流动的水是真实世界存在的物体，而“水（Water）”这个词则是该物体与之对应的概念，$ H\_2O $则是水的模型（同时，$ H\_2O $也是化学世界中的统一语言）。



模型往往会作为交流的有效工具，因而会要求用经济而直观的形式来表达，其中最常用的表现形式就是图形。例如轨道交通线网图：

![](http://zhangyi.xyz/model-of-software-system/beijing-metro.gif)

说明：本图来自[本地宝](http://bj.bendibao.com/ditie/linemap.shtml)的北京城市轨道交通线网图。



该交通线网图体现了模型的许多特点。首先它是抽象的。与地图不同，它并非现实世界中轨道交通线网的缩影，图中的每条轨道其实都是理想化的几何图形，以线段为主，仅仅展现了轨道线的方位、走向和距离。其次它利用了可视化的元素。这些元素实际上都是传递信息的信号量，例如使用不同的颜色来区分线路，使用不同大小的形状与符号来区分普通站点与中转站。模型还传递了重要的模型要素，例如线路、站点、站点数量、站点距离、中转站以及方向，因为对于乘客而言，仅需要这些要素即可获得有用的路径规划与指导信息。



针对现实世界的问题域建立抽象的模型形成解决方案，这个过程视软件复杂度而定，可能会非常漫长。这其间需要迭代的分析、设计和实现，逐步浮现出最终可行的方案，构建满足需求的软件。从问题域到解决方案域，或许有多种途径或手段，然而针对复杂问题域，通过建立抽象的模型来映射现实世界的多样性，就好似通过数学公式来求解一般，是实践证明可行的道路：

![](http://zhangyi.xyz/model-of-software-system/model01.png)



模型的重要性并不体现在它的表现形式，而在于它**传递的知识**。它是从需求到编码实现的知识翻译器，通过它对杂乱无章的问题进行梳理，消除无关逻辑乃至次要逻辑的噪音，然后再按照知识语义进行归纳与分类，并遵循设计标准与规范建立一个清晰表达业务需求的结构。这个梳理、归纳与分类的过程就是建模的过程，建立的结构即为模型。建模过程与软件开发生命周期的各种不同的活动（Activity）息息相关，它们之间的关系大体如下图所示：

![](http://zhangyi.xyz/model-of-software-system/model02.png)



建模活动用灰色的椭圆表示，它主要包括需求分析、软件架构、详细设计和编码与调试等活动，有时候，测试、集成与保障维护活动也会在一定程度上影响系统的建模。为了便于更好地理解建模过程，我将整个建模过程中主要开展的活动称之为“建模活动”，并统一归纳为分析活动、设计活动与实现活动。每一次建模活动都是**对知识的一次提炼和转换**，产出的成果就是各个建模活动的模型：

+ 分析活动：观察现实世界的业务需求，依据设计者的建模观点对业务知识进行提炼与转换，形成表达了业务规则、业务流程或业务关系的逻辑概念，建立**分析模型**。
+ 设计活动：运用软件设计方法进一步提炼与转换分析模型中的逻辑概念，建立**设计模型**，使得模型在满足需求功能的同时满足更高的设计质量。
+ 实现活动：通过编码对设计模型中的概念进行提炼与转换，建立**实现模型**，构建可以运行的高质量软件，同时满足未来的需求变更与产品维护。



整个建模过程如下图所示：

![](http://zhangyi.xyz/model-of-software-system/model03.png)



不同的建模活动会建立不同的模型，上图表达的建模过程体现了这三种模型的递进关系。但是，这种递进关系并不意味着分析、设计与实现形成一种前后相连的串行过程，而应该是分析中蕴含了设计，设计中夹带了实现，甚至在实现中回溯到设计，从而形成一种迭代的螺旋上升的演进过程。不过，在建模的某一个瞬间，针对同一问题，分析、设计与实现这三个活动不能同时进行，这就好似开发过程中不能同时戴上重构与功能实现这两顶帽子一般，它们其实是相互影响、不断切换与递进的关系。一个完整的建模过程，就是**模型驱动设计（Model-Driven-Design）**。



不仅仅是建模活动会对模型带来影响，设计者在面对业务需求时，关注的视角不同，抽象的设计思想不同，也会导致模型的不同，这就形成了从建模视角产生的模型分类。如果我们是以数据为核心，关注数据实体的样式和它们之间的关系，由此建立的模型就是“**数据模型**”。如果我们需要为系统外部的客户端提供服务，关注的是客户端发起的请求以及服务返回的响应，由此建立的模型就是“**服务模型**”。而领域驱动设计则强调以领域为中心，通过识别领域对象来表达业务系统的领域知识包括业务流程、业务规则和约束关系，由此建立的模型就是“**领域模型**”。这三种不同的模型，就是不同视角的模型驱动设计获得的结果。因此，整个模型驱动设计可以分为两个不同的维度来表现模型，即建模视角与建模活动。不同的建模视角驱动出不同的抽象模型，而不同的建模活动，也会获得不同抽象层次的模型。这两个维度表达的模型驱动设计如下图所示：

![](http://zhangyi.xyz/model-of-software-system/model04.png)



无论分析模型、设计模型还是实现模型，它们皆是对现实世界的抽象，只是抽象的层次和目的不同罢了。如何观察现实世界，又可能影响我们最终获得的模型。当我们将现实世界视为由数据组成的系统时，就可以建立一个由数据实体概念组成的软件世界，并驱动着获得**以数据模型为核心的解决方案**。当我们将现实世界隐喻为一个Web系统时，现实世界的任何事物都是暴露给Web系统的资源，这就获得了**以服务资源模型为核心的解决方案**。当我们将现实世界认为是提供服务行为的容器，并由此产生与消费者的协作，就获得了**以服务行为模型为核心的解决方案**。当我们将现实世界看做是由核心领域与子领域组合而成的问题域时，我们就将围绕着领域模型为核心，驱动并指导着我们的设计，形成**以领域模型为核心的解决方案**。



Eric Evans认为模型驱动设计是领域驱动设计中的一种模式。它并没有给出模型驱动设计的定义，只是提出“严格按照基础模型来编写代码，能够使代码更好地表达设计含义，并且使模型与实际的系统相契合。”但我认为，模型的范围要大于领域模型，设计过程也会因为建立模型的不同而各有不同的路径与方向。于是，数据视角产生数据模型驱动设计，服务视角产生服务模型驱动设计，领域视角则产生领域模型驱动设计。在模型驱动的设计过程中，我们获得的模型还将受到建模范式的影响，尤其针对设计与实现，建模范式就意味着设计思想与编程范式的不同，最后获得的模型可能会大相径庭。



因此，要理解和学习领域驱动设计，我们需要辨别各种模型的差异，理解建模范式对模型产生的影响，同样还要认识到：领域驱动设计不过是模型驱动设计中的一种罢了。

# <font style="color:rgb(85, 85, 85);">领域驱动设计揭秘</font>
<font style="color:rgb(85, 85, 85);">我在2020年领域驱动设计中国峰会的分享，主题为：领域驱动设计揭秘。分为四个部分：</font>

+ <font style="color:rgb(85, 85, 85);">领域驱动设计 vs. 数据驱动设计</font>
+ <font style="color:rgb(85, 85, 85);">领域驱动设计的黑铁时代和黄金时代</font>
+ <font style="color:rgb(85, 85, 85);">单体架构是邪恶的吗</font>
+ <font style="color:rgb(85, 85, 85);">领域驱动设计的不足与领域驱动设计统一过程</font>

## <font style="color:rgb(85, 85, 85);">领域驱动设计 vs. 数据驱动设计</font>
<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">通过比较领域驱动设计和数据驱动设计，探讨为何基于数据库进行设计容易催生出贫血模型与事务脚本，指出领域驱动设计与数据驱动设计的不同之处在于限界上下文和聚合。</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">拙著《解构领域驱动设计》特别强调了限界上下文和聚合的重要性，分别将其称之为是基本的架构单元和设计单元。限界上下文与聚合的引入，也是领域驱动设计有别于面向对象设计的根本特征。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1719029383857-4aa4b5cb-a0a0-4e40-b5ad-a2e6031d11b8.png)

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1719029428592-403cae99-be20-4c9a-a397-269c2e9a78ae.png)

## <font style="color:rgb(85, 85, 85);">领域驱动设计的黑铁时代和黄金时代</font>
<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">由此引出我对诞生于2003年的领域驱动设计为何得不到广大程序员青睐的原因。</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">除了在团队管理、需求管理和项目管理方面，领域驱动设计提出了更高要求之外，多数软件设计人员并未认识到限界上下文与聚合的价值；相反，由于限界上下文与聚合边界对设计的诸多限制和约束，程序员更倾向于选择简单的事务脚本和贫血模型的设计模式，更何况，大多数早期软件系统并无高并发、高可靠等质量属性的压力，无法预见到限界上下文在应对架构演进时的重要意义，故而更愿意选择重用领域逻辑的单体架构。这样的单体架构缺少限界上下文的边界保护，随着需求的变化和时间的推移，较容易成为大泥球。直到微服务的诞生——</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1719029557840-e0a15cb3-6c01-4781-954f-4d87ba1f7bd9.png)

<font style="color:rgb(85, 85, 85);">大多数软件设计人员充分认识到，原来，十余年前领域驱动设计的限界上下文已经给出了微服务的边界约束，只不过一个是逻辑边界，一个是物理边界罢了。</font>

## <font style="color:rgb(85, 85, 85);">单体架构是邪恶的吗</font>
![](https://cdn.nlark.com/yuque/0/2024/png/859018/1719029591331-334573d8-f88e-4a05-ab52-1d34e4bddd26.png)

<font style="color:rgb(85, 85, 85);">在限界上下文边界约束下的单体架构并不邪恶，只是相较于微服务而言，它的重用成本更低，无法在有效边界隔离下制止那些肆意穿越限界上下文边界形成领域模型重用的调用，从而得到了这一恶名。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1719029638572-1a35411a-2240-4422-b9b9-a7f9ab588d9c.png)

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1719029670055-38af774e-0f47-4bf0-975f-b38d28a86435.png)

<font style="color:rgb(85, 85, 85);">因此，我在整洁架构与六边形架构的基础上提出了菱形对称架构，希望在代码模型和设计原则上促进开发人员认识到边界的约束力，提高整个系统架构的演进能力。</font>

## <font style="color:rgb(85, 85, 85);">领域驱动设计的不足与领域驱动设计统一过程</font>
<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">我承认领域驱动设计无论伦比的设计魅力，尊敬Eric Evans卓越的洞见与设计前瞻能力，但也不讳言领域驱动设计本身存在的不足。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1719029701232-86264b64-93e7-488c-9182-115919551fd6.png)

<font style="color:rgb(85, 85, 85);">这几年，领域驱动设计随着微服务的流行变成了显学，但领域驱动设计不是“银弹”，既然如此，领域驱动设计统一过程（DDD-UP）就更不是“银弹”了，它不过是对领域驱动设计的一种补充和完善罢了。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1719029740457-1d0d42c4-5a4a-4773-8fec-414bc69916ec.png)

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1719029774522-95fcc6ae-49f9-4d86-be03-5afb41aecc5a.png)

<font style="color:rgb(85, 85, 85);">浸淫软件设计近二十年，我越来越觉得设计玩不得玄虚，不要认为设计是一种“道”，它自有不可言说之处，但那种高妙不是高冷，更不是“道可道非常道”，关键还是落地。若能提供一种简便实用的方法让一套方法体系更容易落地，何乐而不为？！理论体系当然重要，但更重要的是能够真正将方法体系运用到软件构建中，降低开发门槛，提升设计与编码质量，这才是实证主义的态度。</font>

# <font style="color:rgba(0, 0, 0, 0.9);">建立领域驱动设计统一过程</font>
<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计肇始于Eric Evans出版于2004年的著作《Domain-Driven Design-Tackling Complexity in the Heart of Software》： </font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852454246-a3f6851a-0afd-4bc5-a9c1-8acc6356cc3e.png)

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计作为一个软件系统综合分析和设计的面向对象建模过程，如今已经发展为一种针对大型复杂系统的领域建模过程体系。</font>



<font style="color:rgba(0, 0, 0, 0.9);">它改变了传统软件开发工程师针对数据库建模的方法，而是面向领域，将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承、多态等设计要素，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。</font>

## <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计元模型</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计的立意是建立以领域为驱动力的过程体系，在这一核心驱动力的设计思想指导下，并没有死板僵化的构建过程来约束你。Eric Evans定义了一套领域驱动设计元模型，该模型由诸多松散的模式构成：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703852488930-7002aa8b-fc91-4739-9362-4de81fd85288.png)



<font style="color:rgba(0, 0, 0, 0.9);">至今，这套元模型在领域驱动设计的实施中仍然发挥着重要作用。</font>



<font style="color:rgba(0, 0, 0, 0.9);">显然，领域驱动设计是开放的。从领域驱动设计诞生至今，整个社区并未放弃发展其体系的努力，也诞生了许多重要的补充模式，例如以“领域事件（Domain Event）”为核心的诸多模式：事件溯源（Event Sourcing）、CQRS模式等。</font>



<font style="color:rgba(0, 0, 0, 0.9);">随着微服务和中台战略的兴起，领域驱动设计元模型中的限界上下文（Bounded Context）、核心领域（Core Domain）又得到了空前绝后的重视。</font>



<font style="color:rgba(0, 0, 0, 0.9);">然而，在团队运用和实践领域驱动设计过程中，整套体系始终存在力有未逮之处。毕竟，领域驱动设计是否能够取得成功，不只限于一两位精通领域驱动设计的专家就可以力挽狂澜。团队成员的能力、管理规范等诸多因素都会影响整个实践的过程。</font>

## <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计的不足</font>
<font style="color:rgba(0, 0, 0, 0.9);">据我个人的经验和对实施领域驱动设计的反思，认为现行的领域驱动设计存在以下四个不足。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">不足之一</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">Eric Evans构建的领域驱动设计元模型并不足以支撑软件的构建过程。这些模式之间虽然彼此影响，运用得当就能形成设计合力；然而模式的粒度并不均衡，运用上极为随意，缺乏一个统一的过程指导。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">虽然领域驱动设计划分了战略设计阶段与战术设计阶段，但这两个阶段的划分仅仅是对构成元模型的模式进行类别上的划分，例如将限界上下文、上下文映射等模式划分到战略设计阶段，将聚合、实体、值对象等模式划分到战术设计阶段。</font>



<font style="color:rgba(0, 0, 0, 0.9);">缺乏一个统一的过程去规范这两个阶段需要执行的活动、交付的工件以及阶段里程碑。Eric Evans没有清晰定义这两个阶段该如何衔接，它们之间执行的工作流到底是怎样的。</font>



<font style="color:rgba(0, 0, 0, 0.9);">除了极少数精英团队，大多数团队都需要一个清晰的软件构建过程，否则将茫然不知所措。领域驱动设计没能形成这样的统一过程，就使得其缺乏可操作性，团队在运用领域驱动设计时，更多取决于设计者的行业知识与设计经验，使得领域驱动设计在项目上的成功存在较大的偶然性。</font>



<font style="color:rgba(0, 0, 0, 0.9);">因此，领域驱动设计缺乏一个规范的过程指导，是其不足之一。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">不足之二</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计倡导以“领域”为核心驱动力，无论是对领域知识的抽象还是精炼，本质上都是针对问题域的业务需求。</font>



<font style="color:rgba(0, 0, 0, 0.9);">可是，业务需求是如何获得的呢？获得的业务需求应该具备什么样的特征？业务需求的粒度和层次是怎么定义的？该如何规范和约定团队各个角色对需求分析的参与？以及在不同的阶段，业务需求的表现形式与验证标准分别是什么？</font>



<font style="color:rgba(0, 0, 0, 0.9);">种种问题，领域驱动设计都没有给出答案，甚至根本就未提及！虽然说这些问题都可以纳入到需求管理体系，故而可以认为它们游离于领域驱动设计之外；可是，不同层次的业务需求贯穿于领域驱动设计过程中的每个环节，识别限界上下文需要对业务需求和业务流程有着清晰的理解，建立领域模型需要的领域知识和概念也都来自于用户故事层次的业务需求。毫无疑问，需求管理体系会直接影响领域驱动设计的质量。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">因此，领域驱动设计没有匹配的需求管理体系，是其不足之二。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">不足之三</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计战略阶段的核心模式是限界上下文，指导架构设计的主要模式是分层架构，前者决定了业务架构，后者决定了系统架构。</font>



<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计的核心诉求是让业务架构和系统架构形成绑定关系，以面对需求变化时，使得系统架构能够适应业务架构的调整，满足架构的演进性。领域驱动设计虽然给出了这些模式的特征，却失之与简单松散，不足以支撑复杂软件项目的架构需求。</font>



<font style="color:rgba(0, 0, 0, 0.9);">因此，领域驱动设计缺乏面向领域的架构体系，是其不足之三。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">不足之四</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计以模型驱动设计为主线，却没有给出明确的领域建模方法。</font>



<font style="color:rgba(0, 0, 0, 0.9);">无论是否采用敏捷的迭代建模过程，建模分为分析、设计与实现这三个不同的活动确是客观存在的事实。虽然我们必须努力保证领域模型的一致性，但这三个活动存在明显的存续关系，每个活动的目标、参与角色与建模知识存在本质差异，这也是客观存在的事实。</font>



<font style="color:rgba(0, 0, 0, 0.9);">基于此，我们需要分别为领域分析建模、领域设计建模和领域实现建模提供对应的方法指导，减轻每个建模活动的知识负担，明确每个建模活动获得的领域模型的验证标准，避免领域建模的随意性。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">因此，领域驱动设计没有领域建模固化流程的支撑，是其不足之四。</font>

## <font style="color:rgba(0, 0, 0, 0.9);">精简和丰富知识体系</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">针对领域驱动设计的四个不足，我对领域驱动设计的知识体系进行了精简与丰富。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">精简，意味着做减法，就是要剔除领域驱动设计元模型中不太重要的模式，凸显核心模式的重要性，并对领域驱动设计过程进行固化，提供更为直接有效的实践方法，建立具有目的性和操作性的构建过程。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">丰富，意味着做加法，就是突破领域驱动设计的范畴，扩大领域驱动设计的外延，引入更多与之相关的知识体系来丰富它，弥补自身的不足。</font>



<font style="color:rgba(0, 0, 0, 0.9);">要构建全新的领域驱动设计体系，还需要匹配软件构建的目标。软件构建就是不断对问题域求解，获得解决方案进而组成完整解决方案域的过程。若要构建优良的软件系统，那么在这个构建过程中，还需要控制软件的复杂度。因此，我们需要在问题域与解决方案域的背景下定义能够控制软件复杂度的领域驱动设计过程，并将体系的内容限定在领域关注点的边界之内，避免体系的扩大化。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">既然要支持软件构建过程，就需要结合项目的管理过程。</font>



<font style="color:rgba(0, 0, 0, 0.9);">项目的管理过程姿态万千，如何与领域驱动设计结合，却属于空白区域。</font>



<font style="color:rgba(0, 0, 0, 0.9);">例如，当团队采用Scrum过程时，产品待办项（Product Backlog）与冲刺待办项（Sprint Backlog）与领域驱动设计要建模的领域知识有什么关系？当开发人员领取一个用户故事进行开发时，是否意味着在此时才开始领域建模？什么时候开始识别整个系统的限界上下文，又到什么时候结束这一业务架构的分析工作？</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">如果采用RUP来指导软件的构建，那么该如何区分业务建模与领域驱动设计之间的关系？在领域驱动设计中，用例起到了什么样的作用？在设计基于组件的系统架构时，这些可重用的组件是否就等同于限界上下文呢？</font>

## <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计统一过程</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">鉴于此，我们构建的领域驱动设计体系就必须形成一个统一过程。</font>



<font style="color:rgba(0, 0, 0, 0.9);">宏观层次，以需求管理体系和面向领域的架构体系为支撑；微观层次，通过领域建模固化流程来保障解决方案的落地；同时糅合领域驱动设计元模型中有价值的模式作为参考，甚至形成能够重复执行的最佳实践。</font>



<font style="color:rgba(0, 0, 0, 0.9);">如此，就可以使得这一体系做到规范与松散互补充，固化与开放相结合。我将这一体系称之为“领域驱动设计统一过程（Domain-Driven Design Unified Process，简称为DDD-UP）”：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1720447463565-fe675004-3662-4c83-8210-c27485c21052.png)

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计统一过程参考了RUP的结构，整个过程用两个坐标轴来表达：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">横轴代表了推动领域驱动设计在构建过程中的时间，体现了过程的动态结构，构成元素包括阶段（Phase）、迭代（Iteration）。其中阶段又分为三个阶段，分别为：全局分析阶段、架构规划阶段和领域建模阶段。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">纵轴表现了领域驱动设计在各个阶段中执行的工作，体现了过程的静态结构，构成元素包括角色（Workers）、工作流（Workflow）和元模型模式（Pattern）或方法（Method）。</font>

<font style="color:rgba(0, 0, 0, 0.9);">采用这一结构的目的就是希望为领域驱动设计引入一个规范而统一的过程，让团队在实施领域驱动设计可以变得有章可依，有章可循，而不仅仅是靠一两个人的经验来决定成功的高度。</font>

# <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计统一过程交付物</font>
我在《解构领域驱动设计》一书中定义了领域驱动设计统一过程，将整个领域驱动设计过程分为了三个阶段：

+  全局分析阶段 
+  架构映射阶段 
+  领域建模阶段 



我还在书中的附录D给出了领域驱动设计统一过程的交付物。不过，随着我在多个项目中实践领域驱动设计统一过程，我发现定义在交付物的一些关键元素需要更好的表现方式，也需要形成一个统一的标准。为了帮助各位《解构领域驱动设计》的读者在项目中更好地运用领域驱动设计统一过程，并输出高质量的统一而标准的交付物，特别作此文以补充。



为保证交付物的完整性，个别未做更新和改进的内容仍然在本文中有所呈现，各位读者可以自行对比文中和书中的内容。



## 全局分析阶段


### 业务流程


梳理问题空间的业务需求，获得用泳道图表现的业务流程：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706853091031-28b73e19-880f-4114-8169-58b608ea00ac.png)

### 业务服务


根据业务服务的定义分析业务流程，识别出业务服务，并以业务服务图（参考用例图）形式表示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706853091119-f4b19029-d281-4bb7-ab4e-6493ae49f163.png)



说明：如果采用敏捷方式管理需求，可以将业务服务作为用户故事的子任务，它不包括前端的交互设计和开发内容。



如果需要进一步细化业务服务，则需要按照如下格式编写业务服务规约：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706853091030-16138ba6-e1b1-4921-9eb5-bc66d390911a.png)



编写业务服务规约时，需要遵循统一语言。



以上内容，可以构成目标系统的需求规格说明书。

## 架构映射阶段


### 系统上下文


系统上下文用于呈现目标系统的系统边界，明确目标系统与角色、伴生系统之间的关系。可以通过改进的系统上下文图来表示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706853091057-6777d3fb-29f1-406a-8fac-07f89172b912.png)



改进的系统上下文有效地利用了四个方位：

+  上方：代表北向，即调用目标系统的伴生系统或模块 
+  下方：代表南向，即目标系统调用的伴生系统或模块 
+  左方：代表使用目标系统的所有角色 
+  右方：代表互相调用的伴生系统或模块 



### 限界上下文


#### 识别限界上下文


运用服务风暴法，识别限界上下文，建立业务服务与限界上下文的映射关系，并以下图形式呈现出来：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706839147529-e4a02d32-76f8-465a-a126-3ccda90a9a06.png)

图中的菱形代表限界上下文，椭圆形代表业务服务。



#### 确定上下文映射


针对每一个业务服务，通过业务服务规约绘制服务序列图，以确定限界上下文之间的协作关系，并驱动出每个限界上下文的服务契约。绘制服务序列图时，根据业务服务规约“成功场景”部分的流程，确定每个流程步骤需要的领域知识和领域职责应该由哪一个限界上下文负责。服务序列图如下所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706839166410-2285c9ee-2905-4827-b454-ab3afa238688.png)

通过服务序列图，既可以明确限界上下文之间的关系，又可以驱动出每个限界上下文包括伴生系统的服务契约（API），同时还能够确定协作模式，包括客户方-供应方模式和发布者-订阅者模式。其中，查询和命令方式属于客户方-供应方模式，事件方式属于发布者-订阅者模式。服务契约可以通过下表格式表示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706839199281-f6e8719d-d4fa-4dc2-8fb5-d0a8c3e7bfc6.png)



服务契约的API定义也可以在Swagger中维护。



最后，可以通过如下图示表示限界上下文：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706839217114-fe3d3818-ce4a-4ba4-bc73-1b17c131d659.png)



与改进的系统上下文图相似，限界上下文图也有效地利用了四个方位：

+  上方：代表北向服务，为当前限界上下文对外公开的服务接口 
+  下方：代表南向服务，为当前限界上下文调用上游限界上下文或伴生系统的服务接口 
+  左方：当前限界上下文订阅的事件 
+  右方：当前限界上下文发布的事件 



限界上下文内部可以呈现属于当前限界上下文领域模型的聚合，如果还未开展领域建模，可以为空。



### 菱形对称架构


限界上下文的内部应遵循如下图所示的菱形对称架构：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706846064648-07927bbf-4dd0-4fc8-aca5-51a65fd572b2.png)



菱形对称架构的核心思想：

+  内外分离：内部的领域层与外部的网关层分离，保证业务和技术的正交性 
+  南北对称：南向网关采用抽象思想，隔离外部资源变化对内部领域层带来的影响；北向网关采用封装思想，通过定义远程服务和本地服务隔离内部领域逻辑对外部调用者的影响 



### 系统分层架构


在目标系统层面上，需要将各个限界上下文组织在如下图所示的系统分层架构中：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706846085714-9a8de1ef-80bf-4fd2-bed9-089ad3e97db6.png)



### 代码模型


遵循菱形对称架构，一个完整的代码模型如下所示：

+ valueaddedlayer
    - boundedcontext
        * north
            + remote
                - resource
                - controller
                - provider
                - subscriber
            + local
            + message
        * domain
            + aggregate
                - entity
                - valueobject
                - domainservice
        * south
            + port
                - repository
                - client
                - publisher
            + adapter
                - repository
                - client
                - publisher
            + message



以上内容构成了目标系统的架构设计文档。

## 领域建模阶段


### 领域分析建模


领域建模阶段是通过对业务服务规约进行领域分析建模开始的。领域分析建模与具体的建模技术和设计方法没有任何关系，只是从业务的角度通过提取领域概念获得最终的领域分析模型。该方法为快速建模法，得到的模型如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706846307007-915eb7f4-821e-4a50-9ae4-2fe89510f693.png)

图中的灰色领域概念是通过动词建模法获得的。整个领域分析模型需要分配给对应的限界上下文。

### 领域设计建模


#### 静态设计模型


领域设计建模从下图所示的领域分析模型开始：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706846348049-57c4e003-56f0-4d36-bfec-87779648b0be.png)



识别实体和值对象：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706846364015-368b438d-0c55-40e2-b506-6acd4833337b.png)



确定实体之间的关系：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706846384617-76f74365-3138-46a8-8122-8fd784b14672.png)



根据实体关系的强弱划定聚合的边界，获得以聚合为中心的领域设计模型：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706846399774-929dde2d-27a7-4376-8f57-f9c67f6cfd05.png)



#### 动态设计模型


获得动态设计模型的过程如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706846420091-f9068517-2acc-49f6-861f-aac09c177ec6.png)



分析业务服务，获得如下所示的业务服务规约：

服务编号：033

服务名：报名活动

服务描述：

作为报名人

我想要报名活动

以便于预留活动报名资格



触发事件：

报名人选择自己想要报名的活动，点击“报名”按钮



基本流程

1. 检查报名人是否有效

2. 检查报名通道是否已关闭

3. 检查该报名人是否已报名

4. 完成报名预约

5. 发送报名预约成功的通知



替换流程

1.a 若报名人无效，给出提示信息

2.a 如果报名通道已关闭，给出提示信息

3.a 如果已报名，给出提示信息

4.a 如报名失败，给出失败原因



验收标准：

1. 报名人必须是活动所属部落的会员

2. 报名达到截止日期或者报名人数已到达上限，则视为报名通道已关闭

3. 报名人不能重复报名

4. 完成报名后，报名状态设置为“已预订”

5. 报名人接收到预约成功的通知



根据业务服务规约获得如下所示的任务树：

+ 报名活动
    - 验证报名
        * 验证报名人是否会员 --- 访问部落上下文
        * 确定报名通道是否已关闭
            + 获取报名通道
            + 确定是否已关闭
        * 验证报名单 ---- Repository
    - 生成报名单  --- Repository
    - 更新报名通道
        * 加载报名通道
        * 更新
        * 保存报名通道
    - 发送报名预约成功的通知  --- 通知上下文



分配职责给对应的角色构造型，形成序列图脚本：

```java
TicketController.enrollActivity(EnrollingRequest) {
    TicketAppService.enrollActivity(EnrollingRequest) {
        Ticket ticket = EnrollingRequest.to()
            TicketService.enrollActivity(ticket) {
            TicketService.validate(ticket) {
                MemberClient.isMember(enrollerId, tribeId)
                    EnrollingChannelService.isClosed(activityId) {
                    EnrollingChannel channel = EnrollingChannelRepository.channelOf(activityId)
                        channel.isClosed()
                    }
                TicketRepository.isExists(enrollerId, activityId, TicketStatus)
                }
            TicketRepository.add(ticket)
                EnrollingChannelService.occupiedBy(activityId) {
                EnrollingChannel channel = EnrollingChannelRepository.channelOf(activityId)
                    channel.occupiedWith(1)
                    EnrollingChannelRepository.save(channel)
                }
        }
        ActivitySubscribedPublisher.publish(ActivitySubscribed)
        }
}
```



领域建模阶段输出的静态领域设计模型与动态领域设计模型共同组成限界上下文的设计文档。



领域驱动设计统一过程构成了我的著作《解构领域驱动设计》主体框架，该方法框架可以帮助团队有章可循地实施领域驱动设计。



2022年7月5日

# 系统思维与领域驱动设计过程


运用系统思维，可以有效地帮助人们理解目标系统的行为及表现，为系统的设计提供支持，或者为系统设计决策或判断提供指导。



领域驱动设计作为一个针对大型复杂业务系统的领域建模方法体系，自然也可以借鉴系统思维来优化领域驱动设计的设计过程。

![](https://mmbiz.qpic.cn/mmbiz_jpg/d3Qa7X5fakDVvCXWJvUQHG0uXmGUYjozlSJLArc3rQvJlhpGtHt4DCXTmJC8tMWLHblH9b1oibQiasd2yPTu0O8A/640?wx_fmt=jpeg&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)



Edward Crawley在《系统架构》一书中讲解了四种对系统思维有益的任务：

+  任务一：确定系统及其形式与功能 
+  任务二：确定系统中的实体及其形式与功能，以及系统的边界及系统所处的环境 
+  任务三：确定系统中各个实体之间的关系以及位于边界处的关系，并确定这些关系的形式及功能 
+  任务四：根据实体的功能及功能性的互动来确定系统的涌现属性 



这四个任务实际上可以理解为是系统思维的四个执行步骤。通过深入分析这四个任务，可以隐隐约约看到领域驱动设计过程的影子。



**任务一**提到的“形式”，在《系统架构》一书中的解释是：

> 指这个系统是什么样子，它是一种已然存在或有可能存在的物质载体或信息载体。
>



> 通俗地说，就是描述系统到底什么，要达成什么样的目标，也就是要明确系统的愿景和范围。
>



功能是由过程（process）或操作数（operand）组成的，在系统层面，可以将功能理解为由业务流程、业务场景和业务活动组成的业务需求。



如果遵循系统思维的第一项任务，采用领域驱动设计，就是要完成对目标系统问题空间的探索与分析，表现出来的形式就是由业务流程、子领域以及业务功能（业务服务）构成的业务架构。



实体这一概念出现了在了不同的场合。系统思维任务二提到的实体，并非领域驱动设计模式中的实体，而是一种架构单元，是对目标系统进行功能分解的软件元素，属于解空间的一部分。



一言以蔽之，就是战略模式中的限界上下文。



限界上下文属于解空间内部的基本单元。但在进行架构战略设计时，还不能忽略目标系统的系统边界及它所处的环境。我将C4模型中的系统上下文“借”到了领域驱动设计中，用以清晰呈现系统边界以及系统与外部环境的关系。



任务二在确定了系统上下文，并将系统上下文分解为多个限界上下文之后，到了任务三，就是要确定系统内部限界上下文彼此之间的关系，以及限界上下文与外部环境之间的关系。

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakDVvCXWJvUQHG0uXmGUYjoz9c2FDPbIpRjEib2PhYrSdOyqQdY3WsNNhgAavlMVV0e1ic9tANouWRlw/640?wx_fmt=png&from=appmsg&wxfrom=5&wx_lazy=1&wx_co=1)



这是领域驱动设计中上下文映射所要表达的。我提出的“菱形对称架构”可以在架构模式层面弥补战略设计的不足，既能确保限界上下文的自治性，又可以规定统一的代码模型，以便于获得一个边界清晰，方案一致的架构。



系统思维的第四项任务需要“预测涌现物”。Edward Crawley总结了预测涌现物的四种方式：先例、试验、建模与推理。



先例就是就是根据以前做过的案例来预测。一个比较好的输入是寻找相似领域的解决方案或抽象模式，例如Martin Fowler总结的分析模式，Peter Coad在彩色UML中总结的各行业模型，当然也可以是自己曾经做过的项目或产品。



试验就是挑选一个小模块进行快速迭代，快速实现，以验证方案的合理性。领域驱动设计提倡识别核心领域，也推崇以极限编程的实践进行迭代的快速建模。如果还能通过先例阶段找到与该核心领域相似的方案，就可以尝试着挑选属于核心领域的某个限界上下文，快速开展建模。



建模是领域驱动设计最核心的内容。从战略到战术，通过对限界上下文的领域知识建立领域模型，就可以保证系统分解出来的实体（通过限界上下文体现出来的部分）在组合成目标系统这一整体时，要大于这些实体各自独立体现的功能。



如果找不到先例，就不能进行试验性的建模，这时可以采用推理。在推理的过程中，可以从一些相似但不同的系统中了解一些信息，也可以通过不完备的建模来得到一些信息来对最终的涌现物进行判断。



系统思维是认知客观世界的一种有效思维方式，尤其在面对大型的复杂系统时，对系统思维的运用可以减少认知过程的不确定性。尤其在宏观层面上，“系统思维的目标是令我们能够对系统进行思考。我们身边充满了各种各样的系统，这些系统越来越复杂，而系统思维应该使得我们可以把这些复杂的系统理解得不那么复杂。”



领域驱动设计的目的正是为了应对软件的核心复杂性，通过我们对其设计过程和系统思维的分析与比较，可以看到二者的一些共同特征，似乎从侧面证明了领域驱动设计的过程满足了系统思维的原则与方法，或者说，它也可以借鉴或吸收系统思维方法。



2023年12月11日

# <font style="color:rgba(0, 0, 0, 0.9);">《解构领域驱动设计》篇首语</font>
《解构领域驱动设计》在领域驱动设计统一过程的指导下，将该过程的全部三个阶段作为本书的三个核心篇章：全局分析、架构映射与领域建模，再辅以开篇和融合，共分为五篇二十五章，全面而完整地表达了我对领域驱动设计的全部认知与最佳实践。

## 开篇


开篇，明义。  
领域驱动设计需要应对软件复杂度的挑战！那么，软件复杂度的成因究竟是什么？又该如何应对？概括而言，即：

+ 规模：通过分而治之控制规模
+ 结构：通过边界保证清晰有序
+ 变化：顺应变化方向



领域驱动设计对软件复杂度的应对之道可进一步阐述为：

+ 规模：以子领域、限界上下文分而治之
+ 结构：以分层架构隔离业务复杂度与技术复杂度，形成清晰的架构
+ 变化：通过领域建模抽象为以聚合为核心的领域模型，响应需求之变化



子领域、限界上下文、分层架构与聚合皆为领域驱动设计的核心元模型，分属战略设计和战术设计，贯穿了从问题空间到解空间的全过程。



领域驱动设计的开放性是其生命长青的基石，但它过于开放的灵活性也让运用领域驱动设计的开发团队变得举步维艰。我之所以提出领域驱动设计统一过程，正是要在开放的方法体系指导之下，摸索出一条行之有效的软件构建之路。它既不悖于领域驱动设计之精神，又不吝于运用设计元模型，通过提供简单有效的实践方法，建立具有目的性和操作性的构建过程。



领域驱动设计统一过程分为三个阶段：

+ 全局分析阶段
+ 架构映射阶段
+ 领域建模阶段



每个阶段的过程工作流既融合了领域驱动设计既有的设计元模型，又提出了新的模式、方法与实践，丰富了领域驱动设计的外延。领域驱动设计统一过程对项目管理、需求管理与团队管理也提出了明确的要求，它们虽然不属于领域驱动设计关注的范畴，却是影响领域驱动设计实践与落地成功与否的重要因素。

  
领域驱动设计统一过程是对领域驱动设计进行解构的核心内容！

## 全局分析


解决问题的第一要务是明确问题，问题尚不知，就尝试求解，自然就是无的放矢了。全局分析的目标就是确定问题空间，在统一语言的指导下，通过各种可视化手段，由领域专家与团队一起完成对问题空间的探索，帮助领域驱动设计对准问题，输出价值需求和业务需求。



价值需求既是目标系统的目标，也是对目标系统问题空间的界定和约束，它指导着业务需求分析。业务需求由动态的业务流程和静态的业务活动组成，二者的结合依靠业务场景按照时间点和业务目标对业务流程的切分。通过运用商业模式画布，可以获得组成价值需求的利益相关者、系统愿景和系统范围。



业务流程的梳理可以帮助团队对问题空间的各条业务线构成一个整体认识，弄清楚各种角色如何参与到一个完整的流程中，流程的时序性也可以避免识别业务活动时可能出现的缺失。业务流程图与服务蓝图以可视化的方式形象地呈现每一个提供了业务价值的业务流程。



业务活动是角色与目标系统之间的一次功能性交互，是体现了服务价值的功能行为。一直以来，该如何确定业务需求层次，划分业务需求粒度，总是众说纷纭，没有一个客观的标准；业务活动将目标系统视为一个黑盒子，从功能性交互的完整性保证了每个业务活动都是正交的，就无需再考虑业务活动的层次和粒度，或者说，只要确定了完整性，保障了正交性，业务活动的层次与粒度也就确定下来了。业务活动可以使用用例、用户故事或事件风暴中的事件来表达。



业务活动是全局分析阶段的基本业务单元，它的输出对于架构映射与领域建模具有重要意义：

+ 架构映射：业务活动是识别限界上下文、确定上下文映射的基础，同时，它的粒度正好对应每个限界上下文向外公开的服务契约；
+ 领域模型：业务需求分析细化的业务活动既是领域分析建模的重要参考，同时又作为服务场景成为场景驱动设计的起点。



全局分析是领域驱动设计统一过程的起点，它的目的是探索问题空间，使团队就问题空间的价值需求和业务需求达成共识，并在统一语言的指导下将其清晰地呈现出来。只有问题定义清楚了，团队才能更好地寻求解决方案。

## 架构映射


架构映射对应解空间的战略设计层次。



本阶段，映射成为了获得架构的主要设计手段。价值需求中利益相关者、系统愿景和系统范围可映射为系统上下文，业务活动通过对业务相关性的归类与归纳可映射为限界上下文，二者又是构成系统架构的重要层次，前者勾勒出解空间的控制边界，后者勾勒出领域模型的知识边界，组成了一个稳定而又具有演进能力的领域驱动架构。  
限界上下文是架构映射阶段的基本架构单元，决定一个限界上下文边界的元素包括：领域对象、领域知识、角色和活动。限界上下文是领域模型的知识语境，又是业务能力的纵向切分，它满足自治单元的四个要素：最小完备、自我履行、稳定空间、独立进化。一个自治的限界上下文一定遵循菱形对称架构模式。



菱形对称架构模式将整个限界上下文分为内部的领域层和外部的网关层，网关层根据调用方向分为北向网关和南向网关。北向网关体现了“封装”的设计思想，根据通信方式的不同分为远程服务与应用服务；南向网关体现了“抽象”的设计思想，将抽象与实现分离，分为端口与适配器。在诸多上下文映射模式中，除了共享内核与遵奉者模式，都应在菱形对称架构网关层的控制下进行协作。



系统上下文对应了解空间的范围，它站在组织层面思考利益相关者、目标系统与伴生系统之间的关系。它通过系统分层架构体现目标系统的逻辑结构，并按照子领域价值的不同，为限界上下文确定了不同的层次。根据康威定律的规定，系统分层架构可以映射为由前端组件团队、领域特性团队与组件团队组成的开发团队。



限界上下文是顺应业务变化进行功能分解的软件元素，菱形对称架构规定了限界上下文之间、限界上下文与外部环境之间的关系，由系统分层架构模式与菱形对称架构模式组成的领域驱动架构风格则是指导架构设计与演进的原则。这些内容符合架构的定义，同时也是对控制软件复杂度的呼应。



领域建模要在架构的约束下进行，系统上下文和限界上下文的边界对领域模型起到了设计约束的作用。根据限界上下文的价值高低，属于支撑子领域和通用子领域的限界上下文，往往因为业务简单，无需进行领域建模，如此就能快速开发，降低开发成本。因此，架构映射是领域建模的前提，也可以认为是战略对战术的设计指导。

## 领域建模


领域建模的过程，是模型驱动设计的过程，也是迭代建模的过程。



不可妄求一蹴而就能获得完整的领域模型，也不可殚精竭虑地追求领域模型的尽善尽美。领域建模的分析、设计和实现是循序渐进的增量建模，建模目标与侧重点也不尽相同。



领域分析模型负责捕捉表示领域知识的领域概念，明确它们之间的关系，形成反映现实世界的对象概念图。获得的分析模型全面而粗疏，既不至于遗漏重要的领域概念导致模型的缺失，又不至于锱铢必较地因为过分定义领域属性而陷入分析瘫痪。



领域设计模型在领域分析模型的基础上加入对设计和实现的思考，为对象概念图戴上聚合的镣铐，在保证概念完整性、独立性、不变量与一致性的基础上，更好地管理对象的生命周期。场景驱动设计则赋予了领域模型以动能，在对服务场景进行任务分解的基础上，由外自内由各种角色构造型参与协作，形成了连续执行的消息链条，驱动出远程服务、应用服务、领域服务、聚合和各种端口的方法，既验证了领域模型对象的正确性与完整性，又丰富了领域模型的内容。



领域实现模型基于场景驱动设计输出的任务列表和序列图脚本开展测试驱动开发，领域层的产品代码与测试代码共同构成领域实现模型。由于拥有单元测试的保护，及时重构又改进了代码的质量，使得领域实现模型变得整洁而稳定，形成具有运行能力的核心领域资产。在实现领域模型时，也是对领域设计模型和领域分析模型的一次验证。



聚合是领域建模阶段的基本设计单元。领域分析模型向领域设计模型的演进是通过识别聚合完成的，聚合边界的约束能力使得领域设计模型在保证细粒度对象定义的同时，又能通过封装实体与值对象的细节简化对象模型，降低领域模型的复杂度。一旦确定了聚合，就可以由此定义资源库端口和领域服务，并按照信息专家模式将体现领域逻辑的原子任务分配给聚合，建立富领域模型。聚合是纯粹的，它不依赖于任何访问外部资源的端口，因此它也是稳定的；因为聚合是稳定的，使得围绕着它为核心建立的领域模型也变得更加稳定。

## 融合


融合，就是战略和战术的融合，为了让软件运行起来，还需考虑领域逻辑与技术实现的融合，即领域层与网关层的融合。



在战略层次，需在领域驱动架构风格的约束和指导下考虑限界上下文之间的协作，思考并决策限界上下文的通信边界，思考从单体架构向微服务架构的演进，同时，因为进程间通信引起的诸多影响，需评估分布式通信、事务以及受技术因素驱动的命令查询职责分离模式是否对领域模型造成了影响。



事实证明，遵循领域驱动架构风格的系统完全满足架构演进的要求，只需付出少量修改成本，即可支持单体架构、SOA架构、微服务架构与事件驱动架构，同时还满足了领域模型的稳定性。



在战术层次，通过建立设计概念的统一语言，保证团队在领域建模时避免因概念理解的偏差出现设计的不一致，甚至做出有违领域驱动设计理念的错误决策。通过领域模型驱动设计获得的领域模型还需要考虑如何与持久化结合，解决对象关系映射的阻抗不匹配问题，以更加优雅的方式实现资源库，保证作为端口的资源库实现不会侵入领域模型，破坏领域的纯粹性。



无论战略还是战术，抑或二者的融合，都需要在领域驱动设计知识体系的指导下进行。结合领域驱动设计社区的发展与我个人的设计经验，尝试对领域驱动设计做进一步梳理和升华，建立了全方位多维度的领域驱动设计魔方，基于领域驱动设计统一过程给出了具有可操作性的参考过程模型，提炼了领域驱动设计的精髓，面向团队给出领域驱动设计的能力评估模型，如此就能将方法、过程、模式有机地融合起来，给出行之有效的指导意见。

# 领域驱动设计随感录


本文内容来自我发表在知识星球中的一些片段感想，随手而记，记录思想片段，皆是针对领域驱动设计的感悟，因为不成体系，故而名为随感录。



## 随感录一


有时候在技术上确定限界上下文的边界反而是一件容易的事，不过就是按照DDD的设计思想依势而为罢了。虽然有by experience的因素，然则好歹是架构师可以掌控的。



真正难以控制边界的，其实是团队的边界和思维的边界。



要让团队成员能够放开自己的利己主义思想，愿意站在项目层次的高度看待工作边界，真的是太不容易了。如果团队来自不同的公司，就更是困难，对工作边界的划分会不断陷入到争吵、推诿、扯皮的泥潭中，最终还是走上各行其是的道路。很多时候，无论召开多少次协调会议，都不顶用。



要控制思维的边界，那简直就是天方夜谭了。团队成员不愿意改变固有的思维，不愿意接受新的思想方法，你怎么样推动、解释、演示和培训都没有作用，尤其对于那些已经习惯了惯性思维、乐于停留在舒适区的人而言。



## 随感录二


统一语言是团队各个角色达成正确且一致的业务语言。它不仅仅是语言，还是原则，是团队在描述领域知识时必须遵守的最高原则。领域知识包括领域概念、领域行为和领域规则。统一语言是DDD中唯一一个贯穿问题空间和解空间的原则。统一语言可以表现为自然语言、文档、UML图，但最终要通过代码来呈现。



## 随感录三


DDD战术设计的三个要点：

+  DDD强调领域建模，无论是设计还是开发，要从业务角度出发，而不能从数据库角度出发。先定义领域模型，然后再根据领域模型设计数据模型。我所说的数据模型是指数据库表的设计（schema），在DDD中，并不要求定义专门的数据模型对象与数据表对应，领域模型对象自身就扮演持久化对象的角色。 
+  Eric Evans的DDD是以OO编程范式为核心，所以任何战术设计的点，都要围绕着面向对象的思想来考虑。为什么DDD不赞成贫血模型？就是因为贫血模型与OO设计思想相悖。为什么不建议用基本类型？因为它缺乏对领域概念的封装。 
+  Eric Evans的DDD非常强调Aggregate，我认为这是战术层面上Eric的重要创见，因为它在设计层面多引入了一个边界概念。这个边界概念大于类、小于模块，恰恰是与所谓的“不变量（invariant）”（即一致性）刚刚对应起来。当然，这也是在战术设计层面DDD建模不同于OO建模之处。 



## 随感录四


DDD要实施成功，一个必要条件是整个团队都要按照DDD的方式开展，也就是遵守DDD纪律。



为了降低对成员能力的要求，我对DDD的一些实践做了简化，主要的简化就是围绕业务服务提出：

+  菱形对称架构：面向战略架构 
+  服务驱动设计：面向领域建模 



在实施DDD过程中，由于成员能力参差不齐，我的要求是：

+ 对于设计和编码突出的成员，可以打破设计方法和模式的约束，除此之外，其他成员需要严格遵循原则。



## 随感录五


今天回答读者群的一位群友问题，他苦恼于在针对业务进行建模时，设计UML找不到北。如他自己所说：“我清楚应该站在业务的层次去设计，但是我设计出来的UML感觉总是差点意思，技术体现太多了”。他问我：“虽然我知道是咋回事，但是我就是表达不出来。这种毛病有没有什么方法能解决？”



我的回答：



就像张三丰教张无忌太极剑一样，你需要学会忘记技术实现。就是从纯业务的角度去考虑。我的书中将整个领域建模分为三个过程：

+  领域分析建模：只做业务分析 
+  领域设计建模：引入DDD的设计元素 
+  领域实现建模：通过TDD驱动实现 



我用一个形象的比喻来形容这三个过程：

+  第一个过程，你还是单身狗，目的就是找对象，也就是找出业务中的领域概念 
+  第二个过程，你谈恋爱了，需要你有理智地搞对象，弄清楚对象之间的关系 
+  第三个过程，你成家了，须得考虑油盐酱醋茶，也就是考虑基础设施的实现 



嗯嗯~~谈过恋爱成了家的人，或许都能体会到这一点！



2021年10月24日

# <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计对软件复杂度的应对</font>
<font style="color:rgba(0, 0, 0, 0.9);">不管是因为规模与结构制造的理解力障碍，还是因为变化带来的预测能力问题，最终的决定因素还是因为需求。Eric Evans认为“很多应用程序最主要的复杂性并不在技术上，而是来自领域本身、用户的活动或业务”。因而，领域驱动设计关注的焦点在于领域和领域逻辑，因为软件系统的本质其实是给客户（用户）提供具有业务价值的领域功能。  
</font>

## <font style="color:rgba(0, 0, 0, 0.9);">需求引起的软件复杂度</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">需求分为业务需求与质量属性需求，因而需求引起的复杂度可以分为两个方面：技术复杂度与业务复杂度。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">技术复杂度来自需求的质量属性，诸如安全、高性能、高并发、高可用性等需求，为软件设计带来了极大的挑战。让人难受的是这些因素彼此之间又可能互相矛盾互相影响。例如，系统安全性要求对访问进行控制，无论是增加防火墙，还是对传递的消息进行加密，又或者对访问请求进行认证和授权，都需要为整个系统架构添加额外的间接层。这不可避免会对访问的低延迟产生影响，拖慢了系统的整体性能。又例如为了满足系统的高并发访问，我们需要对应用服务进行物理分解，通过横向增加更多的机器来分散访问负载；同时，我们还可以将一个同步的访问请求拆分为多级步骤的异步请求，再通过引入消息中间件对这些请求进行整合和分散处理。这种分离一方面增加了系统架构的复杂性，另一方面也因为引入了更多的资源，使得系统的高可用面临挑战，并增加了维护数据一致性的难度。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">业务复杂度对应了客户的业务需求，因而这种复杂度往往会随着需求规模的增大而增加。由于需求不可能做到完全独立，一旦规模扩大到一定程度，不仅产生了功能数量的增加，还会因为功能互相之间的依赖与影响使得这种复杂度产生叠加，进而影响到整个系统的质量属性，例如系统的可维护性与可扩展性。在考虑系统的业务需求时，还会因为沟通不畅、客户需求不清晰等多种局外因素带来需求的变更和修改。如果不能很好地控制这种变更，就可能因为多次修改导致业务逻辑纠缠不清，系统可能开始慢慢腐烂，变得不可维护，最终形成一种如Brian Foote和Joseph Yoder所说的“大泥球”系统。</font>

<font style="color:rgba(0, 0, 0, 0.9);">  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">以电商系统的促销规则为例。针对不同类型的顾客与产品，商家会提供不同的促销力度；促销的形式多种多样，包括赠送积分、红包、优惠券、礼品；促销的周期需要支持定制，既可以是特定的日期，例如双十一促销，也可以是节假日的固定促销模式。如果我们在设计时没有充分考虑促销规则的复杂度，并处理好促销规则与商品、顾客、卖家与支付乃至于物流、仓储之间的关系，开发过程就会变得踉踉跄跄，举步维艰。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">技术复杂度与业务复杂度并非完全独立，二者混合在一起产生的化合作用更让系统的复杂度变得不可预期，难以掌控。同时，技术的变化维度与业务的变化维度并不相同，产生变化的原因也不一致，倘若未能很好地界定二者之间的关系，系统架构缺乏清晰边界，会变得难以梳理。复杂度一旦增加，团队规模也将随之扩大，再揉以严峻的交付周期、人员流动等诸多因素，就好似将各种不稳定的易燃易爆气体混合在一个不可逃逸的密闭容器中一般，随时都可能爆炸：</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852699086-56ee4ae6-9691-4ec3-8546-00233358b983.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);">随着业务需求的增加与变化，以及对质量属性的高标准要求，自然也引起了软件系统规模的增大与结构的繁杂，至于变化，则是软件开发绕不开的话题。因此，当我们面对一个相对复杂的软件系统时，通常面临的问题在于：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">问题域过于庞大而复杂，使得从问题域中寻求解决方案的挑战增加。该问题与软件系统的规模有关。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">开发人员将业务逻辑的复杂度与技术实现的复杂度混淆在一起。该问题与软件系统的结构有关。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">随着需求的增长和变化，无法控制业务复杂度和技术复杂度。该问题与软件系统的变化有关。</font>

<font style="color:rgba(0, 0, 0, 0.9);">针对这三个问题，领域驱动设计都给出了自己的应对措施。  
</font>

## <font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计的应对措施</font>
### <font style="color:rgba(0, 0, 0, 0.9);">隔离业务复杂度与技术复杂度  
</font>
<font style="color:rgba(0, 0, 0, 0.9);">要避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，首要任务就是确定业务逻辑与技术实现的边界，从而隔离各自的复杂度。这种隔离也是题中应有之义，毕竟技术与业务的关注点完全不同。例如在电商的领域逻辑中，订单业务关注的业务规则包括验证订单有效性，计算订单总额，提交和审核订单的流程等；技术关注点则从实现层面保障这些业务能够正确地完成，包括确保分布式系统之间的数据一致性，确保服务之间通信的正确性等。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">业务逻辑并不关心技术是如何实现的。无论采用何种技术，只要业务需求不变，业务规则就不会变化。换言之，理想状态下，我们应该保证业务规则与技术实现是正交的。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计通过分层架构与六边形架构确保业务逻辑与技术实现的隔离。</font>

#### <font style="color:rgba(0, 0, 0, 0.9);">分层架构的关注点分离  
</font>
<font style="color:rgba(0, 0, 0, 0.9);">分层架构遵循了“关注点分离”原则，将属于业务逻辑的关注点放到领域层（Domain Layer）中，而将支撑业务逻辑的技术实现放到基础设施层（Infrastructure Layer）中。同时，领域驱动设计又颇具创见的引入了应用层（Application Layer）。应用层扮演了双重角色。一方面它作为业务逻辑的外观（Facade），暴露了能够体现业务用例的应用服务接口；另一方面它又是业务逻辑与技术实现的粘合剂，实现二者之间的协作。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">下图展现的就是一个典型的领域驱动设计分层架构。蓝色区域的内容与业务逻辑有关，灰色区域的内容与技术实现有关，二者泾渭分明，然后汇合在应用层。应用层确定了业务逻辑与技术实现的边界，通过直接依赖或者依赖注入（DI，Dependency Injection）的方式将二者结合起来：</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852699058-8103e36e-acc9-421b-bcd2-70ac4ef388e2.jpeg)

#### <font style="color:rgba(0, 0, 0, 0.9);">六边形架构的内外分离  
</font>
<font style="color:rgba(0, 0, 0, 0.9);">由Cockburn提出的六边形架构则以“内外分离”的方式，更加清晰地勾勒出业务逻辑与技术实现的边界，且将业务逻辑放在了架构的核心位置。这种架构模式改变了我们观察系统架构的视角：</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852699080-f2dcc661-1b26-403d-b3f6-d45096ec254c.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);">体现业务逻辑的应用层与领域层处于六边形架构的内核，并通过内部的六边形边界与基础设施的模块隔离开。当我们在进行软件开发时，只要恪守架构上的六边形边界，就不会让技术实现的复杂度污染到业务逻辑，保证了领域的整洁。边界还隔离了变化产生的影响。如果我们在领域层或应用层抽象了技术实现的接口，再通过依赖注入将控制的方向倒转，业务内核就会变得更加的稳定，不会因为技术选型或其他决策的变化而导致领域代码的修改。</font>

#### <font style="color:rgba(0, 0, 0, 0.9);">案例：隔离数据库与缓存的访问  
</font>
<font style="color:rgba(0, 0, 0, 0.9);">领域驱动设计建议我们在领域层建立资源库（Repository）的抽象，它的实现则被放在基础设施层，然后采用依赖注入在运行时为业务逻辑注入具体的资源库实现。那么，对于处于内核之外的Repositories模块而言，即使选择从MyBatis迁移到Sprint Data，领域代码都不会受到牵连：</font>

```java
package practiceddd.ecommerce.ordercontext.application;

@Transaction
public class OrderAppService {
    @Service
    private PlaceOrderService placeOrder;

    public void placeOrder(Identity buyerId, List<OrderItem> items, ShippingAddress shipping, BillingAddress billing) {
        try {
            palceOrder.execute(buyerId, items, shipping, billing);
        } catch (OrderRepositoryException | InvalidOrderException | Exception ex) {
            ex.printStackTrace();
            logger.error(ex.getMessage());
        }
    }
}

package practiceddd.ecommerce.ordercontext.domain;

public interface OrderRepository {
    List<Order> forBuyerId(Identity buyerId);
    void add(Order order);
}

public class PlaceOrderService {
    @Repository
    private OrderRepository orderRepository;

    @Service
    private OrderValidator orderValidator;    

    public void execute(Identity buyerId, List<OrderItem> items, ShippingAddress shipping, BillingAddress billing) {
        Order order = Order.create(buyerId, items, shipping, billing);
        if (orderValidator.isValid(order)) {
            orderRepository.add(order);
        } else {
            throw new InvalidOrderException(String.format("the order which placed by buyer with %s is invalid.", buyerId));
        }
    }
}

package practiceddd.ecommerce.ordercontext.infrastructure.db;

public class OrderMybatisRepository implements OrderRepository {}
public class OrderSprintDataRepository implements OrderRepository {}
```

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">对缓存的处理可以如法炮制，但它与资源库稍有不同之处。资源库作为访问领域模型对象的入口，其本身提供的增删改查功能，在抽象层面上是对领域资源的访问。因此在领域驱动设计中，我们通常将资源库的抽象归属到领域层。对缓存的访问则不相同，它的逻辑就是对key和value的操作，与具体的领域无关。倘若要为缓存的访问方法定义抽象接口，在分层的归属上应该属于应用层，至于实现则属于技术范畴，应该放在基础设施层：</font>

```java
package practiceddd.ecommerce.ordercontext.application;

@Transaction
public class OrderAppService {
    @Repository
    private OrderRepository orderRepository;

    @Service
    private CacheClient<List<Order>> cacheClient;

    public List<Order> findBy(Identity buyerId) {
        Optional<List<Order>> cachedOrders = cacheClient.get(buyerId.value());
        if (cachedOrders.isPresent()) {
            return orders.get();
        }
        List<Order> orders = orderRepository.forBuyerId(buyerId);
        if (!orders.isEmpty()) {
            cacheClient.put(buyerId.value(), orders);
        }
        return orders;
    }
}

package practiceddd.ecommerce.ordercontext.application.cache;

public interface CacheClient<T> {
    Optional<T> get(String key);
    void put(String key, T value);
}

package practiceddd.ecommerce.ordercontext.infrastructure.cache;

public class RedisCacheClient<T> implements CacheClient<T> {}
```

#### <font style="color:rgba(0, 0, 0, 0.9);">限界上下文的分而治之  
</font>
<font style="color:rgba(0, 0, 0, 0.9);">在前面分析缓存访问接口的归属时，我们将接口放在了系统的应用层。从层次的职责来看，这样的设计是合理的，但它却使得系统的应用层变得更加臃肿，职责也变得不够单一了。这是分层架构与六边形架构的局限所在，因为这两种架构模式仅仅体现了一个软件系统的逻辑划分。倘若我们将一个软件系统视为一个纵横交错的魔方，前述的逻辑划分仅仅是一种水平方向的划分。至于垂直方向的划分，则是面向垂直业务的切割。这种方式更利于控制软件系统的规模，将一个庞大的软件系统划分为松散耦合的多个小系统的组合。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">针对前述案例，我们可以将缓存视为一个独立的子系统。它同样拥有自己的业务逻辑和技术实现，因而也可以为其建立属于缓存领域的分层架构。在架构的宏观视角，这个缓存子系统与订单子系统处于同一个抽象层次，这一概念在领域驱动设计中，被称之为限界上下文（Bounded Context）。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">针对庞大而复杂的问题域，限界上下文采用了“分而治之”的思想对问题域进行了分解，有效地控制了问题域的规模，进而控制了整个系统的规模。一旦规模减小，无论业务复杂度还是技术复杂度，都会得到显著的降低，在对领域进行分析以及建模时，也能变得更容易。如果说分层架构与六边形架构确保了业务逻辑与技术实现的隔离，则限界上下文对整个系统进行了划分，将一个大系统拆分为一个个小系统后，我们再利用分层架构与六边形架构思想对其进行逻辑分层，设计会变得更易于把控，系统的架构也会变得更加的清晰。  
</font>

#### <font style="color:rgba(0, 0, 0, 0.9);">案例：限界上下文帮助架构的演进</font>
<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">国际报税系统是为跨国公司的驻外出差雇员（系统中被称之为Assignee）提供方便一体化的税收信息填报平台。客户是一家会计师事务所，该事务所的专员（Admin）通过该平台可以收集雇员提交的报税信息，然后对这些信息进行税务评审。如果Admin评审出信息有问题，则返回给Assignee重新修改和填报。一旦信息确认无误，则进行税收分析和计算，并获得最终的税务报告提交给当地政府以及雇员本人。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">系统主要涉及的功能包括：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">驻外出差雇员的薪酬与福利</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">税收计划与合规评审</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">对税收评审的分配管理</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">税收策略设计与评审</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">对驻外出差雇员的税收合规评审</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">全球的Visa服务  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">主要涉及的用户角色包括：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">Assignee：驻外出差雇员</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">Admin：税务专员</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">Client：出差雇员的雇主</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">在早期的架构设计时，架构师并没有对整个系统的问题域进行拆分，而是基于用户角色对系统进行了简单粗暴的划分，分为两个相对独立的子系统：Frond End与Office End。这两个子系统单独部署，分别面向Assignee与Admin。系统之间的集成则通过消息和Web Service进行通信。两个子系统的开发分属不同的团队，Frond End由美国的团队负责开发与维护，而Office End则由印度的团队负责。整个架构如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704362059347-dcc0d744-6ad5-4ed4-bb99-3d355fa339c8.png)

<font style="color:rgba(0, 0, 0, 0.9);">采用这种架构面临如下问题：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">庞大的代码库：整个Front End和Office End都没有做物理分解，随着需求的增多，代码库变得格外庞大</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">分散的逻辑：系统分解的边界是不合理的，没有按照业务分解，而是按照用户的角色进行分解，导致大量相似的逻辑分散在两个不同的子系统中</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">重复的数据：两个子系统中存在业务重叠，因而也导致了部分数据的重复</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">复杂的集成：Front End与Office End因为某些相关的业务需要彼此通信，这种集成关系是双向的，且由两个不同的团队开发，导致集成的接口混乱，消息协议多样化</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">知识未形成共享：两个团队完全独立开发，没有掌握端对端的整体流程，团队之间没有形成知识的共享</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">无法应对需求变化： 新增需求包括对国际旅游、Visa的支持，现有系统的架构无法很好地支持这些变化  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">采用领域驱动设计，我们将架构的主要关注点放在了“领域”，与客户进行了充分的需求沟通和交流。通过分析已有系统的问题域，结合客户提出的新需求，对整个问题域进行了梳理，并利用限界上下文对问题域进行了分解，获得了如下限界上下文：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">Account Management：管理用户的身份与配置信息</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">Calendar Management：管理用户的日程与旅行足迹  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">之后，客户希望能改进需求，做到全球范围内的工作指派与管理，目的在于提高公司的运营效率。通过对领域的分析，我们又识别出两个限界上下文。在原有的系统架构中，这两个限界上下文同时处于Front End与Office End之中，属于重复开发的业务逻辑：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">Work Record Management：实现工作的分配与任务的跟踪</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">File Sharing：目的是实现客户与会计师事务所之间的文件交换</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">随着我们对领域知识的逐渐深入理解与分析，又随之识别出如下限界上下文：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">Consent：管理合法的遵守法规的状态</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">Notification：管理系统与客户之间的交流</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">Questionnaire：对问卷调查的数据收集  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">这个领域分析的过程实际上就是通过对领域的分析，引入限界上下文对问题域进行分解，通过降低规模的方式降低问题域的复杂度；同时，通过为模型确定清晰的边界，使得系统的结构变得更加的清晰，保证了领域逻辑的一致性。一旦确定了清晰的领域模型，就能够帮助我们更加容易地发现系统的可重用点与可扩展点，并遵循“高内聚松耦合”原则对系统职责进行合理分配，再辅以分层架构划分逻辑边界，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704362082627-f3afd3bd-63f7-4b66-b3d9-4f4e6a073ccf.png)

<font style="color:rgba(0, 0, 0, 0.9);">我们将识别出来的限界上下文定义为微服务，并对外公开REST服务接口。UI Applications是一个薄薄的展现层，它会调用后端的RESTful服务，也使得服务在保证接口不变的前提下能够单独演化。每个服务都是独立的，可以单独部署，因而可以针对服务建立单独的代码库和对应的特性团队（Feature Team）。服务的重用性和可扩展性也有了更好的保障，服务与UI之间的集成变得更简单，整个架构更加清晰了。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">领域模型对领域知识的抽象  
</font>
<font style="color:rgba(0, 0, 0, 0.9);">领域模型是对业务需求的一种抽象，表达了领域概念、领域规则以及领域概念之间的关系。一个好的领域模型是对统一语言的可视化表示，通过它可以减少需求沟通可能出现的歧义；通过提炼领域知识，并运用抽象的领域模型去表达，就可以达到对领域逻辑的化繁为简。模型是封装，实现了对业务细节的隐藏；模型是抽象，提取了领域知识的共同特征，保留了面对变化时能够良好扩展的可能性。</font>

#### <font style="color:rgba(0, 0, 0, 0.9);">案例：项目管理系统的领域模型  
</font>
<font style="color:rgba(0, 0, 0, 0.9);">我们开发的项目管理系统需要支持多种软件项目管理流程，例如瀑布、RUP、XP或者Scrum。这些项目管理流程是迥然不同的，如果需要各自提供不同的解决方案，就会使得系统的模型变得非常复杂，也可能引入许多不必要的重复。通过领域建模，我们可以对项目管理领域的知识进行抽象，寻找具有共同特征的领域概念。这就需要分析各种项目管理流程的主要特征与表现，才能从中提炼出领域模型。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">瀑布式软件开发由需求、分析、设计、编码、测试、验收六个阶段构成，每个阶段都由不同的活动构成，这些活动可能是设计或开发任务，也可能是召开评审会。流程如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852699825-bbfe0432-de84-4969-b196-43d74487276d.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);">RUP清晰地划分了四个阶段：先启阶段、细化阶段、构造阶段与交付阶段。每个阶段可以包含一到多个迭代，每个迭代有不同的工作，例如业务建模、分析设计、配置与变更管理等。RUP的流程如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852699833-473015ce-9810-42f8-b83a-fa8d77e390dc.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);">XP作为一种敏捷方法，采用了迭代的增量式开发，提倡为客户交付具有业务价值的可运行软件。在执行交付计划之前，XP要求团队对系统的架构做一次预研（Architectual Spike，又被译为架构穿刺）。当架构的初始方案确定后，就可以进入每次小版本的交付。每个小版本交付又被划分为多个周期相同的迭代。在迭代过程中，要求执行一些必须的活动，如编写用户故事、故事点估算、验收测试等。XP的流程如下图所示：</font><font style="color:rgba(0, 0, 0, 0.9);">  
</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852699868-8570143c-f341-471d-8f3c-75fc773f63b5.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);">Scrum同样是迭代的增量开发过程。项目在开始之初，需要在准备阶段确定系统愿景、梳理业务用例、确定产品待办项（product backlog）、制定发布计划以及组建团队。一旦在确定了产品待办项以及发布计划之后，就进入sprint迭代阶段。sprint迭代过程是一个固定时长的项目过程，在这个过程中，整个团队需要召开计划会议、每日站会、评审会议和回顾会议。Scrum的流程如下图所示：</font><font style="color:rgba(0, 0, 0, 0.9);">  
</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852700030-565ad05a-e623-4130-b227-c69f4f597aa2.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);">不同的项目管理流程具有不同的业务概念。例如瀑布式开发分为了六个阶段，但却没有发布和迭代的概念。RUP没有发布的概念，而Scrum又为迭代引入了sprint的概念。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">不同的项目管理流程具有不同的业务规则。例如RUP的四个阶段会包含多个迭代周期，每个迭代周期都需要完成对应的工作，只是不同的工作在不同阶段所占的比重不同。XP需要在进入发布阶段之前，进行架构预研，而在每次小版本发布之前，都需要进行验收测试和客户验收。Scrum的sprint是一个基本固定的流程，每个迭代召开的四会（计划会议、评审会议、回顾会议与每日站会）都有明确的目标。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">领域建模就是要从这些纷繁复杂的领域逻辑中寻找到能够表示项目管理领域的概念，并利用面向对象建模范式或其他范式对概念进行抽象，并确定它们之间的关系。经过对这些项目管理流程的分析，我们虽然发现在业务概念和规则上确有不同之处，但由于它们都归属于软件开发领域，我们自然也能寻找到某些共同特征的蛛丝马迹。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">首先，从项目管理系统的角度看，无论针对何种项目管理流程，我们的主题需求是不变的，就是要为这些管理流程制定软件开发计划（Plan）。不同之处在于，计划可以由多个阶段（Phase）组成，也可以由多个发布（Release）组成。一些项目管理流程没有发布的概念，我们可以认为是一个发布。那么，到底是发布包含了多个阶段，还是阶段包含了多个发布呢？我们发现在XP中，明显地划分了两个阶段：Architecture Spike与Release Planning，而发布只属于Release Planning阶段。因而从概念内涵上，我们可以认为是阶段（Phase）包含了发布（Release）。每个发布又包含了一到多个迭代（Iteration），至于Scrum的sprint概念其实可以看做是迭代的一种特例。每个迭代可以开展多种不同的活动（Activity），这些活动可以是整个团队参与的会议，也可以是部分成员或特定角色执行的实践。对于计划而言，我们还需要跟踪任务（Task）。与活动不同，任务具有明确的计划起止时间、实际起止时间、工作量、优先级与承担人。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">于是，我们提炼出如下的统一领域模型：</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852699952-c1063ee0-ebb2-476b-8423-d2ff3ed2dc86.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);">为了项目管理者更加方便地制定项目计划，产品经理提出了计划模板功能。当管理者选择对应的项目管理生命周期类型后，系统会自动创建满足其规则的初始计划。基于该需求，我们更新了之前的领域模型：</font><font style="color:rgba(0, 0, 0, 0.9);">  
</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703852700525-d8008211-c5c1-4f1d-981b-8bb11f7dbd43.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);">在增加的领域模型中，LifeCycleSpecification是一个隐含的概念，遵循领域驱动设计提出的规格（Specification）模式，封装了项目开发生命周期的约束规则。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">领域模型以可视化的方式清晰地表达了业务含义，我们可以根据这个模型来指导后面的程序设计与编码实现。当增加新的需求或者需求发生变化时，我们能够敏锐地捕捉到现有模型的不匹配之处，并对其进行更新。领域模型传递了知识，可以作为交流的载体，符合人们的心智模型，有利于让开发人员从纷繁复杂的业务中解脱出来。这是领域驱动设计对于前述第三个问题——控制业务复杂度的解答。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">2018年12月29日</font>

# <font style="color:rgb(85, 85, 85);">领域驱动设计对依赖的控制</font>
<font style="color:rgb(85, 85, 85);">我在《解构领域驱动设计》一书中分析了软件复杂度的成因，一曰规模，一曰结构，还有一个则是变化的影响。规模与结构存在一定的矛盾关系：解决规模复杂度的有效方法为“分而治之”，一旦系统被分解为多个更为细小的软件元素，结构复杂度就会增加。结构与变化之间存在互相影响的关系：如果结构控制不合理，变化带来的影响就会更强，使得系统更加复杂。</font>

<font style="color:rgb(85, 85, 85);">认真分析结构和变化对系统复杂度的影响，一个关键是</font>**<font style="color:rgb(85, 85, 85);">对依赖的控制</font>**<font style="color:rgb(85, 85, 85);">。当我们对系统进行分解时，</font>**<font style="color:rgb(85, 85, 85);">依赖</font>**<font style="color:rgb(85, 85, 85);">会成为我们无法绕开的问题，它是技术债的重要组成部分，是不可避免的。如果没有控制好依赖，系统的架构就会随着时间的推移不可避免地腐化下去，如人不可避免的老去。</font>

<font style="color:rgb(85, 85, 85);">要合理控制依赖，只有两个可行的思路：</font>

+ <font style="color:rgb(85, 85, 85);">从多到少：减少依赖而非彻底消除依赖，其核心原理是做好职责的合理分配</font>
+ <font style="color:rgb(85, 85, 85);">从强到弱：如果依赖不可避免，则要想办法降低依赖，其核心原理是封装与抽象</font>

## <font style="color:rgb(85, 85, 85);">减少依赖数量</font>
<font style="color:rgb(85, 85, 85);">领域驱动设计通过引入限界上下文和聚合，在战略层次和战术层次分别提供了减少依赖的控制手法。</font>

### <font style="color:rgb(85, 85, 85);">限界上下文</font>
<font style="color:rgb(85, 85, 85);">我在《解构领域驱动设计》书中总结了限界上下文的两个特征：</font>

+ <font style="color:rgb(85, 85, 85);">限界上下文是领域模型的知识语境</font>
+ <font style="color:rgb(85, 85, 85);">限界上下文是业务能力的纵向切分  
</font>

<font style="color:rgb(85, 85, 85);">此两大特征既充分阐释了限界上下文的本质，又提供了减少依赖的思路。</font>

#### <font style="color:rgb(85, 85, 85);">领域模型的知识语境</font>
<font style="color:rgb(85, 85, 85);">限界上下文提供了领域概念的知识边界，在特定的</font>**<font style="color:rgb(85, 85, 85);">上下文</font>**<font style="color:rgb(85, 85, 85);">之下，领域概念体现的是一种局部的全貌。所谓“局部的全貌”听起来颇为矛盾，然而就观察者而言，在你所处的“上下文”边界内，由于你并不关心其他上下文的知识，因而你看到的虽然只是“局部”，却可以理解为这是你需要的“全貌”。</font>

<font style="color:rgb(85, 85, 85);">譬如在一家软件企业，假设一个员工作为我们要了解的全貌，在不同部门看到的却只是各自的局部：</font>

+ <font style="color:rgb(85, 85, 85);">人力资源部门：教育背景、现有角色、岗位、职务、考勤</font>
+ <font style="color:rgb(85, 85, 85);">财务部门：薪资、社保</font>
+ <font style="color:rgb(85, 85, 85);">项目管理部门：技能水平、所属团队、团队角色</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">以财务部门为例，我并不需要知道该员工技能水平如何，也不需要知道他在哪一个团队，只需要知道该员工的薪资构成，然后按照企业规章核算工资并按时发放即可。员工薪资与社保等信息就在此时构成了在财务上下文下财务人员关心的全貌。</font>

<font style="color:rgb(85, 85, 85);">这一设计的好处在于引入了领域知识的控制边界，倘若分配合理，就能减少软件元素之间不必要的依赖关系。这也是限界上下文与模块之间的不同之处。</font>

<font style="color:rgb(85, 85, 85);">如果以业务模块对系统进行分解，一种直观的设计方案是单独分解出一个员工模块，然后将该员工的所有属性与行为（构成了领域知识）都分配给员工模块。当财务部门进行工资核算与支付时，需要从员工模块中获取它与薪资、社保相关的领域知识，带来了财务模块与员工模块之间的依赖关系。</font>

<font style="color:rgb(85, 85, 85);">限界上下文则不同，由于员工与财务相关的领域知识都根据</font>**<font style="color:rgb(85, 85, 85);">上下文</font>**<font style="color:rgb(85, 85, 85);">分配给了需要关注这些领域知识的财务上下文，在核算工资与支付工资时，财务上下文就无需求助于员工上下文了。</font>**<font style="color:rgb(85, 85, 85);">这是让依赖减少的最佳模式。</font>**

#### <font style="color:rgb(85, 85, 85);">业务能力的纵向切分</font>
<font style="color:rgb(85, 85, 85);">限界上下文与模块之间的不同之处，还在于限界上下文不止限于封装了领域知识。它是对业务能力的纵向切分，如此切分出来的每一块，都是相对独立而完整的。准确的说法，就是先根据领域维度对整个系统进行纵向切分，然后再到限界上下文内部，根据技术维度对其进行横向切分，将限界上下文的领域层独立出来。</font>

<font style="color:rgb(85, 85, 85);">模块的划分不是这样，业务模块和基础功能模块泾渭分明。业务模块自身不具备支持业务能力的功能，如访问数据库、网络通信或消息队列，于是引入了业务模块与其他基础功能模块之间的依赖。在限界上下文中，这样的依赖（领域与基础设施之间的依赖）虽然依旧存在，但由于系统的划分边界是整个限界上下文，依赖发生在限界上下文内部，从架构层次看，相当于消除了依赖，变相地减少了依赖。</font>

### <font style="color:rgb(85, 85, 85);">聚合</font>
<font style="color:rgb(85, 85, 85);">聚合在模型粒度与依赖之间引入了平衡。遵循对象建模的思维，建议为每一个领域概念都定义一个领域模型类，哪怕是email、quantity、address这样细小的基础概念，也当如此。Martin Fowler在重构中也提到，编码时要注意规避“基本类型偏执”坏味道。不用基本类型说明这些细小的领域概念，自然就需要定义对应的模型类了。</font>

<font style="color:rgb(85, 85, 85);">一旦为非常细小的领域概念定义了领域模型类，粒度就变得非常小，整个领域模型的类数量就会增加。增加了类的数量，必然也就会增加依赖。这时，聚合引入的边界就起到了很好的控制作用，它要求：</font>

+ <font style="color:rgb(85, 85, 85);">聚合内的领域模型由实体和值对象组成，形成一棵树</font>
+ <font style="color:rgb(85, 85, 85);">一棵树只有一个根，只有实体才能作为根</font>
+ <font style="color:rgb(85, 85, 85);">根实体作为聚合的唯一出口和唯一入口</font>
+ <font style="color:rgb(85, 85, 85);">跨聚合之间只能通过根实体建立关系  
</font>

<font style="color:rgb(85, 85, 85);">通过边界的控制，保障根实体之间才能建立关联关系，就去掉了许多非根元素跨聚合之间的关系，减少了领域模型类之间的依赖。根实体体现了对内部领域模型的封装，由它代表整个聚合内的所有领域模型，站在聚合边界之外，就可以认为领域模型类的数量减少了，调用者也无需关心聚合内部的其他实体和值对象。</font>

<font style="color:rgb(85, 85, 85);">限界上下文通过知识语境和业务能力形成的边界控制，减少了战略层面（也就是架构层面）软件元素之间的依赖关系；聚合则通过规定的设计原则与设计约束形成的边界控制，减少了战术层面领域模型类之间的依赖关系。</font>

<font style="color:rgb(85, 85, 85);">正因为如此，我才在《解构领域驱动设计》书中指出：</font>

+ <font style="color:rgb(85, 85, 85);">限界上下文是架构映射阶段基本的架构单元</font>
+ <font style="color:rgb(85, 85, 85);">聚合是领域建模阶段基本的设计单元  
</font>

<font style="color:rgb(85, 85, 85);">要做好领域驱动设计，在架构层面，限界上下文是不可或缺的，在设计层面，聚合才是不可或缺的。</font>

## <font style="color:rgb(85, 85, 85);">降低依赖强度</font>
<font style="color:rgb(85, 85, 85);">当依赖不可避免时，需要将强依赖降低为弱依赖，也即所谓的“降低耦合度”。限界上下文作为基本的架构单元，要降低依赖强度，实则就是合理地管理限界上下文之间的协作关系，这是领域驱动设计的</font>**<font style="color:rgb(85, 85, 85);">上下文映射</font>**<font style="color:rgb(85, 85, 85);">模式所要处理的。防腐层（ACL）与开放主机服务（OHS）都降低了下游对上游的依赖，而发布语言（PL）则作为开放主机模式的补充，引入了对领域模型的封装。</font>

<font style="color:rgb(85, 85, 85);">上下文映射模式降低了限界上下文之间的耦合，强调了对内部领域模型的封装；对于限界上下文内部，则通过分层架构，凸显了领域模型的核心地位，利用层次（Layer）来分离关注点，并适当引入封装和抽象，解除了外部资源对领域模型，以及领域模型对外部资源的依赖。可概括为：</font>

+ <font style="color:rgb(85, 85, 85);">封装：引入应用服务，隐藏领域模型，包括领域模型中的聚合与领域服务，并保障应用层的轻和薄，严防死守，避免将领域知识泄露出去</font>
+ <font style="color:rgb(85, 85, 85);">抽象：引入资源库的接口，隔离对数据库的访问，且将资源库接口放到领域层，然后通过依赖注入实现依赖关系的反转</font>

<font style="color:rgb(85, 85, 85);">  
</font><font style="color:rgb(85, 85, 85);">在《解构领域驱动设计》书中，我通过引入</font>**<font style="color:rgb(85, 85, 85);">菱形对称架构</font>**<font style="color:rgb(85, 85, 85);">将上述上下文映射模式、分层架构模式，以及应用服务与抽象资源库等内容全部囊括其中。开放主机服务属于北向网关，其中也涵盖了应用服务；防腐层属于南向网关，其中也涵盖了资源库，同时扩大了防腐层的外延，将所有对外部资源的访问都视为南向网关。至于发布语言，则介于外部网关层与内部领域层之间，就其本质而言，仍然属于外部网关层的一部分。</font>

## <font style="color:rgb(85, 85, 85);">自治性</font>
<font style="color:rgb(85, 85, 85);">减少依赖数量，降低依赖强度，一言以蔽之，其实就是我们耳熟能详的六字法则“高内聚低耦合”。不管是架构原则还是设计原则，都是知易行难，知道“高内聚低耦合”的原则，并不能确保你做出符合该原则的设计。领域驱动设计通过限界上下文与聚合的核心模式，提供了相对可行的方法。若要解密领域驱动设计，此二者应为解密的钥匙。</font>

<font style="color:rgb(85, 85, 85);">为了更好地解密二者，我总结了它们共同的特性，将其名为“自治性”。要设计好限界上下文与聚合，就需要确保它们的自治性。</font>

### <font style="color:rgb(85, 85, 85);">自治的限界上下文</font>
<font style="color:rgb(85, 85, 85);">自治的限界上下文需要具备如下四个特征：</font>

+ <font style="color:rgb(85, 85, 85);">最小完备：强调了每个限界上下文拥有的领域知识是最小完备的，它体现了限界上下文是领域模型的知识语境这一特征。</font>
+ <font style="color:rgb(85, 85, 85);">自我履行：强调了限界上下文在拥有了合理领域知识后，能够拥有一定智能，聪明地应对外界的请求，判断哪些该自己做，哪些该求助于别的限界上下文；自我履行的范围不仅限于领域知识，故而它体现了限界上下文是业务能力的纵向切分这一特征。</font>
+ <font style="color:rgb(85, 85, 85);">稳定空间：就限界上下文内部的领域模型而言，我们希望它是稳定的；在不考虑业务需求自身变化的情况下，要确保它的稳定性，就是要尽可能隔离它对外界的引用，将外界变化产生的影响降到最低；这就需要引入“抽象”，隔离外界，也就是菱形对称架构南向网关要做的事情。</font>
+ <font style="color:rgb(85, 85, 85);">独立进化：只要业务需求发生了变化，限界上下文内部的领域模型必然发生调整，但我们希望这种调整对于外界而言，可以变得静悄悄，虽然版本发生了进化，外界却可以无感知；其关键在于引入“封装”，不要将领域模型随便暴露在外，这实际上就是菱形对称架构北向网关要做的事情。  
</font>

<font style="color:rgb(85, 85, 85);">最小完备和自我履行结合起来，可以合理地减少依赖数量；稳定空间与独立进化配合起来，可以有效地降低依赖强度。显然，限界上下文的自治性满足了“高内聚低耦合”的架构原则。</font>

### <font style="color:rgb(85, 85, 85);">自治的聚合</font>
<font style="color:rgb(85, 85, 85);">自治的聚合需要具备如下特征：</font>

+ <font style="color:rgb(85, 85, 85);">完整性：一个设计合理的聚合应该体现为最小单元的完整领域概念</font>
+ <font style="color:rgb(85, 85, 85);">独立性：每个自治的聚合都是相对独立的，它的生命周期也是独立的</font>
+ <font style="color:rgb(85, 85, 85);">不变量：聚合内部要维持各个对象之间关系的不变量，从而满足业务规则的约束</font>
+ <font style="color:rgb(85, 85, 85);">一致性：保持聚合内部各个对象的数据一致性，以及生命周期的一致性</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">完整性、不变量与一致性体现了聚合之“合”的一面，它意味着合入到聚合边界的模型对象是“高内聚”的；独立性体现了聚合之“分”的一面，意味着不要将生命周期不一致、数据不一致的模型对象放在同一个聚合里，聚合边界具有一种排斥能力，要将“异质体”推出去，通过聚合根实体来维持彼此之间的关系，保证聚合之间是“低耦合”的。  
</font>

**<font style="color:rgb(85, 85, 85);">说明：</font>**<font style="color:rgb(85, 85, 85);">限界上下文与聚合的自治性原则继承和延续了诸多促进优良设计的软件原则，是我个人对这些设计原则的总结和提炼，虽不能说是我的全新创造，但就其表现形式与内容而言，确实由我最早提出，特此声明。</font>

# <font style="color:rgb(85, 85, 85);">领域驱动设计基本概念答疑</font>
## <font style="color:rgb(85, 85, 85);">实体与值对象  </font>
<font style="color:rgb(85, 85, 85);">问题：DDD实现中领域对象区分实体(Entity)和值对象(Value Object)的目的(Why)是什么?或者换一种问法：领域对象区分实体(Entity)和值对象(Value Object)之后，带来的好处和收益是什么?</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">回答：从DDD的概念上讲，实体（Entity）与值对象（Value Object）的本质区别仅在于后者无需identity（唯一标识）。这其实就是带来的价值——就是你设计的对象不需要去跟踪和管理这个唯一标识。</font>

<font style="color:rgb(85, 85, 85);">这是概念划分上，值对象带来的价值。</font>

<font style="color:rgb(85, 85, 85);">再来说设计层面。通常情况下，我们建议将值对象设计成一个不变（Immutable）对象。当一个对象是不变的时，你就基本不需要担心并发带来的诸如同步、冲突等问题了，这既降低了编程的难度，又可以无需引入额外的同步锁影响程序的性能。</font>

<font style="color:rgb(85, 85, 85);">反而过来说，之所以可以将值对象设计成不变的，其根本原因还是在于我们无需跟踪和管理唯一标识。</font>

<font style="color:rgb(85, 85, 85);">在领域驱动设计中，我们提倡的实践是尽量定义值对象来替代基本类型，原因在于基本类型无法体现统一语言中的领域概念。此外，在多数语言中，我们无法对基本类型做封装，就意味着一个领域概念缺乏领域行为来支持。假设一个实体定义了许多属性，如果这些属性都是基本类型，就会导致与这些属性相关的领域行为都要放到实体中，导致实体的职责变得不够单一。</font>

<font style="color:rgb(85, 85, 85);">引入值对象后，情况就不同了，因为我们可以利用合理的职责分配，将这些职责（领域行为）按照内聚性分配到各个值对象中，这个领域模型就能变得协作良好。</font>

<font style="color:rgb(85, 85, 85);">当然，反过来说，之所以可以这样设计，还是在于值对象无需承担跟踪和管理唯一标识的职责。</font>

<font style="color:rgb(85, 85, 85);">这也是为何Eric要将实体和值对象分开的主要原因，也是值对象给我们带来的价值所在。</font>

## <font style="color:rgb(85, 85, 85);">如何理解Repository</font>
<font style="color:rgb(85, 85, 85);">问题：怎么看待DDD中的Repository？</font>

<font style="color:rgb(85, 85, 85);">回答：我们必须把握一个根本的底线，就是采用DDD方式设计Repository时，一定要忘记所有与数据访问有关的技术实现细节。Repository接口属于领域层，一旦我们将Repository视为DAO对象，就会不期然地重回数据驱动设计的老路。</font>

<font style="color:rgb(85, 85, 85);">Eric在书中写道：“Repository将某种类型的所有对象表示为一个概念集合（通常是模拟的）”。这句话一语道破天机，也是DDD得名的由来，必须是通过领域去驱动设计，也就是说在这个设计过程中，应尽量去掉技术的色彩。</font>

<font style="color:rgb(85, 85, 85);">借用Martin Fowler对重构的隐喻，在领域驱动设计过程中，也有两顶帽子：领域设计与技术实现。在进行领域设计时，考虑的应该是领域逻辑、业务规则，以及随之需要设计演进的领域模型；一旦开始关注技术实现，就应该切换到与领域完全无关的技术关注点上。这也就是我认为非常关键的点：分离技术复杂度和业务复杂度。</font>

<font style="color:rgb(85, 85, 85);">Repository是一个概念集合，我们在领域设计时，又需要保证领域概念的完整性，并考虑领域逻辑的不变性约束，因此，DDD才会引入Aggregate。同时，DDD明确约定：一个Aggregate只能有一个Repository，即聚合根的Repository。所有对聚合的访问都应该通过Repository来完成。</font>

## <font style="color:rgb(85, 85, 85);">Repository与DAO </font>
<font style="color:rgb(85, 85, 85);">问题：Repository与DAO其实都是两种模式的名称。然而在领域驱动设计中，名称本身就是非常重要的。Dao即Data Access Object，即数据访问对象。从其命名上看，就应该属于数据访问层，即DDD中的基础设施层。</font>

<font style="color:rgb(85, 85, 85);">回答：在DDD中，所有的领域对象应该都属于领域层。那么，该如何访问这些领域对象呢？DDD希望解除领域层与基础设施层之间的关系，即将设计的注意力完全放在领域建模和领域设计上，思考领域逻辑的实现时，应尽可能地不要考虑领域对象的持久化（数据访问），于是就定义了Repository这个抽象。无论放在哪里（文件、DB或者内存），Repository都将其视为一个“资源库”的抽象。经过这么一层的抽象之后，获取领域对象，或者说管理领域对象生命周期的逻辑就应该属于领域层。</font>

<font style="color:rgb(85, 85, 85);">在实现上，你当然可以将这样的Repository接口命名为DAO，这本身没有问题，但名不正则言不顺，如果在领域层中夹杂了一个名为DAO的接口，仍然有“将基础设施混入领域层”的嫌疑。</font>

<font style="color:rgb(85, 85, 85);">所以，Repository是抽象，代表了对领域对象生命周期的管理，但并不等于是持久化，持久化只是Repository的其中一种实现。你可以假设一台服务器无比的强大，内存大且永远不会宕机，这时何须持久化呢？但无论怎么修改生命周期的具体管理方式，都不会影响到Repository的抽象。</font>

## <font style="color:rgb(85, 85, 85);">领域服务与应用服务  </font>
<font style="color:rgb(85, 85, 85);">问题：应用服务与领域服务的区别在哪？</font>

<font style="color:rgb(85, 85, 85);">回答：从分层架构上，应用服务属于应用层，领域服务属于领域层。</font>

<font style="color:rgb(85, 85, 85);">从职责上看，应用服务只是一个门面（Facade），它具体并不做领域服务的活儿，也就是不提供领域实现，也就是不包含业务逻辑。之所以要引入应用服务，有两个原因：</font>

+ <font style="color:rgb(85, 85, 85);">领域服务或其他领域对象的粒度太细（便于协作、扩展和重用），不利于客户端的调用，基于“最小知识原则”，还是让客户端少知道这些领域对象协作的知识为好。此时的应用服务更像是对领域对象的一种“编排”。</font>
+ <font style="color:rgb(85, 85, 85);">在调用领域对象去完成一个用例时，不可避免地要牵涉到一些属于“横切关注点”的内容，如事务、异常处理、授权认证等。这些横切关注点从职责上看，不属于领域层，放在领域服务中可能会导致对领域逻辑的污染，这些职责就像砌砖墙时需要的水泥。水泥自身不提供砖头的职责，但没有水泥，墙就没法砌起来。</font>

<font style="color:rgb(85, 85, 85);">具体对领域服务和应用服务的阐述，可以看我的这篇文章《一篇文章教你分辨应用服务和领域服务》。</font>

## <font style="color:rgb(85, 85, 85);">传统项目到DDD的演化</font>
<font style="color:rgb(85, 85, 85);">问题：针对没有采用DDD的项目，如何演化为DDD</font>

<font style="color:rgb(85, 85, 85);">回答：在《领域驱动设计》的第四章”分离领域“，Eric给出了几点DDD的适用范围：</font>

+ <font style="color:rgb(85, 85, 85);">领域驱动设计只有应用在大型项目上才能产生最大的收益，而这也确实需要高超的技巧。不是所有的项目都是大型项目；也不是所有的项目团队都能掌握这些技巧</font>
+ <font style="color:rgb(85, 85, 85);">如果一个架构能够把那些与领域相关的代码隔离出来，得到一个内聚的领域设计，同时又使领域与系统其它部分保持松散耦合，那么这种架构也许可以支持领域驱动设计</font>
+ <font style="color:rgb(85, 85, 85);">将领域实现独立出来是领域驱动设计的前提</font>

<font style="color:rgb(85, 85, 85);">因此，领域驱动设计绝对不是银弹，我们也不要将领域驱动设计视为拯救项目的灵丹妙药。从上述几点描述，我们似乎可以得出DDD的基础要素：</font>

+ <font style="color:rgb(85, 85, 85);">项目的规模与领域复杂度</font>
+ <font style="color:rgb(85, 85, 85);">项目成员的设计能力</font>

<font style="color:rgb(85, 85, 85);">当我们开始做一个新项目时，有可能从一开始业务并没有多复杂，系统规模也不够大，没有运用DDD是可以接受的选择。但随着需求的增加与变化，项目规模与领域复杂度都达到了DDD的要求。这时该如何应对？</font>

<font style="color:rgb(85, 85, 85);">针对这种已有的系统，若要从Non-DDD形式演化为DDD形式，无非是两种策略：</font>

+ <font style="color:rgb(85, 85, 85);">策略一：对已有系统进行重构。注意这种重构并非Martin Fowler提出的代码级别重构，而是对领域模型的重构。如果没有领域模型，那么我们就需要去重新发掘领域知识，建立统一语言，进而提炼出领域模型，然后使用领域模型指导我们的程序设计。这时，需要重构已有代码来满足领域模型表达的知识。</font>
+ <font style="color:rgb(85, 85, 85);">策略二：如果已有系统的功能与新需求存在一个清晰的边界，更简单的办法是将已有功能视为一个Bounded Context，然后对新需求采用DDD设计方法，并通过引入防腐层和已有系统进行通信。</font>

<font style="color:rgb(85, 85, 85);">倘若开启的新项目在领域复杂度上达不到DDD的要求，我仍然建议运用DDD，只不过需要将DDD的设计重点放在战略设计阶段，即对项目划分合理的Bounded Context。一旦确定了这些Context的边界，在边界之内进入战术设计阶段时，就可以不采纳DDD的设计方式，例如选择使用Transaction Script。</font>

## <font style="color:rgb(85, 85, 85);">领域驱动设计与微服务</font>
<font style="color:rgb(85, 85, 85);">问题：领域驱动设计与微服务之间的关系是什么？</font>

<font style="color:rgb(85, 85, 85);">领域驱动设计的战略设计可以帮助我们识别微服务的边界。针对微服务内部，可以采用DDD的方式，也可以采用其他方式，这个并没有特别约束。</font>

<font style="color:rgb(85, 85, 85);">大体可以这样认为：</font>

+ <font style="color:rgb(85, 85, 85);">战略层面，领域驱动设计指导了微服务设计，微服务架构影响了领域驱动设计</font>
+ <font style="color:rgb(85, 85, 85);">战术层面，二者没有任何关系，但DDD可以是微服务的其中一种实现</font>

<font style="color:rgb(85, 85, 85);">实践中，我们通常会使用DDD的Bounded Context、Context Map以及六边形架构来指导微服务设计。反过来，由于微服务强调服务的独立部署，因此微服务的引入重新定义了Bounded Context的边界，服务之间的通信也突破了Context Map的集成模式。</font>

<font style="color:rgb(85, 85, 85);">至于微服务对数据存储的设计约束——“每个微服务的数据单独存储”，属于基础设施层面，严格来讲，与领域驱动设计是没有任何关系的。</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">2018年3月18日</font>

# <font style="color:rgb(85, 85, 85);">事件风暴的设计要素与驱动力</font>
<font style="color:rgb(85, 85, 85);">个人认为，相比较传统领域分析方法，事件风暴的革命意义在于它建立了以“领域事件”为核心的建模思路，这相当于改变了我们观察业务领域的世界观。</font>



<font style="color:rgb(85, 85, 85);">当我们在理解业务需求时，我们看到的常常是功能、流程，并通过从需求描述中梳理领域概念，进而借助这些概念去识别那些参与到业务场景中互为协作的领域对象，这往往让我们忽略了一个在任何领域中都必须存在的概念，即“</font>**事件**<font style="color:rgb(85, 85, 85);">”。这些事件是每次用户操作、业务活动留下来的不可磨灭的足迹，它牵涉到状态的迁移，业务事实的发生，忠实地记录了每次执行命令后可能产生的结果。倘若这些事件还直接影响到该领域的运营和管理时，则可以将它们认为是“关键事件”。</font>



<font style="color:rgb(85, 85, 85);">正如Martin Fowler对领域事件的定义：“重要的事件肯定会在系统其它地方引起反应，因此理解为什么会有这些反应同样也很重要。”在识别和理解事件时，正是要从这样的因果关系着手，考虑为什么要产生这一事件，以及为什么要响应这一事件，进而思考如何响应这个事件，驱动着设计者的“心流”不断思考下去，就像搅动了一场激荡湍急的风暴一般。我想着或许是Alberto Brandolini将其命名为事件风暴的缘由吧。</font>



<font style="color:rgb(85, 85, 85);">在事件风暴中，往往使用橙色标签来代表一个“关键事件”。由于事件代表的是一个已经发生的事实（fact），所以往往用动词的过去时态来表达，例如OrderConfirmed事件。</font>



<font style="color:rgb(85, 85, 85);">在识别“事件”时，团队应与业务人员一起通过梳理业务流程，在统一语言的指导下共同寻找这些可能直接影响业务价值与运营目的的“关键事件”。在一个业务场景中，一系列“关键事件”连接起来，会形成明显的基于一条时间线的状态迁移过程。如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704161790246-38246cfa-3484-4b6d-ab59-0bb6194593e1.png)



<font style="color:rgb(85, 85, 85);">这种状态迁移过程体现了业务的</font>**因果关系**<font style="color:rgb(85, 85, 85);">。这种因果关系是一种不断传递的过程，导致事件发生的因，在事件风暴中被称之为</font>**命令（Command）**<font style="color:rgb(85, 85, 85);">，相当于事件的发布者，在事件风暴中使用蓝色标签来表示。一旦事件发生，作为该命令的结果又可能引起别的业务反应，事件的订阅者关心这一结果，然后触发新的命令，变成了下一个流程的起因。命令往往由动宾短语组成，例如Place Order、Send Invitation等。</font>



<font style="color:rgb(85, 85, 85);">注意，在识别事件时，要注意区分触发事件的四种情形：</font>

+ <font style="color:rgb(85, 85, 85);"> 由用户活动触发：例如用户将商品加入到购物车 </font>
+ <font style="color:rgb(85, 85, 85);"> 外部系统：支付系统返回交易凭证 </font>
+ <font style="color:rgb(85, 85, 85);"> 时间消逝导致：订单的支付时间超时 </font>
+ <font style="color:rgb(85, 85, 85);"> 另一个领域事件的结果：支付命令产生支付完成事件（PaymentProcessed），该事件导致订单完成事件（OrderCompleted） </font>



<font style="color:rgb(85, 85, 85);">事件由命令触发，那么谁又是命令的发起者呢？答案是</font>**参与者（Actor）**<font style="color:rgb(85, 85, 85);">。参与者的引入就将对事件的分析与业务场景结合起来，这就驱动着参与事件风暴的所有成员要对业务达成一致（形成统一语言），并从用户体验（User Experience）的角度去分析每个业务场景。这时作为参与者对业务的参与，就不再是发起一个业务流程，执行一个业务动作，而是做出</font>**决策（Decision）**<font style="color:rgb(85, 85, 85);">。在事件风暴中，决策就是命令，但“决策”更具有拟人化的意义，正如在现实生活中，当一个管理者要做出决策时，需要如下两方面数据的支撑：</font>

+ <font style="color:rgb(85, 85, 85);"> 信息：必须基于足够充分的信息才能做出正确的决策，提供这些信息的对象就称之为</font>**读模型（Read Model）**<font style="color:rgb(85, 85, 85);">，在事件风暴中用绿色标签表示。 </font>
+ <font style="color:rgb(85, 85, 85);"> 策略：一旦做出决策就会触发一个业务流程，流程的执行暗含了业务规则，该规则被命名为</font>**策略（Policy）**<font style="color:rgb(85, 85, 85);">，在事件风暴中用紫色标签表示。 </font>



<font style="color:rgb(85, 85, 85);">描述策略时，往往可以使用“一旦（Whenever）”这个关键字来引导对策略规则的描述。策略引发的决策可以是自动的，也可以是参与者人为触发的。Alberto Brandolini给出了描述策略的实例，如：</font>

> <font style="color:rgb(85, 85, 85);">whenever the exposure passes the given threshold, we need to notify the risk manager. 一旦关注的值超出给定的阈值，我们就需要通知风险管理者。</font>
>



> <font style="color:rgb(85, 85, 85);">whenever a user logs in from a new device, we send him an SMS warning. 一旦用户从一个新设备中登录，我们就应该给用户发送一条短信警告。</font>
>



<font style="color:rgb(85, 85, 85);">在运用事件风暴时，我们可以通过用户体验（例如用户旅程等UX方法）剖析业务场景，从参与者到命令再到事件，又可以围绕着表达状态迁移的事件为核心，将策略与读模型组合在一起帮助我们推导出命令对象。Alberto Brandolini整体描述了事件风暴的驱动过程：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903094823-4b6f63a0-3f74-411a-b2e8-eede9dbfd01a.png)



<font style="color:rgb(85, 85, 85);">一旦我们识别了事件和对应的命令，我们就可以根据这些对象的生命周期与职责内聚性识别出</font>**聚合（Aggregate）**<font style="color:rgb(85, 85, 85);">与</font>**聚合根**<font style="color:rgb(85, 85, 85);">。聚合在事件风暴中使用黄色标签来表示。聚合是命令的真正发起者，这是相对于前面提到的参与者而言。在问题域中，是由参与者（用户、系统或其他特殊组件，如定时器）发起命令来“开启”一个业务流程。但在解决方案域，我们是从职责的角度去看待命令的，这就需要在领域模型中去寻找履行该职责的对象，即聚合。例如，在电商系统的业务流程中，问题域表达的是“买家购买了商品”，对应的解决方案域，则是“购物车添加了购物项”，因此分析获得ShoppingCart这个聚合对象。</font>



<font style="color:rgb(85, 85, 85);">一旦获得了这些内聚的聚合，就可以根据各自的相关性对聚合进行分组，从而获得限界上下文。在获得限界上下文的过程中，可以从业务、团队合作与技术实现等诸多方面进行判定。由于限界上下文属于解决方案域的内容，在初步获得限界上下文之后，团队就可以考虑这些限界上下文的技术实现。尤其是在微服务架构下，需要针对微服务特征来确定限界上下文的粒度与边界是否合理。此时，我们可以引入上下文映射，通过识别限界上下文之间的协作关系进一步确认它的合理性。</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">2019年2月1日</font>

# <font style="color:rgb(85, 85, 85);">使用事件风暴探索业务全景</font>
<font style="color:rgb(85, 85, 85);">本文介绍了如何使用事件风暴探索系统的业务全景，是深度介绍事件风暴方法的第一部分。</font>



![](https://cdn.nlark.com/yuque/0/2024/jpeg/859018/1704161838375-977472d6-e17a-4cdf-85df-529518dad7a0.jpeg)

## <font style="color:rgb(85, 85, 85);">事件风暴</font>


<font style="color:rgb(85, 85, 85);">事件风暴是一种高度强调交流与协作的可视化工作坊，是大白纸与各色即时贴的重度使用者。面对着糊满整面墙的大白纸，工作坊的参与人员通过充分地交流与沟通，然后用马克笔在各色即时贴上写下各个领域模型概念，贴在墙上呈现生动的模型。由于这些模型都是可视化的，就可以给团队直观印象。大家站在墙面前，观察这些模型，及时开展讨论。若发现有误，就可以通过移动即时贴来调整与更新，也可以随时贴上新的即时贴完善建模结果。</font>



![](https://cdn.nlark.com/yuque/0/2024/jpeg/859018/1704161838343-11e97e2e-65a5-40be-ad8f-4ea71810865b.jpeg)



<font style="color:rgb(85, 85, 85);">Alberto Brandolini设计的事件风暴通常分为两个层次。如果在工作坊过程中将主要的精力用于寻找业务流程中产生的领域事件，则这个过程可以认为是宏观级别的事件风暴，其目的是探索业务全景（Big Picture Exploration）。在识别出全景事件流之后，就可以标记时间轴的关键时间点作为划分领域边界和限界上下文边界的依据；同时也可以基于事件表达的业务概念对领域进行划分，最终确定候选的子领域和限界上下文。</font>



<font style="color:rgb(85, 85, 85);">另一个层次则属于设计级别（Design-level）的领域分析建模方法，通过探索业务全景获得的事件流，围绕着事件获得领域分析模型。这些领域分析建模要素除了领域事件之外，还包括决策命令、读模型和聚合。事件风暴的领域分析建模方法通常会以业务全景探索的结果作为领域分析建模的基础。</font>

## <font style="color:rgb(85, 85, 85);">探索业务全景</font>


<font style="color:rgb(85, 85, 85);">在探索业务全景的过程中，为了使每个人保持专注，一开始要排除其余领域概念的干扰，一心寻找沿着时间轴发展的事件。事件是事件风暴的主要驱动力，寻找出来的事件则是领域分析模型的骨架。事件风暴使用橙色即时贴来代表一个事件（Event）。</font>



<font style="color:rgb(85, 85, 85);">事件风暴工作坊要求沿着时间轴对事件进行识别。通常的做法是由领域专家贴上第一张他/她最为关心的事件，然后由大家分头围绕该事件写出在它之前和之后发生的事件，并按照时间顺序由左向右排列。以信用卡申请开卡的业务为例，领域专家认为“开卡申请已审批”是我们关注的核心事件，于是就可以在整面墙的中间贴上橙色即时贴，上面写上“开卡申请已审批”事件：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903226418-3ed310cc-7ea4-42a2-b7a4-903421262010.png)



<font style="color:rgb(85, 85, 85);">在确定这个核心事件之后，我们就要以此为中心，向前推导它的起因，向后推导它的结果，根据这种因果关系层层推进，逐渐形成一条或多条沿着时间轴且彼此之间存在因果关系的事件流：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903256449-fd9f5102-f965-421f-b8c7-07cf0a70569a.png)



<font style="color:rgb(85, 85, 85);">在识别事件的过程中，工作坊的参与人员应尽可能站在管理和运营的角度去思考领域事件。这里所谓的“因果关系”，也可以理解为产生事件的前置条件是什么，由此推导出前置事件；事件导致的后置条件是什么，由此推导出后置事件。</font>



<font style="color:rgb(85, 85, 85);">从“开卡申请已审批”事件往前推导，它的前置条件是什么呢？显然，只有在信用卡申请人提交了开卡申请之后才可能审批申请，由此得到前置事件“开卡申请已提交”。以此类推，“开卡申请已提交”的前置条件又是什么呢？申请人在提交申请信息之前，需要通过征信系统对填写的内容做征信预检，于是可推导出前置事件“征信预检已完成”：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903278070-a9a3023f-bf8e-4f14-8793-f1a48ad215d2.png)



<font style="color:rgb(85, 85, 85);">从“开卡申请已审批”事件往后推导，它的后置条件是什么呢？如果开卡申请通过了，一方面保证申请人收到审批结果通知，另一方面则开始制卡，首先就需要保证信用卡号已经生成，由此得到两个并行的后置事件“卡号已生成”和“审批结果已通知”。接着，在“卡号已生成”事件之后，就是等待制作信用卡的结果，由此获得后置事件“信用卡制作完毕”：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903293937-6e287283-5c73-4c4b-9627-b33fae1be6f9.png)



<font style="color:rgb(85, 85, 85);">事件风暴是一种探索性的建模活动。在探索事件的过程中，我们不要急于去识别其他的领域对象，基于事件结果，也不要急于去寻找导致事件发生的起因。尤其是在探索业务全景期间，更要如此。毕竟人的注意力是有限的。</font>



<font style="color:rgb(85, 85, 85);">从一开始，就应该让工作坊的参与人员集中精力专注于事件。倘若存在疑问，又或者需要提醒业务人员或技术人员特别注意，可以用粉红色即时贴来表达该警告信息，Alberto Brandolini将其称之为“热点Hot Spot”。例如针对“开卡申请已审批”事件，需要考虑审批未通过的异常情况；“卡号已生成”事件需要考虑不同类型的信用卡需遵循不同的卡号生成规则；“审批结果已通知”事件可以标记系统支持的通知方式：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903311110-aecbea1f-33ac-40b5-9191-c9af11c72fa3.png)

<font style="color:rgb(85, 85, 85);">如前所述，触发事件的起因包括三种可能。在事件风暴业务全景探索过程中，可以在获得全景事件流之后，判断各个事件的起因，并分别用不同颜色的即时贴进行标记：</font>

+ <font style="color:rgb(85, 85, 85);"> 由用户活动触发：标记参与事件的用户角色，用黄色小即时贴绘制火柴棍人表示 </font>
+ <font style="color:rgb(85, 85, 85);"> 当条件满足时：标记引起事件的策略，用紫色即时贴表示 </font>
+ <font style="color:rgb(85, 85, 85);"> 外部系统：标记引起事件的外部系统，用浅粉色即时贴表示 </font>



<font style="color:rgb(85, 85, 85);">前面获得的事件流可以表示为：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903333007-de02a442-7632-414e-923c-731669db7e69.png)

<font style="color:rgb(85, 85, 85);">不要小看对这些事件起因的标记。在完成全景事件流之后，对事件的起因进行再一次梳理有助于团队就识别的事件达成一致，检查事件是否存在疏漏、谬误之处。作为事件起因的用户、外部系统与策略还为后面的领域分析建模奠定基础。其中，识别出的外部系统也有助于未来的架构设计，帮助我们绘制《领域驱动战略设计实践》课程中讲到的C4模型中的系统上下文（System Context）图。</font>

# <font style="color:rgb(85, 85, 85);">运用事件风暴进行领域分析建模</font>
<font style="color:rgb(85, 85, 85);">本文是事件风暴方法的战术设计部分，从获得的业务全景开始进行领域分析建模，通过事件识别出决策命令，进而驱动出读模型和聚合。获得领域分析模型还将是领域驱动设计过程的重要输入。</font>



<font style="color:rgb(85, 85, 85);">在确定了全景事件流之后，可以在战略设计层面继续精进，鉴别出领域与限界上下文的边界。这里略过不提，且进入战术设计阶段的领域分析建模。</font>

## <font style="color:rgb(85, 85, 85);">事件风暴的分析模型要素</font>


<font style="color:rgb(85, 85, 85);">通过事件风暴进行领域分析建模，其核心的模型要素就是“事件”。除此之外，参与事件风暴的分析模型要素还包括决策命令、读模型、策略和聚合。其中，事件和策略已经在探索业务全景的时候进行了初步识别。</font>

### <font style="color:rgb(85, 85, 85);">决策命令</font>
<font style="color:rgb(85, 85, 85);">通观事件之起因，除了外部系统是直接发布事件之外，无论是用户活动，还是满足某个条件，都需要一个命令（Command）来响应，它才是直接导致事件发生的“因”。在事件风暴中，Alberto Brandolini将命令称之为“决策命令（Decision Command）”，使用浅蓝色即时贴表示。决策命令往往由动宾短语组成，例如Place Order、Send Invitation等。</font>



<font style="color:rgb(85, 85, 85);">由于决策命令和事件存在因果关系，因此二者往往是一一对应的。例如，Cancel Order决策命令会触发OrderCancelled事件，Subscribe Course决策命令会触发CourseSubscribed事件。正是这种一一对应关系，使得它们存在语义上的重叠，区别仅在于时态。故而有的事件风暴实践者认为可以在事件风暴中省略决策命令。</font>



<font style="color:rgb(85, 85, 85);">我并不敢苟同这一观点，相反，我反而极为强调决策命令在事件风暴中的重要性，它是领域分析建模的一个重要驱动力，因为通过它连接了用户、策略、聚合、读模型和事件，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903444832-c742c562-009e-4b83-9d7f-47631144e6c6.png)



<font style="color:rgb(85, 85, 85);">从图中可以看出，由事件可以驱动出决策命令，在它们之间籍由聚合对象来发布事件。当事件发生后，如果某个策略满足条件，也会引发决策命令，而用户在引发决策命令时，需要足够的读模型来帮助它做出正确的决策。</font>



<font style="color:rgb(85, 85, 85);">那么，该如何正确地理解决策命令？显然，Alberto Brandolini使用决策来修饰命令并非空穴来风，因为这一名词突出了命令往往需要更多的信息来帮助参与者（Actor）做出决策。</font>



<font style="color:rgb(85, 85, 85);">参与者是用例图的设计要素，在事件风暴中，可以认为是对所有事件起因的抽象：用户、条件满足（如定时器）与外部系统。其中，外部系统对我们而言是一个黑盒子，不用考虑它是如何触发了事件，因而可以忽略。因此，参与者在基于业务场景做出决策时，需要如下两方面数据的支撑：</font>

+ <font style="color:rgb(85, 85, 85);"> 信息：必须基于足够充分的信息才能做出正确的决策，提供这些信息的对象被称之为读模型（Read Model），在事件风暴中用浅绿色即时贴表示。 </font>
+ <font style="color:rgb(85, 85, 85);"> 策略：根据业务规则，当某个条件满足时，会触发一个决策命令，这个业务规则被命名为策略（Policy），在事件风暴中用紫色标签表示。 </font>

### <font style="color:rgb(85, 85, 85);">读模型和策略</font>


<font style="color:rgb(85, 85, 85);">当决策命令由用户引发时，可以确认该决策命令的发生是否需要提供足够的读模型信息。读模型是用户通过查询（读）操作获得的。若不具备这一信息，可能不足以支持用户执行决策命令。例如买家希望提交订单，就需要先查看购物车获得购物车内容，然后才能执行下订单（Place Order）的决策命令，触发OrderCreated事件。这时，查看购物车获得的结果ShoppingCart就是读模型：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903490923-0d8ece78-ec87-469a-9611-5217f7d66fac.png)



<font style="color:rgb(85, 85, 85);">读模型是用户执行决策命令必需的输入信息，在代码层面，这些读模型就是执行决策命令的领域行为所需的输入参数。用户发起决策命令的方式是因为执行了某个活动，例如决策命令“提交订单”实则是因为用户点击了“提交订单”按钮。用户活动的执行与用户体验（User eXerperience，UX）直接有关。</font>



<font style="color:rgb(85, 85, 85);">现实世界的业务场景通过用户体验将用户与读模型结合起来，把信息传输给事件风暴的决策命令。这一过程牵涉到用户、查询和命令操作，恰好符合组成用例的要素。若建模人员熟悉用例，也可借助用例图来分析。</font>



<font style="color:rgb(85, 85, 85);">注意，上图是将读模型ShoppingCart提供给Place Order决策命令，而非查询操作与命令操作之间的交互。有的事件风暴实践者将查询操作也纳入到事件风暴的模型中，认为是用户执行查询操作获得读模型后，触发了决策命令，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903505631-3660301e-4fc6-4ccb-a1a5-2196e1b3cd7a.png)



**我认为这样的模型设计并不恰当**<font style="color:rgb(85, 85, 85);">，因为它将活动流程图与事件的因果关系混为一谈了。</font>



<font style="color:rgb(85, 85, 85);">实际上，活动流程图反应了现实世界的问题域，事件风暴表现的事件因果关系却是解决方案域的内容，这是领域建模活动中两个不同的层次。买家先查询购物车，然后提交订单，这是买家的操作流程。但从事件的因果关系看，并非“查询购物车”触发了“提交订单”这个决策命令，而是用户通过查询获得了购物车读模型之后，由用户发起“提交订单”的决策命令，再通过订单聚合发布了OrderCreated事件。</font>



<font style="color:rgb(85, 85, 85);">“查询购物车”和“提交订单”是两个不同的用户活动，它们并不具有时序上的连续性，可以认为是两个独立的业务场景。由于查询操作并不会触发事件的发生，从模型上看，它也不会导致命令的发生，因而在事件风暴中，并没有查询操作的位置，而是以读模型的形式出现。这也变相地促使建模人员在识别用户活动时，需要分辨该活动究竟是查询还是命令，有利于CQRS模式的落地。</font>



<font style="color:rgb(85, 85, 85);">当决策命令由策略引发时，就表示事件发生后某些数据满足了某条业务规则。一旦该策略被满足，就会引起目标对象的状态变更，然后根据业务规则的规定触发下一个决策命令。</font>



<font style="color:rgb(85, 85, 85);">例如，策略“提交订单后，一旦超过规定时间未支付，则取消订单”会触发Cancel Order命令，从而引起OrderCancelled事件的发生。策略引发的决策可以是自动的，如定时器检测到支付时间超时；也可以是用户手动触发，如用户登录时输入错误密码的次数太多；还可以二者并存，如在取消订单业务场景中，Cancel Order命令既可以由定时器自动触发，也可以由用户手动触发。</font>

### <font style="color:rgb(85, 85, 85);">聚合</font>


<font style="color:rgb(85, 85, 85);">虽然决策命令和事件之间存在因果关系，但事件并非直接由决策命令发布，而是借助一个“媒介”来发布事件。这个媒介就是“聚合（Aggregate）”。聚合在事件风暴中使用黄色大即时贴来表示。聚合划分了现实世界和模型世界之间的界线。在现实世界，是用户执行了决策命令触发了事件；在模型世界，是聚合履行了发布事件的职责。例如，在电商系统的业务流程中，现实世界的用户活动是用户提交了订单；在模型世界，是Order聚合发布了OrderCreated事件。</font>



<font style="color:rgb(85, 85, 85);">寻找聚合的过程可能是一个艰难的过程。由于聚合是构成领域分析模型的核心要素，识别聚合需要审慎，不要轻易下结论。若未寻找到它，可以先贴上一个空白的黄色大即时贴表示这里存在一个聚合，但目前还不知道它的名字。</font>



<font style="color:rgb(85, 85, 85);">在事件风暴中，我们也可以利用事件来反向寻找聚合。分析事件的特征，由于它是由决策命令触发的，意味着事件的产生会带来目标对象状态的变化。状态的变化分为三种形式：</font>

+ <font style="color:rgb(85, 85, 85);"> 从无到有：意味着创建，例如“订单已创建”事件标志着新订单的产生； </font>
+ <font style="color:rgb(85, 85, 85);"> 修改属性值：意味着值的更新，例如“订单已取消”事件使得订单从之前的状态变更为“已取消”状态；也可能意味着内容的变化，例如“商品被加入到购物车”事件，说明购物车增加了一个新的条目； </font>
+ <font style="color:rgb(85, 85, 85);"> 从有到无：意味着删除，不过在多数项目中并不存在这种状态变化；表面是删除，实际是修改属性值。例如“会员已注销”事件和“商品已下架”事件，实则都不是直接删除会员和商品记录，而是将该记录的状态置为“已注销/已下架”状态。 </font>



<font style="color:rgb(85, 85, 85);">显然，发生状态变更的对象有很大几率就是我们要寻找的聚合对象。毕竟聚合对象承担了发布事件的职责，而事件又是由于状态变更而产生。谁能准确地侦知状态是否变更以及何时发生变更？我想，只有拥有状态的聚合对象自身才具备这一能力。</font>

## <font style="color:rgb(85, 85, 85);">事件风暴的建模过程</font>


<font style="color:rgb(85, 85, 85);">显然，围绕着“事件”为中心，事件风暴给出了一条有章可循的领域分析建模路径。领域分析建模的基础是探索业务全景的产出物，即业已识别出来的事件流，以及参与事件流的用户、策略与外部系统。整个领域分析建模的过程如下：</font>

**第一步：**<font style="color:rgb(85, 85, 85);">挑选任意一个与用户有关的事件，反向驱动出决策命令，该用户就是发出决策命令的人（角色）。从事件驱动出决策命令非常容易，就是将事件的过去时态转换为动宾形式的决策命令即可。</font>

**第二步：**<font style="color:rgb(85, 85, 85);">根据决策命令与事件之间的因果关系，推导出要发布该事件必须的前置信息，即决策所需的读模型。读模型通常由用户通过查询操作获得，可以理解为是决策命令行为的输入参数。</font>

**第三步：**<font style="color:rgb(85, 85, 85);">根据事件状态变更的目标，决定决策命令与事件之间的聚合对象。若无法确定，则保留一个空的黄色即时贴，待以后确定。</font>

**第四步：**<font style="color:rgb(85, 85, 85);">选择当前事件的后置事件。若后置事件仍然与用户有关，则重复第一步；若后置事件与外部系统有关，可以跳过该事件的建模，继续选择下一个后置事件。若事件与策略有关，在进一步细化策略对象之后，驱动出决策命令，重复第三步。</font>



<font style="color:rgb(85, 85, 85);">以前面所示的信用卡开卡事件流为例，我们依次选择以下三个事件：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903542738-bee0f8cd-06d8-406a-b5fd-8ba76ad637f5.png)



<font style="color:rgb(85, 85, 85);">首先是审批人参与的“开卡申请已审批”事件，执行第一步，由该事件可以反向驱动出决策命令“审批开卡申请”。</font>



<font style="color:rgb(85, 85, 85);">第二步是根据决策命令推导出触发事件需要的读模型。审批开卡申请的前置信息是“申请”和“用户征信”，若缺乏这两个信息，审批人无法做出“审批开卡申请”的决策。</font>



<font style="color:rgb(85, 85, 85);">第三步是确定决策命令与事件之间的聚合对象。显然，“开卡申请已审批”事件影响到的就是申请的状态，它就是我们要寻找的聚合对象：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903558889-fbab8af8-b10b-4cb9-8bf8-6f72ba93f848.png)



<font style="color:rgb(85, 85, 85);">接着进入第四步，选择下一个后置事件“卡号已生成”。该事件与策略有关，细化策略为“卡号规则”。由事件驱动出决策命令为“生成卡号”，进入第三步，识别两者之间的聚合对象。卡号的生成影响了信用卡的属性，可以认为该事件影响状态的目标对象为“信用卡”：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903575672-29bf9071-3bee-4c1a-9665-0a3a098b5724.png)



<font style="color:rgb(85, 85, 85);">继续第四步，选择下一个后置事件“信用卡制作完毕”。由于该事件由外部系统发布，可以忽略该建模过程，仅仅标记外部系统即可：</font>

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703903600114-cfee3ea6-01e0-4571-ae60-a96fe855e2d5.png)



<font style="color:rgb(85, 85, 85);">通过这个简单案例，可以清晰地看到我总结的领域分析建模过程具有一定的可操作性。事件风暴工作坊的参与人员可以按照建模步骤一步一步执行。执行每一步都需要团队与领域专家进一步讨论和确认，保证识别出来的模型对象遵循该领域的统一语言。</font>



<font style="color:rgb(85, 85, 85);">在这个分析建模过程中，每个模型对象都有着建模的参考依据，包括模型对象的身份特征、彼此之间的关系、承担的职责，这就在一定程度上减轻了对建模人员经验的依赖。</font>

# <font style="color:rgb(85, 85, 85);">领域场景分析的6W模型</font>
<font style="color:rgb(85, 85, 85);">在软件构造过程中，我们必须正确地理解领域。一种生动的方式是通过“场景”来展现领域逻辑。领域专家或业务分析师从领域中提炼出“场景”，就好像是从抽象的三维球体中，切割出具体可见的一片。然后以这一片场景为舞台，上演各种角色之间的悲欢离合。每个角色的行为皆在业务流程的指引下展开活动，并受到业务规则的约束。当我们在描述场景时，就好像在讲故事，又好似在拍电影。</font>



<font style="color:rgb(85, 85, 85);">组成场景的要素常常被称之为</font>**6W模型**<font style="color:rgb(85, 85, 85);">，即描写场景的过程必须包含</font>**W**<font style="color:rgb(85, 85, 85);">ho，</font>**W**<font style="color:rgb(85, 85, 85);">hat，</font>**W**<font style="color:rgb(85, 85, 85);">hy，</font>**W**<font style="color:rgb(85, 85, 85);">here，</font>**W**<font style="color:rgb(85, 85, 85);">hen与ho</font>**W**<font style="color:rgb(85, 85, 85);">这六个要素。6W模型如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704161943419-418b7262-f918-43e5-ab81-47d9262f3c4c.png)



<font style="color:rgb(85, 85, 85);">通过场景分析领域需求时，我们需要首先识别参与该场景的用户角色。我们可以为其建立用户画像（Persona），通过分析该用户的特征与属性辨别该角色在整个场景中参与的活动。这意味着我们需要明确业务功能（what），思考这一功能给该角色能够带来什么样的业务价值（why）。注意，这里所谓的“角色”是参差多态的，同一个用户在不同场景可能是完全不同的角色。例如在电商系统中，倘若执行的是下订单功能，则角色就是买家；针对该订单发表评论，参与的角色就变成了评论者。</font>



<font style="color:rgb(85, 85, 85);">在6W模型中，我将领域功能划分为三个层次，即业务价值、业务功能和业务实现，我将其称之为“职责的层次”。定义为“职责（Responsibility）”，才能够更好地体现它与角色之间的关系，即“角色履行了职责”。业务价值体现了职责存在的目的，即解释了该领域需求的Why。只有提供了该职责，这个场景对于参与角色才是有价值的。为了满足业务价值，我们可以进一步剖析为了实现该价值需要哪些支撑功能，这些业务功能对应6W模型中的What。进一步，我们对功能深入分析，就可以分析获得具体的业务实现。业务实现关注于如何去实现该业务价值，因而对应于hoW。</font>



<font style="color:rgb(85, 85, 85);">在电商系统中购买商品时，对于买家而言，</font>**下订单**<font style="color:rgb(85, 85, 85);">这一职责是具有业务价值的。通过领域分析，结合职责的层次概念，我们就可以得到如下的职责分层结构：</font>

+ <font style="color:rgb(85, 85, 85);">下订单 </font>
    - <font style="color:rgb(85, 85, 85);">验证订单是否有效 </font>
        * <font style="color:rgb(85, 85, 85);">验证订单是否为空</font>
        * <font style="color:rgb(85, 85, 85);">验证订单信息是否完整</font>
        * <font style="color:rgb(85, 85, 85);">验证订单当前状态是否处于“待提交”状态</font>
        * <font style="color:rgb(85, 85, 85);">验证订单提交者是否为合法用户</font>
        * <font style="color:rgb(85, 85, 85);">验证商品库存量是否大于等于订单中的数量</font>
    - <font style="color:rgb(85, 85, 85);">基于业务规则计算订单总价、优惠与配送费 </font>
        * <font style="color:rgb(85, 85, 85);">获取用户信息</font>
        * <font style="color:rgb(85, 85, 85);">获取当前促销规则</font>
        * <font style="color:rgb(85, 85, 85);">计算订单总价</font>
        * <font style="color:rgb(85, 85, 85);">计算订单优惠</font>
        * <font style="color:rgb(85, 85, 85);">计算商品配送费</font>
    - <font style="color:rgb(85, 85, 85);">提交订单 </font>
        * <font style="color:rgb(85, 85, 85);">将订单项插入到数据表中</font>
        * <font style="color:rgb(85, 85, 85);">将订单插入到数据表中</font>
        * <font style="color:rgb(85, 85, 85);">更新订单状态为“待付款”</font>
    - <font style="color:rgb(85, 85, 85);">发送通知 </font>
        * <font style="color:rgb(85, 85, 85);">给买家发送电子邮件，通知订单提交成功，等待付款</font>



<font style="color:rgb(85, 85, 85);">当我们获得这样的职责层次结构之后，就可以帮助我们更加细致地针对领域进行建模。在利用场景进行建模时，还要充分考虑场景的边界，即6W模型中的Where。例如在“下订单”的案例中，验证商品库存量的业务实现需要调用库存提供的接口，而该功能实则属于下订单场景的边界之外。领域驱动设计引入了</font>**限界上下文（Bounded Context）**<font style="color:rgb(85, 85, 85);">来解决这一问题。</font>



<font style="color:rgb(85, 85, 85);">针对问题域提炼领域知识是一个空泛的概念，业务场景分析的6W模型给出了具有指导意义的约束，要求我们提炼的领域知识必须具备模型的六个要素。这就好比两位侃侃而谈的交谈者，因为有了确定的主题与话题边界，一场本来是漫无目的野鹤闲云似的闲聊就变成了一次深度交流的专题高端对话。6W模型也是对领域逻辑的一种检验，如果提炼出来的领域逻辑缺乏部分要素，就有可能忽略一些重要的领域概念、规则与约束。这种缺失会对后续的领域建模直接产生影响。正本清源，按照领域场景分析的6W模型去分析领域逻辑，提炼领域知识，可以从一开始在一定程度上保证领域模型的完整性。</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">2018年4月9日</font>

# <font style="color:rgb(85, 85, 85);">领域驱动设计中的架构要素</font>
<font style="color:rgb(85, 85, 85);">多数时候，领域驱动设计的分层架构并不能清晰表达各模块之间的依赖关系，以及这些模块在分层架构中所处的位置。因为我倾向于将Uncle Bob的Clean Architecture与DDD的分层架构整合起来，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254451928-0d799284-8e4b-4ccc-bd87-aa6b5b62fd9d.png)



<font style="color:rgb(85, 85, 85);">在这个架构图中，基础设施层处于最外部，然后是应用层，最核心的是领域层。</font>**基础设施中的模块，我都称之为gateway。**<font style="color:rgb(85, 85, 85);">根据依赖方向，如果是被调用的方向，即由外至内的调用方向，就是北向，称之为北向网关。如果当前限界上下文是通过该网关调用外部资源或者别的限界上下文，即由内至外的调用方向，则是南向网关。例如图中的</font>`<font style="color:rgb(85, 85, 85);">OrderController</font>`<font style="color:rgb(85, 85, 85);">，会被别人调用，因而属于北向网关。注意，倘若</font>`<font style="color:rgb(85, 85, 85);">OrderController</font>`<font style="color:rgb(85, 85, 85);">通过RESTful方式暴露API，即为REST服务，也就是基于资源的服务。我们不能将它与DDD的应用服务混为一谈。</font>



<font style="color:rgb(85, 85, 85);">南向网关要特殊一些，它是打通应用层或领域层与外部资源（数据库、消息队列、第三方服务）的通道。根据整洁架构的设计原则，我们不能让内层依赖外层，以保证内层的纯粹性与稳定性。为了解除应用层或领域层与它的耦合，南向网关往往需要提供接口。这就说明，基础设施层的南向网关都是具体实现，内层对南向网关的调用则通过接口和依赖注入。至于它们的接口，就应该放在领域层或者应用层。例如，数据库的持久化属于南向网关，但它们的抽象Repository就属于领域层。</font>



<font style="color:rgb(85, 85, 85);">通过上图，可以帮助我们明确各个模块和各层之间的职责。下图则基于这样的内外层架构清晰地表达了限界上下文（Bounded Context，以下简称BC）之间的协作关系，即DDD中的Context Map：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254467311-76ad0eb6-2fe1-4994-8d85-563a8e8c3f3b.png)



<font style="color:rgb(85, 85, 85);">Context Map中有两个常用的模式OHS（开放主机服务）与ACL（防腐层）。显然，OHS就对应前面提到的北向网关，ACL就对应着南向网关。</font>



<font style="color:rgb(85, 85, 85);">为了遵循整洁架构原则，就需要为ACL提供一个抽象。例如订单要调用商家BC的服务，就需要在订单BC中定义一个被调用服务的接口，然后在ACL中，通过具体框架提供的跨进程调用方式，去真正发起对商家BC服务的调用。所以，我通常将代表ACL的模块命名为Client。通过Client可以防止上游BC发生变化时对下游BC产生直接影响。一旦变化发生，我们仅需要修改南向网关中的client实现。如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254479568-5da7aa20-87e1-4454-92f3-2da4fef8139a.png)



<font style="color:rgb(85, 85, 85);">这张图体现了有ACL和无ACL的区别。</font>



<font style="color:rgb(85, 85, 85);">下图体现了BC对领域概念的控制，它是控制领域概念一致性的边界。在DDD中，最好的方式是不去跨BC重用一个相同的领域概念：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254494126-931491b4-3012-448d-b2ee-a65e509226c5.png)



<font style="color:rgb(85, 85, 85);">假设我们的BC都是微服务，就是零共享架构，数据库是独立的。那么，各自BC关心的Product属性应该放在各自数据库中，它们的ID要保持一致。</font>



<font style="color:rgb(85, 85, 85);">现在基于这些认识来讨论两个问题：</font>

+ <font style="color:rgb(85, 85, 85);">一个BC如何发起对另一个BC的调用</font>
+ <font style="color:rgb(85, 85, 85);">调用时，是否会产生所谓的“领域模型”耦合</font>



<font style="color:rgb(85, 85, 85);">例如在订单BC中，如果在获得订单信息的同时，还需要获得订单中商品的信息以及该商品所属商家的信息，那么该谁发起对商家BC和商品BC的调用？</font>



<font style="color:rgb(85, 85, 85);">首先，我们在订单BC中定义自己的模型，该模型除了Order之外，还包含了商家与商品的信息，但这些信息是Read Model，是不需要在订单BC中持久化的。这就遵循了“</font>**BC是控制领域概念一致性的边界**<font style="color:rgb(85, 85, 85);">”这一原则。由于商家与商品在订单BC中并没有持久化的需求，因此当修改发生时，并不会因此而产生数据的不一致，更不会产生领域模型的耦合。这些领域模型都各自被定义在自己的BC中，没有重用。</font>



<font style="color:rgb(85, 85, 85);">其次，该谁来发起商家和商品BC的调用呢？通过第一张图与第二张图的讨论，我们需要在订单BC中定义商家BC和商品BC对应服务的接口（即前面提到的Client的接口），然后在领域层的相关对象（通常是领域服务），发起对这些接口的调用。框架会通过IoC框架注入Client实现，以满足对外部服务的调用。调用后，会在订单BC将返回的结果转换为自己BC的模型对象。如果需要组装最后的DTO，则可以在领域服务之上再包装一个应用服务，完成整个完整用例的逻辑。这样，就可以让Controller只调用应用服务，减少Controller对领域层的理解，从而遵循“最小知识”法则。</font>



<font style="color:rgb(85, 85, 85);">基于这样的设计思想，DDD的代码模型就可以定义为：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254509028-0405f82b-9e49-4b75-8a06-ca525401a1cc.png)



<font style="color:rgb(85, 85, 85);">以下是对代码结构的说明：</font>

+ <font style="color:rgb(85, 85, 85);">application：对应了领域驱动设计的应用层，主要内容为该限界上下文中所有的应用服务。</font>
+ <font style="color:rgb(85, 85, 85);">interfaces：对gateways中除persistence之外的抽象，包括访问除数据库之外其他外部资源的抽象接口，以及对第三方服务或其他限界上下文服务的抽象接口。从分层架构的角度讲，interfaces应该属于应用层，但在实践时，往往会遭遇领域层需要访问这些抽象接口的情形，单独分离出interfaces，非常有必要。</font>
+ <font style="color:rgb(85, 85, 85);">domain：对应了领域驱动设计的领域层，但是我将repositories单独分了出来，目的是为了更好地体现它在基础设施层扮演的与外部资源打交道的网关语义。</font>
+ <font style="color:rgb(85, 85, 85);">repositories：代表了领域驱动设计中战术设计阶段的资源库，皆为抽象类型。如果该限界上下文的资源库并不复杂，可以将repositories合并到domain中。</font>
+ <font style="color:rgb(85, 85, 85);">gateways：对应了领域驱动设计的基础设施层，命名为gateways，则是为了更好地体现网关的语义，其下可以视外部资源的集成需求划分不同的包。其中，controllers相对特殊，它属于对客户端提供接口的北向网关，等同于上下文映射中“</font>**开放主机服务（OHS）**<font style="color:rgb(85, 85, 85);">”的概念。如果为了凸显它的重要性，可以将controllers提升到与application、domain、gateways同等层次。我之所以将其放在gateways之下，还是想体现它的网关本质。persistence对应了repositories抽象，至于其余网关，对应的则是application/interfaces下的抽象，包括消息队列以及与其他限界上下文交互的客户端，例如通过http通信的客户端。其中，client包下的实现类与interfaces下的对应接口组合起来，等同于上下文映射中“</font>**防腐层（ACL）**<font style="color:rgb(85, 85, 85);">”的概念。</font>



<font style="color:rgb(85, 85, 85);">归根结底，在运用DDD进行架构设计，并通过BC映射到微服务设计时，要遵循两方面的设计原则。一个是</font>**普适性的架构与设计原则**<font style="color:rgb(85, 85, 85);">，例如整洁架构、分而治之思想、关注点分离、最小知识法则等。理解了这些原则，你就清楚该如何分配职责，如何解耦。另一个是DDD的设计原则，搞清楚每个层的职责，层之间的关系，BC之间的关系，领域模型是什么？在明白了这些设计原则的真谛时，当我们碰到DDD设计落地的问题时，不知道该如何处理时，都可以基于这些设计原则来做出符合当前场景的决策，而不要做个“寻章摘句老雕虫”，照搬书上的方法，只要书上未曾涉及到此问题，就无从应对了。</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">2018年9月6日</font>

# <font style="color:rgb(85, 85, 85);">限界上下文的边界</font>
**边界通过限界上下文来确定，这在领域驱动设计中具有非凡的意义。**<font style="color:rgb(85, 85, 85);">对应于通用语言，限界上下文是语言的边界，对于领域模型，限界上下文是模型的边界，二者对应于问题空间（Problem Space）的界定。对于系统的架构，限界上下文还确定了应用边界和技术边界，进而帮助我们确定整个系统及各个限界上下文的解决方案。可以说，限界上下文是连接问题空间与解决方案空间的重要桥梁。</font>



<font style="color:rgb(85, 85, 85);">那么，限界上下文所界定的边界，究竟是逻辑边界，还是物理边界？这并没有定论，需得依据不同场景而做出不同的决策。</font>

## <font style="color:rgb(85, 85, 85);">逻辑边界</font>


<font style="color:rgb(85, 85, 85);">根据业务对领域进行逻辑分解时，分与合是两个矛盾而又统一的概念。合是目标，分是降低复杂度的一种手段。分实则是为了更好的合。通过业务分解，每个分解出来的限界上下文规模就变得更小，因而更容易理解和把控。由于这种分解是从业务相关性来考虑的，使得领域可以更加细分，业务分析师或者领域专家就可以只要求掌握更加细分的专精领域。</font>



<font style="color:rgb(85, 85, 85);">从系统的代码模型（Code Model）看，所谓</font>**逻辑边界**<font style="color:rgb(85, 85, 85);">有两种表现形式。以Java为例，归纳如下：</font>

+ <font style="color:rgb(85, 85, 85);"> 命名空间级别：逻辑边界仅仅通过命名空间进行界定，但是所有的限界上下文其实都处于同一个模块中，编译后都属于同一个Jar包。 </font>
+ <font style="color:rgb(85, 85, 85);"> 模块级别：在命名空间上是逻辑分离的，而不同限界上下文则属于同一个项目的不同模块，编译后会生成各自的Jar包。若限界上下文之间存在依赖，则在运行时，这些Jar会被同时加载到同一个Java虚拟机中。这里所谓的“模块”，在Java代码中也可以创建为Jigsaw的module。 </font>



<font style="color:rgb(85, 85, 85);">将限定上下文的边界视为逻辑边界是最常见也是最简单的一种形式。一方面逻辑的分离可以保证系统代码的清晰结构，另一方面它也使得限界上下文之间的协作变得更加容易，更加高效。在物理上，限界上下文彼此之间的通信其实是无缝集成的，要重用的领域模型都可以直接访问，并对模型类进行实例化。如下是国际报税系统的逻辑边界（Java）：</font>

![](https://cdn.nlark.com/yuque/0/2024/jpeg/859018/1704161999864-fb03c4da-756f-4465-b9dd-dbad45435279.jpeg)



<font style="color:rgb(85, 85, 85);">然而，正所谓</font>**越容易重用，就越容易产生耦合**<font style="color:rgb(85, 85, 85);">。编写代码时，我们需要谨守这条无形的逻辑边界，时刻注意不要逾界，并确定限界上下文各自对外公开的接口，避免对具体的实现产生依赖。</font>



**采用逻辑边界划分限界上下文的系统架构是单块（Monolithic）架构**<font style="color:rgb(85, 85, 85);">，所有的限界上下文都部署在同一个进程中，因此不能针对某一个限界上下文进行水平伸缩。需要对限界上下文的实现进行替换或升级时，会影响到整个系统。即使我们守住了逻辑边界，这种耦合仍然存在，导致各个限界上下文的开发互相影响，团队之间的协调成本也随之而增加。</font>

## <font style="color:rgb(85, 85, 85);">物理边界</font>


<font style="color:rgb(85, 85, 85);">逻辑边界的坏，正是物理边界的好；反过来，物理边界的坏，同样是逻辑边界的好。</font>**当我们将限界上下文的边界定义为物理边界时，每个限界上下文就变成了一个个细粒度的微服务。**



<font style="color:rgb(85, 85, 85);">这里，我们需要针对Eric Evans提出的“限界上下文”概念做进一步澄清：</font>**限界上下文究竟是仅仅针对领域模型的边界划分，还是对整个架构（包括基础设施层以及需要使用的外部资源）垂直方向的划分？**<font style="color:rgb(85, 85, 85);">正如前面对Eric Evans观点的引用，他在《领域驱动设计》一书中明确地指出：“根据团队的组织、软件系统的各个部分的用法以及物理表现（代码和数据库模式等）来设置模型的边界。”显然，限界上下文不仅仅作用于领域层和应用层。</font>**它是架构设计而非仅仅是领域设计的关键因素。**



<font style="color:rgb(85, 85, 85);">倘若我们将限界上下文的边界视为物理边界，则可以保证边界内的服务、基础设施乃至于存储资源、中间件等其他外部资源的完整性，最终形成自治的服务。限界上下文之间仅仅通过限定的方式以限定的通信协议和数据格式进行通信，除此之外，彼此没有任何共享，这种架构被称之为</font>**零共享架构**<font style="color:rgb(85, 85, 85);">。这种架构的表现形式为：每个限界上下文都有自己的代码库、数据存储以及开发团队，每个限界上下文选择的技术栈和语言平台也可以不同。当每个限界上下文都被物理隔离时，一个限界上下文的开发人员就不能调用另一个限界上下文的方法，或者将数据存储在共享结构中了，这可以避免因为共享带来的耦合。下图为危机分析系统的架构：</font>

![](https://cdn.nlark.com/yuque/0/2024/jpeg/859018/1704161999949-11a791b8-fb8c-4e90-b4c7-e832d0152c36.jpeg)



<font style="color:rgb(85, 85, 85);">物理分隔开的限界上下文变得小而专，使得我们可以很好地安排遵循2PTs规则的小团队去治理它。然而，这种架构的复杂度也不可低估。限界上下文之间的通信是跨进程的，我们需要考虑通信的健壮性。数据库是完全分离的，当需要关联之间的数据时，需得跨限界上下文去访问，无法享受数据库自身提供的关联福利。由于每个限界上下文都是分布式的，如何保证数据的一致性也是一件棘手的问题。当整个系统都被分解成一个个可以独立部署的限界上下文时，运维与监控的复杂度也随之而剧增。</font>

## <font style="color:rgb(85, 85, 85);">数据库共享</font>


<font style="color:rgb(85, 85, 85);">在逻辑边界和物理边界中间，还存在一种折中的手段。在考虑限界上下文划分时，分开考虑代码模型与数据库模型，就可能出现在代码上分离，而在数据库层面却存在数据共享的形式，即多个限界上下文共享同一个数据库。</font>



<font style="color:rgb(85, 85, 85);">因为没有分库，在数据库层面就可以更好地保证事务的ACID。这或许是该方案最有说服力的证据，但也可以视为是对“一致性”约束的妥协。</font>



<font style="color:rgb(85, 85, 85);">数据库共享的问题在于数据库的变化方向与业务的变化方向会不一致。这种不一致性体现在两个方面：</font>

+ <font style="color:rgb(85, 85, 85);"> 耦合：虽然业务上限界上下文之间是解耦的，但是在数据库层面依然存在强耦合关系 </font>
+ <font style="color:rgb(85, 85, 85);"> 水平伸缩：部署在应用服务器的应用服务可以根据限界上下文的边界单独进行水平伸缩，但是在数据库层面却无法做到 </font>



<font style="color:rgb(85, 85, 85);">根据Netflix团队提出的微服务架构最佳实践，其中一个最重要特征就是“</font>**每个微服务的数据单独存储**<font style="color:rgb(85, 85, 85);">”。但是服务的分离并不绝对代表数据应该分离。数据库的样式（Schema）与领域模型未必存在一对一的映射关系。在对数据进行分库设计时，如果仅仅站在业务边界的角度去思考，可能会因为分库的粒度太小，导致不必要的跨库关联。因此，我们可以将“数据库共享”模式视为一种过渡方案，不要在一开始设计微服务的时候，就直接将数据彻底分开，而是采用演进式的设计。</font>



<font style="color:rgb(85, 85, 85);">为了便于在演进设计中将分表重构为分库，从一开始要</font>**注意避免在两个表之间建立外键约束关系**<font style="color:rgb(85, 85, 85);">。某些关系型数据库可能通过这种约束关系提供级联更新与删除的功能，这种功能反过来会影响代码的实现。一旦因为分库而去掉表之间的外键约束关系，需要修改的代码太多，会导致演进的成本太高，甚至可能因为某种疏漏带来隐藏的Bug。</font>



<font style="color:rgb(85, 85, 85);">没有外键约束关系可能在当前增加了开发成本，却为未来的演进打开了方便之门。例如，在针对某手机品牌开发的舆情分析系统中，危机查询服务提供对识别出来的危机的查询，需要通过userId获得危机处理人、危机汇报人的详细信息。左图为演进前直接通过数据库查询的方式，右图则切断了这种数据库耦合，改为服务调用的方式：</font>

![](https://cdn.nlark.com/yuque/0/2024/jpeg/859018/1704161999969-9a00280d-beb7-44fc-b205-cd2d2c80e63b.jpeg)



<font style="color:rgb(85, 85, 85);">倘若架构被设计为数据库共享，且两个服务需要操作同一张数据表（这张表被称之为“共享表”），则传递了一个信号，即我们的设计可能出现了错误：</font>

+ <font style="color:rgb(85, 85, 85);"> 遗漏了一个限界上下文，共享表对应的是一个被重用的服务：买家在查询商品时，商品服务会查询价格表中的当前价格，而在提交订单时，订单服务也会查询价格表中的价格，计算当前的订单总额；共享价格数据的原因是我们遗漏了价格上下文，通过引入价格服务就可以解除这种不必要的数据共享。 </font>
+ <font style="color:rgb(85, 85, 85);"> 职责分配出现了问题，操作共享表的职责应该分配给已有的服务：舆情服务与危机服务都需要从邮件模板表中获取模板数据，然后再调用邮件服务组合模板的内容发送邮件；实际上从邮件模板表获取模板数据的职责应该分配给已有的邮件服务。 </font>
+ <font style="color:rgb(85, 85, 85);"> 共享表对应两个限界上下文的不同概念：仓储上下文与订单上下文都需要访问共享的产品表，但实际上这两个上下文需要的产品信息是完全不同的，应该按照限界上下文的边界分开为产品建表。 </font>



<font style="color:rgb(85, 85, 85);">为什么会出现这三种错误的设计？</font>**根本原因还是在于我们没有通过业务建模，而是在数据库中隐式地进行建模**<font style="color:rgb(85, 85, 85);">，因而在代码中没有体现正确的领域模型，从而导致了数据库层面的耦合或共享。</font>

<font style="color:rgb(85, 85, 85);"></font>

<font style="color:rgb(85, 85, 85);">2017年12月4日</font>

# <font style="color:rgb(85, 85, 85);">可视化与领域驱动设计</font>
<font style="color:rgb(85, 85, 85);">从DDD的角度，领域逻辑的分析可以运用战略方法Bounded Context。可是，一个问题是：</font>**如何获得Bounded Context ？**



<font style="color:rgb(85, 85, 85);">我查看了许多关于Bounded Context的书籍与文章，虽然都着重强调了它的重要性，也给出了一些实例，却对如何从需求——>Boundex Context这一点上语焉不详。</font>

## <font style="color:rgb(85, 85, 85);">一个初步设想</font>


<font style="color:rgb(85, 85, 85);">我的初步设想是通过绘制场景图（但并不成熟）。我认为有三种绘制场景图的方式：商业画布，体验地图和流程图。我认为，商业画布可以作为需求分析（尤其针对初创产品）的起点。商业画布如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/webp/859018/1704162032474-8f9bff64-b568-40ca-a099-778b54d0a52c.webp)



<font style="color:rgb(85, 85, 85);">采用这种规范化的方式来推导商业模型，可以激发我们的灵感，理清我们的思路，以便我们思考为何要做这个产品，产品应该具备哪些功能。结合优点和缺点、成本等因素，我们可以藉此判断和决策功能的优先级，从而得到MVP。这个过程需要大量运用即时贴，让整个商业模型呈现。经过取舍后，就可以针对产品绘制场景图。此时，场景图可以采用Experience Map或流程图来体现。Experience Map的例子如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/webp/859018/1704162032685-1297ba09-435b-4a7b-b40f-30a7f152e22a.webp)



<font style="color:rgb(85, 85, 85);">由于商业画布本身提供了“客户”项，我们应该创建Persona，找准人物角色的特征来“搜寻”需求。绘制了场景图后，就能够确定用例了，此时，可辅以ATDD帮助确定Story。在确定了用例后，可以识别Bounded Context，并通过Context Map确定上下文之间的关系。</font>



<font style="color:rgb(85, 85, 85);">就我个人感觉，体验地图还是从Persona的角度设想系统如何使用，考虑它的用户体验。它其实符合“场景”的概念。这里可能还是要考虑：在一个完整的场景中，需要哪些参与者？但是，即使从粗粒度的角度出发，场景都可能存在多个，可能需要绘制多个场景图来逐步提炼Bounded Context。</font>



<font style="color:rgb(85, 85, 85);">关于如何运用Persona，熊子川在他的博客《</font>[<font style="color:rgb(85, 85, 85);">XD关键字5：Persona</font>](https://link.jianshu.com/?t=http://www.tuzei8.com/2011/06/xd%E5%85%B3%E9%94%AE%E5%AD%975-persona/)<font style="color:rgb(85, 85, 85);">》中已有详细介绍，同样在他的博客《</font>[<font style="color:rgb(85, 85, 85);">Agile UX内容策略工作坊</font>](https://link.jianshu.com/?t=http://www.tuzei8.com/2012/06/agile-ux-content-strategy/)<font style="color:rgb(85, 85, 85);">》中提出的“消费者建模”实践，指出：</font>

> <font style="color:rgb(85, 85, 85);">为了更好的理解我们选择的目标消费者，我们需要对消费者进行完整的建模，即Persona。越接近于真实的Persona帮助我们更好的理解其用户目标……Persona的重要产出物是一系列用户目标，对于同一个Persona，用户目标可能有不同，有些目标是基础核心目标，有些则是衍生性的，例如一个访问网站潜在投资者的核心目标可能是了解成为投资者的过程，而衍生性目标可能是获得一些关于公司历史信息增加信任度。</font>
>



![](https://cdn.nlark.com/yuque/0/2024/webp/859018/1704162032550-3318cd96-977e-4670-bdbe-3d01f2d32f99.webp)

## <font style="color:rgb(85, 85, 85);">获得Context并划分领域</font>


<font style="color:rgb(85, 85, 85);">假设我们要开发一个电子商务网站，我们就可以通过商业画布来驱动出这个产品应该具有哪些功能，它的客户有哪些等，在绘制了场景图后，可以初步得到这样的Bounded Context:</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704361952528-66dc6f6b-15b5-4a14-a533-792bb548d34f.png)



<font style="color:rgb(85, 85, 85);">然后，我利用Context Map得到了各个上下文之间的关系：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704361967261-72d6ea38-bdd7-451c-a47e-b9235e7420e0.png)

<font style="color:rgb(85, 85, 85);">这样，一个包图的获得就水到渠成了：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704361982569-77f94efd-f78c-4649-b2a7-150c5f88fbba.png)

## <font style="color:rgb(85, 85, 85);">六边形架构</font>


<font style="color:rgb(85, 85, 85);">在识别了Bounded Context以及Context之间的关系后，我们可以运用Hexagon架构（Cockburn提出的六边形架构）来展现系统的整体架构。Hexagon架构并不深入关注内部边界中领域部分，仅仅是简单的划分为Application与Domain两层。但它有助于我们获得基础设施层以及相关集成点的包结构。我们要合理地运用六边形架构。它更贴近应用逻辑架构，并可以驱动我们去发现诸多集成点，寻找集成模式。内外边界的分离也有助于我们将业务逻辑与应用逻辑分离开。这实际上符合“关注点分离”的架构原则。下图为Cockburn提出的六边形架构：</font>

![](https://cdn.nlark.com/yuque/0/2024/webp/859018/1704162033460-d6e15429-a2bd-44f0-a230-7f66a9bd6e0a.webp)

六边形架构更贴近应用逻辑架构，并可以驱动我们去发现诸多集成点，寻找集成模式。内外边界的分离也有助于我们将业务逻辑与应用逻辑分离开。这实际上符合“关注点分离”的架构原则。下图展现了六边形架构中常见的Port与Adapter：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704361904544-27220bae-5fb4-4286-9662-32395d66df4a.png)

<font style="color:rgb(85, 85, 85);">所谓“可视化架构”，是一种利用多种交流方式实现架构知识共享的方法，因而需要团队成员均参与进来，并以Workshop的形式，更多通过即时贴、白板等工具实现可视化，而非通过绘图。至少，绘图不应该成为主要的驱动力，否则，开发人员很难接受。例如，下图就是我运用Hexagon架构，并结合可视化手段分析该电子商务系统得到的应用逻辑架构，它很好地一个展现了Hexagon架构的可视化手法。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704361814328-3c919455-a67b-46e5-aad5-3532b59ad854.png)



<font style="color:rgb(85, 85, 85);">在这个图中，直观地展现了如何与外部的支付系统以及物流系统的集成。例如，图中展现的Port实际上为防腐层（ACL）。为何要建立这样的一个防腐层呢，原因在于：支付与物流常常存在多个供应商，因而需要解除对供应商的绑定，并避免供应商系统的变化造成对电子商务系统的腐蚀。这是切合实际的决策。</font>

## <font style="color:rgb(85, 85, 85);">实例：仓库管理流程控制系统</font>


<font style="color:rgb(85, 85, 85);">这个电子商务系统需要与仓库管理系统集成。恰好在《</font>[<font style="color:rgb(85, 85, 85);">面向模式的软件架构</font>](https://link.jianshu.com/?t=https://book.douban.com/subject/4848563/)<font style="color:rgb(85, 85, 85);">》卷四的第35页，给出了一个仓库管理流程控制系统的案例。书中描述的非功能性需求，即所谓质量属性包括：</font>

+ <font style="color:rgb(85, 85, 85);">分布性。仓库管理流程控制系统天生就是分布式的。</font>
+ <font style="color:rgb(85, 85, 85);">性能。仓库管理流程控制系统不是一个“绝对的”实时系统，但性能仍与业务息息相关。对系统有整体的吞吐量要求，因此系统必须确保所有的运输指令能够被及时而有效地运行。</font>
+ <font style="color:rgb(85, 85, 85);">可伸缩性。不同仓库其大小可能会有很大的不同，因此仓库管理流程控制系统必须能既支持只有几千个箱子的小仓库，又要支持超过一百万个箱子的大仓库。</font>
+ <font style="color:rgb(85, 85, 85);">可用性。许多仓库操作采用三班倒的24/7模式工作，因此可用性是仓库管理流程控制系统对业务案例支持的关键因素。</font>



<font style="color:rgb(85, 85, 85);">假设要设计这样的系统以支持这些质量属性。对于分布式而言，书中提出的解决方案是传统的分布式系统解决方案，即引入Broker模式，在本地建立对远程对象的代理。而对于支持并发的领域对象访问而言，则采用了Active Object模式，并引入Leader/Followers并发模型来获得可扩展。</font>



<font style="color:rgb(85, 85, 85);">我没有打算引入这么复杂的模式，而是通过引入消息队列，并为消息队列引入路由的方式，来实现系统的分布式。这其中当然会用到经典的Publisher-Subscriber模式。我对领域逻辑进行了识别，将整个仓库管理流程控制系统的领域逻辑分为三个Bounded Context。</font>

+ <font style="color:rgb(85, 85, 85);">库存管理</font>
+ <font style="color:rgb(85, 85, 85);">物流控制</font>
+ <font style="color:rgb(85, 85, 85);">拓扑管理</font>



<font style="color:rgb(85, 85, 85);">整个架构如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1705389706151-5b3550aa-99d2-42a1-95e6-13126f9b69f9.png)



<font style="color:rgb(85, 85, 85);">对于库存管理而言，我认为它主要支持商品存放信息的数据管理，即获得商品数量、存放位置以及更新这些信息。对于该上下文而言，操作本身比较简单，且耗时较短。若出现大规模并发，其瓶颈也不在于获取或更新仓库信息（当然需要通过测试数据验证），而在于客户下订单后向仓库管理流程控制系统发起的发货请求。</font>



<font style="color:rgb(85, 85, 85);">我将发货请求放到了物流控制上下文中，除此之外，它还包括收货以及订单管理等。同时，对于物流控制与拓扑管理功能，基本上与具体的仓库形成了一一对应关系。此外，对于发货请求（或收货请求），并不要求很强的实时性，这使得对这些请求的异步处理成为可能。</font>



<font style="color:rgb(85, 85, 85);">物流控制由于牵涉到收货和运货，需要控制仓库的相关设备，并按照仓库的拓扑结构设定设备的路由。这说明物流控制与拓扑控制存在上下游关系，拓扑控制是上游。这两个上下文可以是Customer-Provider的关系。但它们之间不应该存在物理边界。因此，我将这两个上下文放到了同一个六边形中，而将库存管理放到了另一个单独的六边形中，以便于它们各自独立的可伸缩。</font>



<font style="color:rgb(85, 85, 85);">在库存管理与物流控制六边形之间，我引入消息队列来应对从库存管理子系统中转发而来的发货请求（发货请求实则又来自于E-Commerce的订单请求）。原则上，我针对一个物理的仓库建立一个单独的消息队列，因此库存管理在发送发货请求时，会根据商品的存放位置以及用户请求的IP地址，获得最优的仓库信息，然后通过Router将消息转发到正确的消息队列中。</font>



<font style="color:rgb(85, 85, 85);">一旦收到消息，物流控制系统作为消息队列的订阅者（或侦听器）就可以及时处理信息，进行后续的处理。</font>



<font style="color:rgb(85, 85, 85);">针对库存管理而言，我认为它是一个独立的物理边界，因此在可视化手段中，我展现为一个单独的库存管理六边形，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1705389756369-e022b085-4730-41ef-8e29-2011d214cb65.png)



<font style="color:rgb(85, 85, 85);">在这个BC中，利用六边形架构，我分别建立了如下端口：</font>

+ <font style="color:rgb(85, 85, 85);">建立了针对REST服务的端口，对应的适配器为Controller，其目的是支持E-Commerce系统。事实上，我们对E-Commerce系统进行过分析，获得的六边形架构正好与此对接。</font>
+ <font style="color:rgb(85, 85, 85);">建立了针对DB的端口，对应的适配器为DB Gateway，它负责访问库存管理自身的数据库。数据库持久化的消息包括商品的基本信息如SKU、商品名、数量等，以及商品存放的仓库名。</font>
+ <font style="color:rgb(85, 85, 85);">建立了针对Queue的端口，对应的适配器为Message Router，负责将发货请求消息路由到正确的消息队列。</font>



<font style="color:rgb(85, 85, 85);">物流控制与拓扑管理放在同一个边界中，它是高度可伸缩的独立系统，为展现它的可伸缩性以及它与库存管理之间的集成，我在可视化手段中，展现出两个独立的六边形，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1705389814045-b4de1adf-8fe6-4d16-a29d-15691e9dbd87.png)



<font style="color:rgb(85, 85, 85);">我为物流控制与拓扑管理的BC建立了如下端口：</font>

+ <font style="color:rgb(85, 85, 85);">针对Queue的侦听器端口，对应的适配器为Message Handler。若有必要，例如为了更好地支持并发，也可以在此引入Active Object甚至Leader/Followers。</font>
+ <font style="color:rgb(85, 85, 85);">提供了针对REST的端口，对应适配器为Controller。它主要是为了支持移动终端设备、Web应用，以便于相关人员直接发出发货或收货请求。</font>
+ <font style="color:rgb(85, 85, 85);">提供了DB的端口。这个数据库是对应仓库的专有数据库，与库存管理数据库无关。</font>
+ <font style="color:rgb(85, 85, 85);">提供了针对设备（指仓库的设备，如叉车，箱子，运输车等）的端口，对应适配器为South Gateway。</font>
+ <font style="color:rgb(85, 85, 85);">提供了针对配置文件的端口，对应适配器为Configurer。此功能是为了支持拓扑信息的动态配置。</font>
+ <font style="color:rgb(85, 85, 85);">提供了针对外部物流系统的端口，这里为其建立了Shipping的防腐层，使其能够更好地支持各个不同的物流供应商。</font>



<font style="color:rgb(85, 85, 85);">目前，我针对可视化架构与设计的手段仍在完善之中，并已经尝试在真实项目中实践以进行验证，并希望能够找到足够简单的方法，为架构师与开发者提供直观而又具有体验价值的沟通方式，并能形成行之有效的设计手段。</font>

# <font style="color:rgb(85, 85, 85);">领域驱动战略设计工作坊</font>
![](http://zhangyi.xyz/ddd-strategic-design-workshop/01.jpg)



在2018年第二届领域驱动设计中国峰会，我作为讲师做了一个领域驱动战略设计工作坊——再现具有实操价值的架构方案。在这个工作坊中，我将敏捷实践中的Inception与领域驱动战略设计结合起来，并引入Event Storming和用例场景分析等方法，带着大家一起糊了墙，玩风暴，算是满意地完成了战略设计的预期目标。在这次工作坊的参与者中，我欣喜地看到了业务同学的加入。这些业务同学敏锐的分析目光与业务感给我们的用例场景分析带来了极好的助力，也为整个工作坊增加了不少亮点。



我把整个工作坊分为了十个步骤，依次为：

+ 确定利益相关人
+ 确定业务期望和愿景
+ 对问题域的共同理解
+ 确定项目的业务范围
+ 确定业务流程
+ 史诗级故事和主故事
+ 运用用例分析场景
+ 通过边界识别限界上下文
+ 上下文映射
+ 领域架构



我选择一些重要步骤对整个工作坊做一个简单的回顾。

## 对问题域的共同理解


我认为：“对问题域（Problem Domain）的识别其实就是对客户痛点的识别。之所以要开发这个软件，目的就是解决这些痛点，为应对这些问题提供具有业务价值的功能。在识别痛点的过程中，需要始终从业务期望与愿景出发，与不同的利益相关人进行交流，如此才能达成对问题域的共同理解。”在工作坊中，一位业务人员补充了我对问题域定义的不足，她认为问题域不仅是对**痛点**的识别，还包括系统所要提供的**价值**。



ThoughtWorks的禚娴静则以淘宝和京东的例子提出了她对问题域的看法，她认为，虽然这两家都是电商系统，但二者的核心价值并不相同。淘宝的核心价值是为买家提供物美价廉的商品，京东的核心价值则是提供快速便捷的物流。对于京东而言，物流问题域会作为一个核心领域而存在。



通过分析系统的业务期望和愿景，有团队针对问题域做出了颇具价值的抽象，如下图所示，他们提炼出“需、控、供、决策”这四个核心问题域：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254613641-787c95a0-cdf5-4516-ba27-b5b2f1b7cd75.png)



另一个团队则从价值和服务两个维度对整个系统的问题域进行了清晰的划分：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254632941-213909e2-2414-4512-90e1-4b782f9f9cec.png)



现场探讨了问题域与解决方案域之间的区别，进而也谈到了核心域、子域与限界上下文之间的关系。我的观点可以用这样一幅图来表达：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254648499-3c01eb69-6c59-4741-a77b-9b27aae66986.png)

## 确定项目的业务范围


之所以要确定项目的业务范围，是为了明确整个系统的边界。明确系统边界是架构设计的重要前提，它一方面可以明确职责划分，了解哪些内容才属于领域驱动设计的范畴；另一方面则可以事先明确当前系统需要与哪些外部系统集成。



我引入了Simon C4模型中的System Context来确定系统的边界：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254657568-28af383b-a91b-4176-8d6c-7ee825d25d41.png)



在这个过程中，我们要将自己设计的系统视为一个黑盒子，假设它已经实现，再来考虑它需要与哪些角色以及外部系统、外部资源进行协作。System Context除了可以帮助我们确定系统的边界之外，还有利于推动我们开展build vs buy的决策。如果是购买第三方软件系统或服务，则该系统或服务就将作为本系统协作的外部系统。

## 运用用例分析场景


一个主用例可以认为是一个具有业务价值的业务功能。我提出的用例场景分析步骤为：

+ 确定业务流程，通过业务流程识别参与者（Actor）；
+ 根据每个参与者识别属于该参与者的用例，遵循一个参与者一张用例图的原则，保证用例图的直观与清晰；
+ 对识别出来的用例根据语义相关性和功能相关性进行分类，确定用例的主题边界，并对每个主题进行命名。



首先，我让学员通过识别系统的参与者驱动用例的识别。一个参与者一个用例图，可以让我们的用例分析既有清晰的分析起点，又能保证用例图的清晰直观：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254673526-45c00e5f-c3b4-4ef7-bb5e-50e160a6567d.png)



运用用例进行场景分析时，不必死板地抱着UML的规则行事，但用例图的根本价值仍然值得重视。例如参与者与用例的use关系体现了用例的价值（Why），用例的描述应采用简洁明了的动宾短语，识别用例之间的包含与扩展关系等。在工作坊演练过程中，我让学员使用不同颜色的即时贴来表达用例，例如黄色代表Actor，蓝色代表主用例，绿色代表扩展或包含用例。这样就有助于整个团队在进行场景分析时的沟通与协作，俗称“糊墙”：

![](http://zhangyi.xyz/ddd-strategic-design-workshop/07.jpg)



当然，你也可以放在桌面上进行：

![](http://zhangyi.xyz/ddd-strategic-design-workshop/08.jpg)



一旦准确地识别出用例，再根据语义相关性和功能相关性对这些用例进行分组，最后，确定主题边界（Subject Boundary）就变得相对容易了。以下是其中四个团队分别给出的主题边界分组：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254696800-ac723ddf-3826-498d-ba68-71164ec16cef.png)

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254705966-8fb89b68-a0e8-45c9-8361-6af1189e3d96.png)

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254711071-42efeeb5-51bc-4569-a626-8d805a21c1fd.png)

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254717481-c702957f-1978-4cd4-826b-bfbe39f38139.png)



这些识别出来的主题边界其实就是限界上下文的候选了。可以看到，不同团队因为需求理解的不同，识别出来的主题边界确实存在差别，但这个差别是非常细微的，基本能就限界上下文的边界达成一致。这些识别出来的用例同时也将作为统一语言的一部分，在后续的领域建模和战术设计中提供非常有价值的指导。

## 领域架构


在架构层面，我引入了RUP的4+1视图，这样可以使得领域驱动战略设计的成果显得更加系统化，能够为业务人员、开发人员、运维人员提供不同视角的架构指导。例如获得的逻辑视图可以非常清晰地表达系统层面与限界上下文层面各自的逻辑组成：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254739465-7586dd70-9a79-4cfb-8abe-7abef77818b0.png)



进程视图则使用时序图针对那些需要异步处理或分布式通信的用例进行了清晰刻画：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254749485-35243efb-1202-486d-be32-47719c0e4d60.png)



至于开发视图则为后续的领域驱动战术设计提供了重要的指导，明确了每个模块（包）的职责以及它们在逻辑架构中所处的位置：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1709254760649-2cc6da3b-1ab8-4627-96e2-73a033550b72.png)



针对这样的战略设计工作坊，我们既要有高屋建瓴的系统理论，又需要让这些理论和方法能够落地，成为具有实操价值的一种工作坊形式。我充分借鉴了事件风暴这种新方法，却又未完全抛弃UML这种老方法，采用各取所长的手段将二者结合起来，形成一种行之有效的设计手法，有助于大家清晰地认识问题域，并通过场景分析寻找解决方案域中最重要的限界上下文。这一方法同样可以帮助我们进行微服务设计，毕竟，从某种角度讲，一个限界上下文就可以等于是一个微服务。



特别强调的是，在整个工作坊设计过程中，我们需要抛开技术因素对我们的干扰，只能由业务来驱动我们的设计。这就需要团队充分地与领域专家或需求分析人员进行沟通和交流。只有在最后确定限界上下文的粒度与边界，以及探讨限界上下文之间的协作时，我们才能揭开技术的面纱，从技术复杂度的角度去进一步地分析，直到得到就目前而言恰如其分的领域架构。



2018年12月20日

# <font style="color:rgba(0, 0, 0, 0.9);">我对领域模型的理解</font>
<font style="color:rgba(0, 0, 0, 0.9);">我始终认为，Eric Evans的领域驱动设计是对软件设计领域的一次重新审视，是在面向对象语言大行其道时对数据建模的“拔乱反正”。Eric强调了模型的重要性，例如他在书中总结了模型在领域驱动设计中的作用包括：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">模型和设计的核心互相影响</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">模型是团队所有成员使用的统一语言的中枢</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">模型是浓缩的知识  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">显然，模型在领域驱动设计中是设计的起点和关键。但是，该如何才能得到我们心目中能够准确表达业务需求的模型呢？我们需要认识到模型和领域模型是两个不同层次的概念。如前所述，模型还可以是数据模型或服务模型，这取决于我们观察现实世界业务需求的视角。因此，</font>**<font style="color:rgba(0, 0, 0, 0.9);">领域模型是以“领域”为关注核心的模型，是对领域知识严格的组织且有选择的抽象。</font>**<font style="color:rgba(0, 0, 0, 0.9);">  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">即便有了这个定义，却没有清晰地说明领域模型到底长什么样子。领域模型究竟是什么呢？是使用建模工具绘制出来的UML图？是通过编程语言实现的代码？或者干脆就是一个完整的书面设计文档？  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">我认为，UML图、代码与文档仅仅是表达领域模型的一种载体而已，如果绘制出来的UML图或者编写的代码与文档并没有传递领域知识，那就不是领域模型。因此，领域模型应该具备以下特征：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">运用了统一语言来表达领域中的概念</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">蕴含了业务活动和规则等领域知识</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">对领域知识进行了适度的提炼和抽象</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">它的建立是一个迭代的演进的过程</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">能够有助于业务人员与技术人员的交流</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">既然如此，不管领域模型的表现形式，只要它正确地传递了领域知识，并有助于业务人员与技术人员的交流，就可以说是领域模型。这是一个更不容易犯错误的定义。它其实体现的是一种原则。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">很可惜，这样高屋建瓴的原则并不能指导开发团队运用领域驱动设计。就好似软件设计有个核心原则是“高内聚低耦合”，然而知道这个原则并不能保证你设计出高内聚低耦合的方案。故而诸如这样打太极似的原则与模糊定义，并不能让开发团队满意，他们还是会执着地追问：领域模型到底是什么？</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">Eric并没有就此作出正面地解答，但是他在模型驱动设计中提到了模型与程序设计之间的关系：“</font><font style="color:rgb(64, 118, 0);">模型驱动设计不再将分析模型和程序设计分离开，而是寻求一种能够满足这两方面需求的单一模型。</font><font style="color:rgba(0, 0, 0, 0.9);">”这句话说明分析模型和程序设计应该一起被放入到同一个模型中。这个单一模型应该就是“领域模型”。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">他反复强调程序设计与程序实现应该忠实地反映领域模型。例如，他写道：“</font><font style="color:rgb(64, 118, 0);">软件系统各个部分的设计应该忠实地反映领域模型，以便体现出这二者之间的明确对应关系。</font><font style="color:rgba(0, 0, 0, 0.9);">”同时，他还要求：“</font><font style="color:rgb(64, 118, 0);">从模型中获取用于程序设计和基本职责分配的术语。让程序代码成为模型的表达。</font><font style="color:rgba(0, 0, 0, 0.9);">”  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">在我看来，设计对领域模型的反映，就是“</font>**<font style="color:rgba(0, 0, 0, 0.9);">设计模型</font>**<font style="color:rgba(0, 0, 0, 0.9);">”；代码对领域模型的表达，就是“</font>**<font style="color:rgba(0, 0, 0, 0.9);">实现模型</font>**<font style="color:rgba(0, 0, 0, 0.9);">”。分析模型、设计模型与实现模型在领域视角下，成为了领域模型中相互引用和参考的不可或缺的组成部分，它们分别代表了分析阶段、设计阶段与实现阶段进行建模的产物。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">模型驱动设计非常强调模型的一致性，Eric Evans甚至认为“将分析、建模、设计和编程工作过度分离会对模型驱动设计产生不良影响。”这正是我将分析、设计和实现都统一到模型驱动设计中的原因。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">我之所以清晰地将领域模型划分为这三个模型，主要是出于交流的目的。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">在分析阶段，开发团队与领域专家一起工作，通过建立更加准确而简洁的分析模型，直观地传递着不同角色对业务知识的理解。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">在设计阶段，必须基于分析模型对模型中的对象做出设计改进，考虑职责的合理分配与良好的协作，建立具有指导意义的设计模型。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">在实现阶段，代码必须是设计模型的忠实表现，意味着它其实也忠实表现了分析模型蕴含的领域知识。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">一言以蔽之，让分析模型服务于开发团队与领域专家，设计模型服务于软件设计人员，代码模型服务于程序员。这三个模型各司其职，各取所需。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">在建模过程中，我们需要不断地从“统一语言”中汲取建模的营养，并通过“统一语言”来维护模型的一致性。当开发团队根据分析模型建立设计模型时，如果发现分析模型中的概念未能准确表达领域知识，又或者缺少了隐式概念，就需要调整分析模型，使得设计模型与分析模型保持一致。实现模型亦当如此。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">显然，统一语言在领域模型驱动设计中，提供了一致的领域概念，使得模型在整个软件开发阶段保持了同步：   
</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703904368883-e89277f1-a465-4b43-941a-a982f13380ae.jpeg)<font style="color:rgba(0, 0, 0, 0.9);">  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">分析、设计与实现不是割裂开的三个阶段，而是一个迭代建模（Iteration Modeling）的过程。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">在战略设计阶段，我们可以通过业务场景识别系统的限界上下文。在限界上下文中的语义相关与功能相关的用例可以作为分析建模的重要输入。这个阶段可以在系统的先启活动中完成，之后就进入到战术设计阶段。  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">战术设计以限界上下文为单位开始迭代，通过迭代中的用户故事逐步对分析模型进行细化，并引入设计模式获得设计模型后，就可以利用诸如测试驱动开发等实践进行编码实现，以求快速交付高价值的可运行的功能。</font>

![](https://cdn.nlark.com/yuque/0/2023/jpeg/859018/1703904368949-a0f6df78-1b36-4db6-be67-5cbd51ca0be1.jpeg)

<font style="color:rgba(0, 0, 0, 0.9);"></font>

**<font style="color:#5C8D07;">说明：</font>**<font style="color:#5C8D07;">迭代建模与本图参考了Scott W. Ambler敏捷建模的思想，参见链接：http://agilemodeling.com/essays/iterationModeling.htm</font><font style="color:rgba(0, 0, 0, 0.9);">  
</font>

<font style="color:rgba(0, 0, 0, 0.9);">显然，这种迭代建模的方式是与迭代的增量开发是一脉相承的。它避免了在建模过程尤其是分析建模过程的分析瘫痪，也避免了在设计建模过程中的过度设计，同时还将通过增量快速地开发出新功能来及时获得反馈。获得的模型也随着增量开发而不断演化，并始终指导着设计与开发。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">迭代建模使得建模活动成为迭代开发中不可缺少的一个重要环节，但整个活动却是轻量的，有效地促进了团队成员的交流，符合Kent Beck提出的核心价值观：</font>**<font style="color:rgba(0, 0, 0, 0.9);">沟通、简单和灵活</font>**<font style="color:rgba(0, 0, 0, 0.9);">。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">2019年3月16日</font>

# <font style="color:rgba(0, 0, 0, 0.9);">领域驱动建模与面向对象建模的差异</font>
<font style="color:rgba(0, 0, 0, 0.9);">即便采用面向对象建模范式，领域驱动设计的建模仍与面向对象建模存在较大差异，原因在于领域驱动设计引入了</font>**限界上下文（Bounded Context）**<font style="color:rgba(0, 0, 0, 0.9);">与</font>**聚合（Aggregate）**<font style="color:rgba(0, 0, 0, 0.9);">，使得建模的风景变得迥然不同。二者为领域模型引入了边界的约束，使得建模者不能随心所欲地建模，亦改变了模型的面貌。</font>



<font style="color:rgba(0, 0, 0, 0.9);">在我的《解构领域驱动设计》一书中，提炼了领域驱动设计之精髓，在于对边界的控制。其中，限界上下文与聚合是解空间边界控制中最为重要的两个要素。我们构建的领域模型必然位于限界上下文中，构成领域模型中的主力军——实体和值对象——又必然位于聚合的边界内：</font>



![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162105563-b1b6b987-52b3-41f4-bf9e-5c5496f3868a.png)



<font style="color:rgba(0, 0, 0, 0.9);">虽然限界上下文只是逻辑边界，但它的</font>**自治**<font style="color:rgba(0, 0, 0, 0.9);">特性需要保证其内部领域模型的独立性，建模时，必须避免出现跨限界上下文之间领域模型的直接引用。至于聚合之间的协作，社区的大多数声音认为：聚合之间需通过根实体的ID建立协作关系。</font>



<font style="color:rgba(0, 0, 0, 0.9);">限界上下文与聚合边界的约束，使得我们需要重新正视领域模型类之间的关系，在面向对象世界中，设计者耳熟能详的继承、组合、依赖关系，可能需要做出改变。</font>



<font style="color:rgba(0, 0, 0, 0.9);">以教育领域之用户模型为例。学生、教师、家长是3种不同类型的用户，各自业务不同，又有一些共用业务，如：修改密码。从面向对象的角度思考模型的建立，自然会想到通过为它们建立继承关系，将用户定义为基类，封装共同的领域逻辑满足复用的要求。由此形成如下的领域模型：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162105556-947fd614-d1f4-40b5-b7db-bc22aba7b038.png)



<font style="color:rgba(0, 0, 0, 0.9);">我将限界上下文视为</font>**领域模型的知识语境**<font style="color:rgba(0, 0, 0, 0.9);">，通过它形成领域知识的逻辑边界。对相同的一个领域概念因为观察视角的不同，需要关注的领域知识（属性与行为）各有不同。犹如盲人摸象，在此，并非讽刺盲人只见大象之局部而错以为是整头大象，相反，代表了一种正面的含义，即从当前上下文观之，虽然明知此乃大象之局部，我仍然认为它就是大象之整体。</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162105560-6f66eaa7-c186-4324-807f-c9b62fc9e0b6.png)

<font style="color:rgba(0, 0, 0, 0.9);">无论现实世界还是软件世界，谁又能穷尽任意一个领域概念的全部呢？就以“人”这一领域概念而言，在居民身份管理系统中，关注公民这一身份，除了姓名、性别、出生年月等基本信息之外，需关注籍贯、户籍所在地、照片等与公民身份有关的重要属性；在员工管理系统中，关注的内容又变成角色、职位以及教育背景、工作经验等与员工能力息息相关的属性。如果将一个“人”的所有属性加在一起，可以认为是一头完整的“大象”的话，居民身份管理系统与员工管理系统看到的“人”，何尝不像是盲人看到的大象局部呢？而在各自的上下文中，公民与员工就是当前需要关注的全部了。</font>



<font style="color:rgba(0, 0, 0, 0.9);">系统如此，限界上下文亦如此，只是边界更小罢了。因而在教育领域的身份上下文，用户的全部就是诸如姓名、账号、密码以及身份认证等领域知识；切换到学籍上下文，知识语境发生了变化，用户变为了学生，关注的领域知识不再是对身份的认证，而是对学生信息如学籍号的管理，此时的家长，作为学生附带属性的一部分，表达了学生的家庭关系，抽象其概念，可以表示为“家庭成员”；再切换到教务上下文，则需要建立以教师、课程、年级、班级为核心的领域模型，此时的学生概念，变成了教学活动的参与者，建立了班级与学生之间的关系，需要明确学生的“学号”而非“学籍号”，抽象其概念，实则代表了“班级成员”。</font>



<font style="color:rgba(0, 0, 0, 0.9);">在各自知识语境的界定下，如果仍然要保持学生、家长、教师与用户之间的继承关系，就显得“不合时宜”了。本质上，它们是同一个概念在不同语境下的局部知识，在切换上下文时，每个建模者看到的局部概念，都应视为一个整体，如果让学籍管理上下文的学生继承自身份管理上下文的用户，就好似让一头“局部的大象”去继承另外一头“局部的大象”，真是匪夷所思了！正确的领域模型应该如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162105604-02c78741-6839-42e1-82c1-fb6e2de4004e.png)



<font style="color:rgba(0, 0, 0, 0.9);">因此，在领域驱动设计的领域建模中，需要建立</font>**上下文为王**<font style="color:rgba(0, 0, 0, 0.9);">的意识。形成的一个个自治的限界上下文，就是领域模型的“独立王国”，除了需要调用必须的对外公开的业务能力之外，它们几乎是”老死不相往来“的。在跨限界上下文的领域模型之间，即便是相对弱耦合的依赖关系也当避免，更不用说继承、合成与聚合关系了。除非，我们将某个限界上下文设计为“共享内核（shared kernel）”。</font>



<font style="color:rgba(0, 0, 0, 0.9);">在领域驱动设计获得的设计模型中，一个聚合作为边界封装了实体和值对象。我们可以将聚合“伪装”为一个完整的类（其实质是领域模型的边界），与之对应的设计要素还包括管理聚合生命周期的资源库（repository）和负责协作外部资源或多聚合的领域服务（domain service）。多数情况下，一个聚合、一个资源库和一个领域服务可能都需要定义，它们的关系如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162105508-0ffa2b7a-6579-4360-b7fb-7b5747977ef9.png)



<font style="color:rgba(0, 0, 0, 0.9);">资源库和领域服务在操作聚合时，是将</font>**聚合当作一个完整的整体概念来看待**<font style="color:rgba(0, 0, 0, 0.9);">的。领域驱动设计尤其重视聚合对领域模型的边界控制。在设计领域模型时，需要清晰定义出聚合的边界，然后再由此推导出资源库和领域服务。在学籍管理上下文中，我将家长放到了以学生为根实体的聚合中，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162107174-d0ff4c2f-f7bf-4fd8-9cc8-837e29fabed0.png)



<font style="color:rgba(0, 0, 0, 0.9);">一方面，家长信息如家庭住址一般都是学生的属性，另一方面，需要约束学生与家长关系的</font>**不变量（Invariant）**<font style="color:rgba(0, 0, 0, 0.9);">，例如，在为学生添加家长信息时，总不能出现两个父亲吧？——谁愿意呢！</font>



<font style="color:rgba(0, 0, 0, 0.9);">由此可知，当限界上下文作为领域模型的边界时，一方面它限制了跨限界上下文之间领域模型的关系，另一方面它作为知识语境，分离了同一个领域概念的不同视角。我将限界上下文称为</font>**战略设计的基本架构单元**<font style="color:rgba(0, 0, 0, 0.9);">。</font>



<font style="color:rgba(0, 0, 0, 0.9);">聚合作为领域模型的边界，维护的是当前上下文领域概念的完整性，并将其作为一个不可分割的整体，由资源库管理其生命周期。它平衡了领域对象粒度与数量的矛盾，既可以确保每个领域概念的细粒度，又可通过聚合根的封装在形式上减少领域对象的数量。通过聚合边界的控制，减少了领域对象之间不必要的依赖，并通过约束聚合之间的关系来降低耦合。我将聚合称为</font>**战术设计的基本设计单元**<font style="color:rgba(0, 0, 0, 0.9);">。</font>



<font style="color:rgba(0, 0, 0, 0.9);">对象建模范式的领域建模确乎是建立在面向对象思想之上的，但领域驱动设计考虑了软件世界与理想的对象世界之差异，不只是考虑领域模型的关系与协作，还考虑领域模型与外部资源的关系，这就需要施加恰当的约束，进一步保证领域模型的质量。这是我们在进行领域建模时务必谨记的要点。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">2021年7月23日</font>

# 函数范式与领域建模
## [](http://zhangyi.xyz/fp-and-domain-model/#%E5%87%BD%E6%95%B0%E8%8C%83%E5%BC%8F)函数范式
REA的Ken Scambler认为函数范式的主要特征为：模块化（Modularity），抽象化（Abstraction）和可组合（Composability）。这三个特征可以帮助我们编写**简单**的程序。



通常，为了降低系统的复杂度，都需要将系统分解为多个功能的组成部分，每个组成部分有着清晰的边界。**模块化**的编码范式需要支持实现者能够轻易地对模块进行替换，这就要求模块具有隔离性，避免在模块之间出现太多的纠缠。函数范式以“函数”为核心，作为模块化的重要组成部分。函数范式要求函数均为没有副作用的纯函数（pure function）。在推断每个函数的功能时，由于函数没有产生副作用，就可以不考虑该函数当前所处的上下文，形成清晰的隔离边界。这种相互隔离的纯函数使得模块化成为可能。



函数的**抽象**能力不言而喻，因为它本质上是一种将输入类型转换为输出类型的转换行为。任何一个函数都可以视为一种转换(transform)，这是对行为的最高抽象，代表了类型（type）之间的某种动作。极端情况下，我们甚至不用考虑函数的名称和类型，只需要关注其数学本质：`f(x) = y`。其中，x是输入，y是输出，f就是极度抽象的函数。



函数范式领域模型的核心要素为代数数据类型（Algebraic Data Type, ADT）和纯函数。代数数据类型表达领域概念，纯函数表达领域行为。由于二者皆被定义为不变的、原子的，因此在类型的约束规则下可以对它们进行组合。**可组合**的特征使得函数范式建立的领域模型可以由简单到复杂，利用组合子来表现复杂的领域逻辑。

## 代数数据类型
代数数据类型借鉴了代数学中的概念，作为一种函数式数据结构，体现了函数范式的数学意义。通常，代数数据类型不包含任何行为。它利用**和类型（Sum Type）**来展示相同抽象概念的不同组合，使用**积类型（Product Type）**来展示同一个概念不同属性的组合。

和与积是代数中的概念，它们在函数范式中体现了类型的两种组合模式。和就是加，用以表达一种类型是它的所有子类型之和。例如表达时间单位的TimeUnit类型：

```scala
sealed trait TimeUnit

case object Days extends TimeUnit
case object Hours extends TimeUnit
case object Minutes extends TimeUnit
case object Seconds extends TimeUnit
case object MilliSeconds extends TimeUnit
case object MicroSeconds extends TimeUnit
case object NanoSeconds extends TimeUnit
```

**说明：**由于Java并非真正的函数式语言，较难表达一些函数式特性，因此，本节内容的代码使用Scala语言作为示例。



在上述模型中，`TimeUnit`是对时间单位概念的一个抽象。定义为和类型，说明它的实例只能是以下的任意一种：Days、Hours、Minutes、Seconds、MilliSeconds、MicroSeconds或NanoSeconds。这是一种逻辑或的关系，用加号来表示：

```scala
type TimeUnit = Days + Hours + Minutes + Seconds + MilliSeconds + MicroSeconds + NanoSeconds
```



积类型体现了一个代数数据类型是其属性组合的笛卡尔积，例如一个员工类型：

```scala
case class Employee(number: String, name: String, email: String, onboardingDate: Date)
```



它表示Employee类型是`(String, String, String, Date)`组合的集合，也就是这四种数据类型的笛卡尔积，在类型语言中可以表达为：

```plain
type Employee = (String, String, String, Date)
```



也可以用乘号来表示这个类型的定义：

```plain
type Employee = String * String * String * Date
```



和类型和积类型的这一特点体现了代数数据类型的组合（combinable）特性。代数数据类型的这两种类型并非互斥的，有的代数数据类型既是和类型，又是积类型，例如银行的账户类型：

```scala
sealed trait Currency
case object RMB extends Currency
case object USD extends Currency
case object EUR extends Currency

case class Balance(amount: BigDecimal, currency: Currency)

sealed trait Account {
  def number: String
  def name: String
}

case class SavingsAccount(number: String, name: String, dateOfOpening: Date) extends Account
case class BilledAccount(number: String, name: String, dateOfOpening: Date, balance: Balance) extends Account
```



代码中的`Currency`被定义为和类型，`Balance`为积类型。`Account`首先是和类型，它的值要么是`SavingsAccount`，要么是`BilledAccount`；同时，每个类型的Account又是一个积类型。



代数数据类型与对象范式的抽象数据类型有着本质的区别。前者体现了数学计算的特性，具有**不变性**。使用Scala的`case object`或`case class`语法糖会帮助我们创建一个不可变的抽象。当我们创建了如下的账户对象时，它的值就已经确定，不可改变：

```scala
val today = Calendar.getInstance.getTime
val balance = Balance(10.0, RMB)
val account = BilledAccount("980130111110043", "Bruce Zhang", today, balance)
```



数据的不变性使得代码可以更好地支持并发，可以随意共享值而无需承受对可变状态的担忧。**不可变数据是函数式编程中实践的重要原则之一**，它可以与纯函数更好地结合。



代数数据类型既体现了领域概念的知识，同时还通过和类型和积类型定义了约束规则，从而建立了严格的抽象。例如类型组合`(String, String, Date)`是一种高度的抽象，但它却丢失了领域知识，因为它缺乏类型标签，如果采用积类型方式进行定义，则在抽象的同时，还约束了各自的类型。和类型在约束上更进了一步，它将变化建模在一个特定数据类型内部，并限制了类型的取值范围。和类型与积类型结合起来，与操作代数数据类型的函数放在一起，然后利用模式匹配来实现表达业务规则的领域行为。



我们以Robert Martin在《敏捷软件开发》一书中给出的薪资管理系统需求为例，利用函数范式的建模方式来说明代数数据类型的优势。需求描述如下：

> 公司雇员有三种类型。一种雇员是钟点工，系统会按照雇员记录中每小时报酬字段的值对他们进行支付。他们每天会提交工作时间卡，其中记录了日期以及工作小时数。如果他们每天工作超过8小时，超过部分会按照正常报酬的1.5倍进行支付。支付日期为每周五。月薪制的雇员以月薪进行支付。每个月的最后一个工作日对他们进行支付。在雇员记录中有月薪字段。销售人员会根据他们的销售情况支付一定数量的酬金（Commssion）。他们会提交销售凭条，其中记录了销售的日期和数量。在他们的雇员记录中有一个酬金报酬字段。每隔一周的周五对他们进行支付。
>



我们现在要计算公司雇员的薪资。从需求看，我们需要建立的领域模型是雇员，它是一个**积类型**。注意，需求虽然清晰地勾勒出三种类型的雇员，但实则它们的差异体现在**收入**的类型上，这种差异体现为**和类型**不同的值。于是，可以得到由如下代数数据类型呈现的领域模型：

```scala
// ADT定义，体现了领域概念
// Amount是一个积类型，Currency则为前面定义的和类型
calse class Amount(value: BigDecimal, currency: Currency) {
  // 实现了运算符重载，支持Amount的组合运算
  def +(that: Amount): Amount = {
    require(that.currency == currency)
    Amount(value + that.value, currency)
  }
  def *(times: BigDecimal): Amount = {
    Amount(value * times, currency)
  }
}

// 以下类型皆为积类型，分别体现了工作时间卡与销售凭条领域概念
case class TimeCard(startTime: Date, endTimeDate)
case class SalesReceipt(date: Date, amount: Amount)

// 支付周期是一个隐藏概念，不同类型的雇员支付周期不同
case class PayrollPeriod(startDate: Date, endDate: Date)

// Income的抽象表示成和类型与乘积类型的组合
sealed trait Income
case class WeeklySalary(feeOfHour: Amount, timeCards: List[TimeCard], payrollPeriod: PayrollPeriod) extends Income
case class MonthlySalary(salary: Amount, payrollPeriod: PayrollPeriod) extends Income
case class Commission(salary: Amount, saleReceipts: List[SalesReceipt], payrollPeriod: PayrollPeriod)

// Employee被定义为积类型，它组合的Income具有不同的抽象
case class Employee(number: String, name: String, onboardingDate: Date, income: Income)
```



在定义了以上由代数数据类型组成的领域模型之后，即可将其与领域行为结合起来，例如计算每个雇员的收入。由于`Income`被定义为和类型，它表达的是一种逻辑或的关系，因此它的每个子类型（称为ADT变体）都将成为模式匹配的分支。和类型的组合有着确定的值（类型理论的术语将其称之为inhabitant），例如`Income`和类型的值为3，则模式匹配的分支就应该是3个，这就使得Scala编译器可以检查模式匹配的穷尽性。如果模式匹配缺少了对和类型的值表示，编译器都会给出警告。倘若和类型增加了一个新的值，编译器也会指出所有需要新增ADT变体来更新模式匹配的地方。针对`Income`积类型，可以利用模式匹配结合业务规则对它进行解构，代码如下所示：

```scala
def calculateIncome(employee: Employee): Amount = employee.income match {
  case WeeklySalary(fee, timeCards, _) => weeklyIncomeOf(fee, timeCards)
  case MonthlySalary(salary, _) => salary
  case Commision(salary, saleReceipts, _) => salary + commistionOf(saleReceipts)
}
```



`calculateIncome()`是一个纯函数，它利用模式匹配，针对`Employee`的特定`Income`类型计算雇员的不同收入。

## 纯函数
在函数范式中，往往使用纯函数（pure function）来表现领域行为。所谓“纯函数”，就是指没有副作用（side effects）的函数。《Scala函数式编程》认为常见的副作用包括：

+ 修改一个变量
+ 直接修改数据结构
+ 设置一个对象的成员
+ 抛出一个异常或以一个错误终止
+ 打印到终端或读取用户的输入
+ 读取或写入一个文件
+ 在屏幕上绘画

例如，读取花名册文件对内容进行解析获得收件人电子邮件列表的函数为：

```scala
def parse(rosterPath: String): List[Email] = {
  val lines = readLines(rosterPath)
  lines.filter(containsValidEmail(_)).map(toEmail(_))
}
```



代码中的`readLines()`函数需要读取一个外部的花名册文件，这是引起副作用的一个原因。该副作用为单元测试带来了影响。要测试`parse()`函数，就需要为它事先准备好一个花名册文件，增加了测试的复杂度。同时，该副作用使得我们无法根据输入参数推断函数的返回结果，因为读取文件可能出现一些未知的错误，如读取文件错误，又或者有其他人同时在修改该文件，就可能抛出异常或者返回一个不符合预期的邮件列表。



要将`parse()`定义为纯函数，就需要分离这种副作用，函数的计算结果就不会受到任何内部或外部过程状态改变的影响。一旦去掉副作用，调用函数返回的结果就与直接使用返回结果具有相同效果，二者可以互相替换，这称之为“引用透明（referential transparency）”。引用透明的替换性可以用于验证一个函数是否是纯函数。假设客户端要根据解析获得的电子邮件列表发送邮件，解析的花名册文件路径为`roster.txt`。假定解析该花名册得到的电子邮件列表为：

```scala
List(Email("liubei@dddcompany.com"), Email("guanyu@dddcompany.com"))
```



如果`parse()`是一个纯函数，就需要遵循引用透明的原则，则如下函数调用的行为应该完全相同：

```scala
// 调用解析方法
send(parse("roster.txt"))

// 直接调用解析结果
send(List(Email("liubei@dddcompany.com"), Email("guanyu@dddcompany.com")))
```



显然并非如此。后者传入的参数是一个电子邮件列表，而前者除了提供了电子邮件列表之外，还读取了花名册文件。函数获得的电子邮件列表不是由花名册文件路径决定的，而是由读取文件的内容决定。读取外部文件的这种副作用使得我们无法根据确定的输入参数推断出确定的计算结果。要将`parse()`改造为支持引用透明的纯函数，就需要分离副作用，即将产生副作用的读取外部文件功能推向`parse()`函数外部：

```scala
def parse(content: List[String]): List[Emial] = 
content.filter(containsValidEmail(_)).map(toEmail(_))
```



现在，以下代码的行为就是完全相同的：

```scala
send(parse(List("liubei, liubei@dddcompany.com", "noname", "guanyu, guanyu@dddcompany.com")))

send(List(Email("liubei@dddcompany.com"), Email("guanyu@dddcompany.com")))
```



这意味着改进后的`parse()`可以根据输入结果推断出函数的计算结果，这正是引用透明的价值。**保持函数的引用透明，不产生任何副作用，是函数式编程的基本原则。**如果说面向对象设计需要将依赖尽可能向外推，最终采用依赖注入的方式来降低耦合；那么，函数式编程思想就是要利用纯函数来隔离变化与不变，内部由无副作用的纯函数组成，纯函数将副作用向外推，形成由不变的业务内核与可变的副作用外围组成的结构：

![](http://zhangyi.xyz/fp-and-domain-model/01.png)

具有引用透明特征的纯函数更加贴近数学中的函数概念：没有计算，只有转换。转换操作不会修改输入参数的值，只是基于某种规则把输入参数值转换为输出。输入值和输出值都是不变的（immutable），只要给定的输入值相同，总会给出相同的输出结果。例如我们定义`add1()`函数：

```scala
def add1(x: Int):Int => x + 1
```



基于数学函数的转换（transformation）特征，完全可以翻译为如下代码：

```scala
def add1(x: Int): Int => x match {
  case 0 => 1
  case 1 => 2
  case 2 => 3
  case 3 => 4
  // ...
}
```



我们看到的不是对变量x增加1，而是根据x的值进行模式匹配，然后基于业务规则返回确定的值。这就是纯函数的数学意义。



引用透明、无副作用以及数学函数的转换本质，为纯函数提供了模块化的能力，再结合高阶函数的特性，使纯函数具备了强大的组合（combinable）特性，而这正是函数式编程的核心原则。这种组合性如下图所示：

![](http://zhangyi.xyz/fp-and-domain-model/02.png)



图中的`andThen`是Scala语言提供的组合子，它可以组合两个函数形成一个新的函数。Scala还提供了`compose`组合子，二者的区别在于组合函数的顺序不同。上图可以表现为如下Scala代码：

```scala
sealed trait Fruit {
  def weight: Int
}
case class Apple(weight: Int) extends Fruit
case class Pear(weight: Int) extends Fruit
case class Banana(weight: Int) extends Fruit

val appleToPear: Apple => Pear = apple => Pear(apple.weight)
val pearToBanana: Pear => Banana = pear => Banana(pear.weight)

// 使用组合
val appleToBanana = appleToPear andThen pearToBanana
```



组合后得到的函数类型，以及对该函数的调用如下所示：

```plain
scala> val appleToBanana = appleToPear andThen pearToBanana
appleToBanana: Apple => Banana = <function1>

scala> appleToBanana(Apple(15))
res0: Banana = Banana(15)
```



除了纯函数的组合性之外，函数式编程中的Monad模式也支持组合。我们可以简单地将一个Monad理解为提供bind功能的容器。在Scala语言中，bind功能就是`flatMap`函数。可以简单地将`flatMap`函数理解为是`map`与`flattern`的组合。例如，针对如下的编程语言列表：

```plain
scala> val l = List("scala", "java", "python", "go")
l: List[String] = List(scala, java, python, go)
```



对该列表执行map操作，对列表中的每个元素执行`toCharArray()`函数，就可以把一个字符串转换为同样是Monad的字符数组：

```plain
scala> l.map(lang => lang.toCharArray)
res7: List[Array[Char]] = List(Array(s, c, a, l, a), Array(j, a, v, a), Array(p, y, t, h, o, n), Array(g, o))
```



`map`函数完成了从`List[String]`到`List[Array[Char]]`的转换。对同一个列表执行相同的转换函数，但调用`flatMap`函数：

```plain
scala> l.flatMap(lang => lang.toCharArray)
res6: List[Char] = List(s, c, a, l, a, j, a, v, a, p, y, t, h, o, n, g, o)
```



`flatMap`函数将字符串转换为字符数组后，还执行了一次拍平操作，完成了`List[String]`到`List[Char]`的转换。



然而在Monad的真正实现中，`flatMap`并非`map`与`flattern`的组合，相反，`map`函数是`flatMap`基于unit演绎出来的。因此，Monad的核心其实是`flatMap`函数：

```scala
class M[A](value: A) { 
  private def unit[B] (value : B) = new M(value) 
  def map[B](f: A => B) : M[B] = flatMap {x => unit(f(x))} 
  def flatMap[B](f: A => M[B]) : M[B] = ... 
} 
```



`flatMap`和`map`以及`filter`往往可以组合起来，实现更加复杂的针对Monad的操作。一旦操作变得复杂，这种组合操作的可读性就会降低。例如，我们将两个同等大小列表中的元素项相乘，使用`flatMap`与`map`的代码为：

```scala
val ns = List(1, 2)
val os = List(4, 5)
val qs = ns.flatMap(n => os.map(o => n * o))
```



这样的代码并不好理解。为了提高代码的可读性，Scala提供了for-comprehaension。它本质上是Monad的语法糖，组合了flatMap、map与filter等函数；但从语法上看，却类似一个for循环，这就使得我们多了一种可读性更强的调用Monad的形式。同样的功能，使用for-comprehaension语法糖就变成了：

```scala
val qs = for {
  n <- ns
  o <- os
} yield n * o
```



这里演示的for语法糖看起来像是一个嵌套循环，分别从ns和os中取值，然后利用yield生成器将计算得到的积返回为一个列表；实质上，这段代码与使用`flatMap`和`map`的代码完全相同。



在使用纯函数表现领域行为时，我们可以让纯函数返回一个Monad容器，再通过for-comprehaension进行组合。这种方式既保证了代码对领域行为知识的体现，又能因为不变性避免状态变更带来的缺陷。同时，结合纯函数的组合子特性，使得代码的表现力更加强大，非常自然地传递了领域知识。例如，针对下订单场景，需要验证订单，并对验证后的订单进行计算。验证订单时，需要验证订单自身的合法性、客户状态以及库存；对订单的计算则包括计算订单的总金额、促销折扣与运费。



在对这样的需求进行领域建模时，我们需要先寻找到表达领域知识的各个原子元素，包括具体的代数数据类型和实现原子功能的纯函数：

```scala
// 积类型
case class Order(id: OrderId, customerId: CustomerId, desc: String, totalPrice: Amount, discount: Amount, shippingFee: Amount, orderItems: List[OrderItem])

// 以下是验证订单的行为，皆为原子的纯函数，并返回scalaz定义的Validation Monad
val validateOrder : Order => Validation[Order, Boolean] = order =>
if (order.orderItems isEmpty) Failure(s"Validation failed for order $order.id") 
else Success(true)

val checkCustomerStatus: Order => Validation[Order, Boolean] = order => 
Success(true)

val checkInventory: Order => Validation[Order, Boolean] = order => 
Success(true)

// 以下定义了计算订单的行为，皆为原子的纯函数
val calculateTotalPrice: Order => Order = order => 
val total = totalPriceOf(order)
order.copy(totalPrice = total)

val calculateDiscount: Order => Order = order => 
order.copy(discount = discountOf(order))

val calculateShippingFee: Order => Order = order =>
order.copy(shippingFee = shippingFeeOf(order))
```



这些纯函数是原子的、分散的、可组合的，接下来就可以利用纯函数与Monad的组合能力，编写满足业务场景需求的实现代码：

```scala
val order = ...

// 组合验证逻辑
// 注意返回的orderValidated也是一个Validation Monad
val orderValidated = for {
  _ <- validateOrder(order)
  _ <- checkCustomerStatus(order)
  c <- checkInventory(order)
} yield c

if (orderValidated.isSuccess) {
  // 组合计算逻辑，返回了一个组合后的函数
  val calculate = calculateTotalPrice andThen calculateDiscount andThen calculateShippingFee
  // 返回具有订单总价、折扣与运费的订单对象
  // 在计算订单的过程中，订单对象是不变的
  val calculatedOrder = calculate(order)

  // ...
}
```

## 函数范式与领域模型
遵循函数范式建立领域模型时，代数数据类型与纯函数是主要的建模元素。代数数据类型中的和类型与积类型可以表达领域概念，纯函数则用于表达领域行为。它们都被定义为不变的原子类型，然后再将这些原子的类型与操作组合起来，满足复杂业务逻辑的需要。这是函数式编程中面向组合子（combinator）的建模方法，它与面向对象的建模方法存在思想上的不同。



面向对象的建模方法是一种**归纳法**，通过分析和归纳需求，找到问题域并逐级分解问题，然后通过对象来表达领域逻辑，并以职责的角度分析这些领域逻辑，按照角色把职责分配给各自的对象，通过对象之间的协作实现复杂的领域行为。面向组合子的建模方法则是一种**演绎法**，通过在领域需求中寻找和定义最基本的原子操作，然后根据基本的组合规则将这些原子类型与原子函数组合起来。



因此，函数范式对领域建模的影响是全方位的，它与对象范式看待世界的角度迥然不同。对象范式是在定义一个完整的世界，然后以上帝的身份去规划各自行使职责的对象；函数范式是在组合一个完整的世界，它就像古代哲学家一般，看透了物质的本原而识别出不可再分的原子微粒，然后再按照期望的方式组合这些微粒来创造世界。故而，采用函数范式进行领域建模，关键是组合子包括组合规则的设计，既要简单，又要完整，还需要保证每个组合子的正交性，如此才能对其进行组合，互不冗余，互不干涉。这些组合子，就是前面介绍的代数数据类型和纯函数。



通过前面给出的案例，我们发现函数范式的领域模型颠覆了面向对象思想中“贫血模型是坏的”这一观点。事实上，函数范式的贫血模型不同于结构范式和对象范式的贫血模型。结构范式是将过程与数据分离，这些过程实现的是一个完整的业务场景，由于缺乏完整的封装性，因而无法控制对过程与数据的修改对其他调用者带来的影响。对象范式要求将数据与行为封装在一起，就是为了解决这一问题。函数范式虽然建立的是贫血模型，但它的模块化、抽象化与可组合特征降低了变化带来的影响。在组合这些组合子时，通过引入高内聚松耦合的模块对这些功能进行分组，就能避免细粒度的组合子过于散乱，形成更加清晰的代码层次。



Debasish Ghosh总结了函数范式的基本原则，用以建立更好的领域模型：

+ 利用函数组合的力量，用小函数组装成一个大函数，获得更好的组合性。
+ 纯粹，领域模型的很多部分都由引用透明的表达式组成。
+ 通过方程式推导，可以很容易地推导和验证领域行为。



不止如此，根据代数数据类型的不变性以及对模式匹配的支持，它还天生适合表达领域事件。例如地址变更事件，就可以用一个积类型来表示：

```scala
case class AddressChanged(eventId: EventId, customerId: CustomerId, oldAddress: Address, newAddress: Address, occurred: Time)
```



我们还可以用和类型对事件进行抽象，这样就可以在处理事件时运用模式匹配：

```scala
sealed trait Event {
  def eventId: EventId
  def occurred: Time
}

case class AddressChanged(eventId: EventId, customerId: CustomerId, oldAddress: Address, newAddress: Address, occurred: Time) extends Event
case class AccountOpened(eventId: EventId, Account: Account, occurred: Time) extends Event

def handle(event: Event) = event match {
  case ac: AddressChanged => ...
  case ao: AccountOpened => ...
}
```



函数范式中的代数数据类型仍然可以用来表示实体和值对象，但它们都是不变的，二者的区别主要在于是否需要定义唯一标识符。聚合的概念仍然存在，如果使用Scala语言，往往会为聚合定义满足角色特征的trait，这样就可以使得聚合的实现通过混入多个trait来完成代数数据类型的组合。由于资源库（Repository）会与外部资源进行协作，意味着它会产生副作用，因此遵循函数式编程思想，往往会将其推向纯函数的外部。在函数式语言中，可以利用柯里化（Currying，又译作咖喱化）或者Reader Monad来推迟对资源库具体实现的注入。



主流的领域驱动设计往往以对象范式作为建模范式，利用函数范式建立的领域模型多多少少显得有点“另类”，因此我将其称之为非主流的领域驱动设计。这里所谓的“非主流”，仅仅是从建模范式的普及性角度来考虑的，并不能说明二者的优劣与高下之分。事实上，函数范式可以很好地与事件驱动架构结合在一起，这是一种**以领域事件作为模型驱动设计的驱动力**思想。针对事件进行建模，则任何业务流程皆可用状态机来表达。状态的迁移，就是命令（command）或者决策（decision）对事件的触发。我们还可以利用事件风暴（Event Storming）帮助我们识别这些事件，而事件的不变性特征又可以很好地与函数式编程结合起来。



如果采用命令查询职责分离（CQRS）模式，那么在命令端，将由命令与事件组成一系列异步的非阻塞消息流。这种对消息的认识，恰好可以与响应式编程（Reactive Programming）结合起来。诸如ReactiveX这样的响应式编程框架在参考了迭代器模式与观察者模式的基础上，结合了函数式编程思想，以事件处理的形式实现了异步非阻塞处理，在满足系统架构灵活性与伸缩性的同时，提高了事件处理的响应能力。



显然，围绕着不变的事件为中心，包括响应式编程、事件风暴、事件溯源与命令查询职责分离模式都可以与函数范式有效地结合起来，形成一种事件模型驱动设计(Event Model Driven Design, EDDD)方法。与事件驱动架构不同，事件模型驱动设计可以算是领域驱动设计的一种分支。作为一种设计方法学，它的实践与模式同样涵盖了战略设计与战术设计等多个层次，且可以与领域驱动设计的模式如限界上下文、领域事件、领域服务等结合起来。在金融、通信等少数领域，已经开始了对这种建立在函数范式基础之上的领域驱动设计的尝试，与它们相关的知识可以写成厚厚的一本大书，在这里就不再赘述了。

# <font style="color:rgba(0, 0, 0, 0.9);">领域模型在交流中扮演的角色</font>
**问题：**<font style="color:rgba(0, 0, 0, 0.9);">我对于领域模型如何表示始终还不太明白。按照Evans书里的说法，代码应当是领域模型的主要部分，文档、图表作为补充。另外一方面，领域模型应当是所有参与者都能够理解的，而我觉得用户不太可能去理解代码。</font>



<font style="color:rgba(0, 0, 0, 0.9);">比如以Evans书里举的，可以超载10%这一点，书里是通过一个Strategy模式来表达这个知识，从程序员的角度看很清晰了，但是从用户的角度看，还是不太能够明白吧。</font>



<font style="color:rgba(0, 0, 0, 0.9);">请教张老师如何看待这个问题？</font>



**回答**<font style="color:rgba(0, 0, 0, 0.9);">：其实从模型的角度看，有几个层次，Eric说的是模型驱动模型。重点是模型。这几个层次包括：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">现实模型即问题域</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">领域模型</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">设计模型</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">代码模型</font>



<font style="color:rgba(0, 0, 0, 0.9);">实际上领域模型是搭建现实模型需求问题到解决方案的桥梁。领域模型是领域概念尤其是统一语言的可视化表现，在Eric写作《领域驱动设计》一书的时代，领域模型多数以UML来表达。</font>



<font style="color:rgba(0, 0, 0, 0.9);">这里要注意一个历史问题。在Eric写作该书的时代，正是UML与逆向工程大行其道的时代。当时有很多人都在倡导运用建模工具如Rational Rose来建模，进而利用图形化的模型生成代码。这个思想在当时人们的心中会是未来编程的一个主流发展方向，也有很多人在朝着这个方向努力，随之也催生了诸多建模工具的诞生，UML得到大量的普及，甚至差点成为了软件设计的唯一标准。这也是Eric倡导模型驱动设计的一个历史背景，至少我认为他在写书时是收到这个思想影响的。最终，这种设计思想并没有得以实现，人们低估了编程的复杂度，高估了模型的重要性。所以，Eric的书是有历史局限性的。尽信书不如无书，这是阅读他的书要注意的。书中讲的一些实践，未必都对。</font>



<font style="color:rgba(0, 0, 0, 0.9);">但是，Eric的领域驱动设计是一个方法学，是开放的，也是逐步演进的。事实上，已经有很多人站在Eric的肩膀上，提出了很多切合实际，也吻合软件行业发展趋势的实践与模式，作为领域驱动设计的补充。例如领域事件、六边形架构以及CQRS等。Eric自己也认可这种演进。</font>



<font style="color:rgba(0, 0, 0, 0.9);">回到模型上来。我认为领域模型就是对领域概念的抽象，你说的超载10%其实就是业务规则，所以可以抽象为一个领域概念，在与领域专家进行交流时，可以通过领域模型的这个领域概念来表达，而不是直接使用代码。</font>



<font style="color:rgba(0, 0, 0, 0.9);">设计模型则是对领域模型的一种技术呈现，乃至于是从技术角度的一种精化与演进，例如通过引入设计原则与模式，可以实现领域模型对象更好的职责分配，通过抽象实现解耦，定义更加合理的封装。这时，设计模型要取决于你的编程范式，如采用面向对象还是函数式编程。同样以超载规则为例，面向对象范式的设计模型就是抽象的服务接口，函数式就是一个函数。如果规则需要组合，前者就利用继承或委派，后者就用组合子。</font>



<font style="color:rgba(0, 0, 0, 0.9);">代码模型是设计模型的具体实现，它是遵循设计模型来实现的，采用不同的语言和框架，也会有区别。例如，有的语言可以非常方便地定义值对象，如Scala的Case Class，就是值对象的语法糖。</font>



<font style="color:rgba(0, 0, 0, 0.9);">整体来看，领域模型是团队与领域专家交流所用，设计模型是团队的设计人员交流的工具，代码模型自然为程序员服务。这三个模型之间的关系如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162162567-1cedf02e-123b-42bf-ba31-497bde742850.png)



<font style="color:rgba(0, 0, 0, 0.9);">随着时间的推移，这三种模型可能会出现不同步的问题。Eric在书中讲解模型驱动设计时也提到了这个问题。如上图所示，领域模型为指导设计模型，设计模型是领域模型的实现，而随着设计模型的演进，我们又需要这种变更体现在领域模型中，保证模型是领域的真实表达。至于代码模型，一方面是遵循设计模型进行代码的实现，同时还应该尽力保障代码模型要表达领域概念，这不仅仅是从代码可读性的角度来考虑，也牵涉到代码对领域逻辑的呈现。这也是为什么在DDD的编程实践中，我们为什么希望避免贫血模型，希望避免使用无法表达领域行为的get和set方法的原因。</font>



<font style="color:rgba(0, 0, 0, 0.9);">倘若要在代码模型中体现领域模型，一种更好的做法是使用DSL，即领域特定语言。但DSL的实现其实是一个相对漫长的积累过程，不同语言的领域表达能力也不相同。所以DSL主要还是用在一些相对复杂但又相对稳定专业的行业中，例如通信和金融行业，就有DSL的开发需求。当然，即使不去做一套DSL，我们也可以借鉴DSL的思想，例如通过Fluent Interface之类的实践改进代码的表达能力。</font>



<font style="color:rgba(0, 0, 0, 0.9);">还有一种做法就是利用BDD编写验收测试，形成活文档（Live Document）。BDD框架如Cucumber、Robot Framework、RSpec其实就是一种DSL，通过这些框架可以编写符合自然语言规范的测试用例，形成一个中规格（Specification），这些测试用例又是能够运行的代码，这就相当于搭建了代码与需求规格的桥梁。不过，这种活文档只能应用在测试保障上，它可以帮助我们建立一种更好的交流机制，但并不能取代设计模型和代码模型。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">2018年10月14日</font>

# <font style="color:rgba(0, 0, 0, 0.9);">从拼多多事件看电商的促销模型</font>
<font style="color:rgba(0, 0, 0, 0.9);">最近一段时间，电商圈出了一件大事情，拼多多再次吸引了大家的眼球。2019年1月20日，拼多多出现了数额巨大的羊毛Bug，起因在于一张无门槛的优惠券，券面价值100元，可以全场通用（特殊商品除外），有效期一年。如果仅仅从业务角度分析，定义这样的优惠券自身并没有任何问题。当然，也有人说像这样的无门槛券本身就不该用于花费充值、Q币充值等几乎等于现金业务的商品，这是从促销层面去考虑的问题。还有人提到风控问题，为何等到损失达200亿（事后拼多多说明这些优惠券涉及到千万）才发现问题？更有人质疑这是一次别出心裁的炒作。</font>



<font style="color:rgba(0, 0, 0, 0.9);">从薅羊毛的角度看这个Bug，似乎是因为该无门槛券可以被无限次使用导致的。本质上，这确实是一个Bug，我不明白这样的Bug是如何产生的，是测试不到位，还是说该优惠券本身是一个内部测试数据，被不小心放到生产环境？正好，最近正在考虑如何利用分析模式建立电商系统中的促销模型，算是应景之作吧。</font>

## <font style="color:rgba(0, 0, 0, 0.9);">分析模式对模型的精炼</font>


<font style="color:rgba(0, 0, 0, 0.9);">在领域驱动设计中，通过统一语言与“名词动词法”的结合，可以快速获得初步的分析模型。但是这种方法获得的模型品质，受限于语言描述的写作技巧，统一语言的描述更多体现在是对现实世界的模型描述，缺乏深入精准的分析与统一的抽象，使得我们很难发现一些隐含在统一语言背后的重要概念。一言以蔽之，由此获得分析模型还需要进一步精炼。</font>



<font style="color:rgba(0, 0, 0, 0.9);">对相同或相近的领域进行建模分析时，一定有章法和规律可循。例如同样都是电商系统，它们的领域模型定有相似之处；如果都为财务系统，自然也得遵循普适性的会计准则。这并非运用行业术语这么简单，而是结合领域专家的知识，将这些相同或相似的模型抽象出来，形成可以参考和重用的概念模型，这就是Martin Fowler提出的分析模式。Fowler认为：“分析模式是一组概念，这些概念反映了业务建模中的通用结构。它可以只与某个特定的领域相关，也可以跨越多个领域。”由于分析模式是独立于软件技术的，就使得领域专家可以理解这些模式，这是分析建模过程中关键的一点。</font>



<font style="color:rgba(0, 0, 0, 0.9);">每个行业都可以定义自己的分析模式，当然我们也可以参考一些已经被别人总结好的分析模式。例如在Martin Fowler的著作《分析模式》中，模式所覆盖的领域就包括组织结构、单位数量、财务模型、库存与账务、计划以及合同（期权、期货、产品以及交易）等领域。Eric Evans认为利用这些分析模式，“可以避免一些代价高昂的尝试和失败过程，而直接从一个已经具有良好表达力和易实现的模型开始工作，并解决了一些可能难于学习的微妙的问题。我们可以从这样一个起点来重构和实验。”</font>



<font style="color:rgba(0, 0, 0, 0.9);">要获得这样的分析模式，需要专精的领域专家与软件设计师共同来完成。只可惜沟通与知识的壁垒让这样一个重要的分析工作变得举步维艰。Martin Fowler撰写《分析模式》正是希望通过引入更多的模式来降低建模的难度，至少可以做到一定程度的模型复用。然而，分析模式与领域知识息息相关，这就限制了分析模式的通用性；但这并不能说明分析模式不重要。领域驱动设计尤其强调为领域建模，对于那些具有较长生命周期的产品而言，</font>**针对产品的核心领域建立一套分析模式绝对值得，因为它是分析阶段的重要资产，它的稳定与扩展能力可能会直接影响到领域模型中的设计模型与实现模型**<font style="color:rgba(0, 0, 0, 0.9);">。</font>

## <font style="color:rgb(85, 85, 85);"></font><font style="color:rgba(0, 0, 0, 0.9);">案例：促销策略的分析模式</font>


<font style="color:rgba(0, 0, 0, 0.9);">促销（Promotion）是一种运营手段，目的是通过这种手段去刺激消费的各种信息，把信息传递到一个或更多的目标对象，以影响其态度和行为，提高转化率。为了拉动消费，无论是线上还是线下，商家总是会绞尽脑汁提供各种促销手段，这就带来了促销策略的复杂性；然而从消费心理角度考虑，要刺激消费，简单有效的方式就是让消费者认为花了更少的钱却买了更多的商品，这就带来了促销策略的相似性。从某种意义上讲，拼多多的这次促销极大地“刺激”了消费者的热情！</font>

### <font style="color:rgba(0, 0, 0, 0.9);">促销策略的业务背景</font>


<font style="color:rgba(0, 0, 0, 0.9);">在电商系统中，对促销的管理主要牵涉到对促销活动与促销规则的管理。同时，促销还会影响到订单、库存、物流以及支付。如果我们将促销视为核心领域，那么在为它建立分析模型时，应以促销领域为主。</font>

#### <font style="color:rgba(0, 0, 0, 0.9);">促销活动</font>


<font style="color:rgba(0, 0, 0, 0.9);">促销活动实际上是针对促销进行基本属性管理，负责提供活动方式和商品内容，主要包括：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">商品选择：参加促销的商品，分为活动商品和赠品两种；也可以选定商品的品种参与促销，例如针对图书类开展促销。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">投放时间选择：即该促销的有效时段</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">投放区域选择：针对全平台还是部分平台（自营或指定店铺），或者仅针对APP平台</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">用户类型：针对新注册用户，VIP用户等</font>

#### <font style="color:rgba(0, 0, 0, 0.9);">促销规则</font>


<font style="color:rgba(0, 0, 0, 0.9);">促销规则是促销管理的核心。一个促销系统的好坏取决于促销规则设计是否合理，设计时既要考虑到商品的促销，又要考虑到店铺的盈利，还要考虑滞销品和畅销品的差别，因此促销规则的制订是非常灵活的，范围和促销力度也各有不同。大体来看，我们可以从平台、商品种数、促销方式这三个维度来分别理解促销规则的制订：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">平台维度：促销规则可以分为自营促销和POP平台促销。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">商品总数维度：站在商品角度看促销，则促销可以分为单品促销、集合促销和店铺促销： </font>
    - <font style="color:rgba(0, 0, 0, 0.9);">单品促销：以单个商品为维度进行的促销叫单品促销，例如限时抢。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">集合促销：通过商品集合来满足促销规则进行的促销叫集合促销，例如满额减。</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">店铺级促销：以商家店铺为维度进行的促销叫店铺级促销，例如店铺级满额折。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">促销方式维度： </font>
    - <font style="color:rgba(0, 0, 0, 0.9);">直减类：限时抢、直减、多买多折、VIP专享价、手机专享价等</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">赠品：满赠</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">换购类：加价购，凑单</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">满额类：满额减、满额折等</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">返券类：满额返券</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">组合优惠类：套餐</font>
    - <font style="color:rgba(0, 0, 0, 0.9);">预订类：团购</font>



<font style="color:rgba(0, 0, 0, 0.9);">在配置促销规则时，还需要考虑规则的优先级，它会直接影响促销活动的</font>**共享与互斥**<font style="color:rgba(0, 0, 0, 0.9);">。例如我们可以按照一定的优先级完成用户的优惠享用，如享用了单品促销，就不能参加集合促销，满减优先级大于代金券；这是互斥的情况。促销活动也可以共享，例如满额累促销可以与满额包邮共同使用。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">对促销领域的分析建模</font>
<font style="color:rgba(0, 0, 0, 0.9);">我们在为促销领域进行分析建模时，首先需要甄别出该领域的核心概念，然后分析这些概念在该领域中蕴含的业务意义。基于前面介绍的业务背景，我们知道促销领域的核心概念包括促销活动与促销规则。在管理促销活动时，需要指定促销规则，这就产生了二者之间的关联关系。表面看，是通过促销活动去配置促销规则，前者为主，后者为辅；但对于促销而言，其实是活动与规则合二为一组合形成一种</font>**促销产品（Promotion Product）**<font style="color:rgba(0, 0, 0, 0.9);">。这种促销产品可以是“券（Coupon）”形式，也可以是“礼品卡（Gift Card）”形式，又或者是提供“打折（Discount）”或者“包邮（Free Shipping）”。</font>



<font style="color:rgba(0, 0, 0, 0.9);">模型概念“促销产品”的获得实际上是分析建模过程中</font>**对关系建模**<font style="color:rgba(0, 0, 0, 0.9);">的一种体现。在现实世界中，各种概念之间总是会存在各种错综复杂的关系，例如在学校中，有教师与学生之间的师生关系，有院长与教师之间的上下级关系，有教授与研究生之间的科研关系。一旦关系变得越来越多，越来越复杂，仅仅靠体现对象之间的委派关系来体现这种组合就会显得缺乏表现力，这个时候就可以将“关系”提炼为模型中一个显式的概念。</font>



**建模原则：如果某个类型拥有多种相似的关联，可以为这些关联对象定义一个新的类型，并建立一个知识级类型来区分它们。**



<font style="color:rgba(0, 0, 0, 0.9);">前面所述的促销活动与促销规则在业务上存在一定的重复。例如平台维度的促销规则，其实对应的是促销活动中对投放平台或区域的选择。商品总数维度的促销规则，又与促销活动中适用商品（品种）选择的配置重叠了。这是因为我们扩大了所谓“规则”的外延。规则（Rule）不是计划，更不是策略，而应该是一条条具体的可判断是否满足条件的约束规则，例如：</font>

```plain
购指定图书满100元减20元，满200元减40元，在2018年12月12日当天有效。
```



<font style="color:rgba(0, 0, 0, 0.9);">以上描述并非</font>**促销规则**<font style="color:rgba(0, 0, 0, 0.9);">，而是一次完整的</font>**促销**<font style="color:rgba(0, 0, 0, 0.9);">，该促销的促销产品为“券（Coupon）”，券的类型为现金券（若描述中为满额折扣，就是折扣券）。描述“指定图书”属于促销活动中对适用商品（品种）的配置，描述“2018年12月12日当天有效”则是该促销的有效时段属性。唯有描述“满100元减20元，满200元减40元”，才是所谓的</font>**规则**<font style="color:rgba(0, 0, 0, 0.9);">。该规则又包含了两条金额阈值的条件（Creteria）。面对这种场景，我们就可以在分析模型中引入“</font>[<font style="color:rgba(0, 0, 0, 0.9);">规格模式（Specification Pattern）</font>](https://www.martinfowler.com/apsupp/spec.pdf)<font style="color:rgba(0, 0, 0, 0.9);">”。</font>



<font style="color:rgba(0, 0, 0, 0.9);">规格模式由Martin Fowler与Eric Evans提出，他们对规格模式的描述如下所示：</font>



**问题**<font style="color:rgba(0, 0, 0, 0.9);">：  
</font><font style="color:rgba(0, 0, 0, 0.9);">选择（Selection）：需要基于某些条件（Creteria）选择对象的一个子集，且需要多次刷新其选择  
</font><font style="color:rgba(0, 0, 0, 0.9);">验证（Validation）：需要根据确定的目标获得满足条件的合适对象  
</font><font style="color:rgba(0, 0, 0, 0.9);">按需构造（Construction-to-order）：需要描述对象应该做什么而无需解释对象执行的细节，这样就可以构造一个候选对象来满足需求</font>



**解决方案：**<font style="color:rgba(0, 0, 0, 0.9);">  
</font><font style="color:rgba(0, 0, 0, 0.9);">创建一个规格（Specification）对象，它能够辨别候选对象是否满足某些条件。规格对象定义了方法</font>`<font style="color:rgba(0, 0, 0, 0.9);">isSatisfiedBy(anObject)</font>`<font style="color:rgba(0, 0, 0, 0.9);">，如果anObject的所有条件均满足，则返回值true。</font>



**结果：**

+ <font style="color:rgba(0, 0, 0, 0.9);">解除需求设计、实现与验证之间的耦合</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">提供清晰的声明式的系统定义</font>



<font style="color:rgba(0, 0, 0, 0.9);">规格对象可以是单一的，也可以是合成的。</font>



<font style="color:rgba(0, 0, 0, 0.9);">一个促销规则可以包含多个规格，而对于规格而言，在促销场景又可以分为：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">金额（Amount）阈值的规格：例如满200元减40元，或满200元9折</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">数量（Count）阈值的规格：例如满2件9折，又或者限量购</font>



<font style="color:rgba(0, 0, 0, 0.9);">结合业务分析与模型分析，我们可以得出如下的分析模型：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162246764-e0232ed0-f4bb-48d3-8081-7f6911dc4271.png)



<font style="color:rgba(0, 0, 0, 0.9);">分析促销产品时，我们发现模型中的概念并未处于同一个抽象层次，且相互间存在混合关联的关系。例如打折（Discount）或现金抵用（Reward）可以单独针对一次促销提供，也可以和券（Coupon）进行捆绑；礼品卡（Gift Card）和券均可以提供赠品或者包邮。显然，诸如打折、现金抵用、赠品和包邮等概念并非一种促销产品，而是一种促销产品类型，是促销产品的一种属性，例如券的促销产品类型若为打折，就是折扣券，若为现金抵用，就是现金券。这时，促销产品其实是这些产品类型的一种载体。</font>



<font style="color:rgba(0, 0, 0, 0.9);">在电商系统的促销策略中，诸如打折、现金抵用之类的促销手段未必需要通过券或者礼品卡的形式呈现，它们其实是可以作为促销产品被单独使用的。但在建模过程中，我们却不允许概念层次的混乱，因为我们必须要避免领域概念的二义性。例如对于打折（Discount），到底是促销产品，还是促销类型，必须分辨清楚。既然概念层次不在同一个抽象层次上，我们就需要针对这些概念建立一层抽象，这个抽象概念是与券、礼品卡处于同一个抽象层次。这个抽象的促销产品概念就是“优惠（Special Offer）”。因此，前面建立的模型就可以改进为：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162246752-a88c51a6-1df6-4ca8-8baa-f0423810a2f5.png)



**建模原则：保证分析模型中的概念遵循单一抽象层次原则。**

### <font style="color:rgba(0, 0, 0, 0.9);">知识级和操作级</font>


<font style="color:rgba(0, 0, 0, 0.9);">当模型变得渐趋复杂时，《分析模式》引入了操作级（operational level）和知识级（knowledge level）两个层次来组织模型中的概念。操作级模型记录该领域每天发生的事件；知识级模型则定义了操作级对象的合法配置，记录控制着结构的各种通用规则。知识级和操作级二者之间并没有明确的差异，但Martin Fowler认为“将两者（知识级和操作级）分开有助于理清建模思路”。为此，我们需要明确这二者之间的差别。</font>



<font style="color:rgba(0, 0, 0, 0.9);">在《分析模式》一书中，Martin Fowler引入了英国国民医疗服务制度的Cosmos项目作为分析模式的案例，这个模型的推导过程清晰地展现了引入这两个层级是怎么让模型变得更加清晰的。</font>



<font style="color:rgba(0, 0, 0, 0.9);">Cosmos作为一个医疗保健系统，需要对医药行业的测量和观察需求建立模型。简单说来，每个患者的测量结果可以建模为“测量（Meassurement）”。然而针对整家医院，即使是一个患者也可能存在成千上万种可能的测量。如果为每种测量定义一个相应的属性，就意味着一个患者存在着成千上万种可能的测量操作——测量的接口就会变得格外复杂。分析模型的解决方案是将所有可以被测量的不同事物（身高、体重、血糖水平……）都作为测量对象，并将其抽象为“现象类型（Phenomenon Type）”。这里，测量属于操作级，现象类型属于知识级：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162246811-a2068fba-dd8d-44c4-b4d9-95babcb51ffb.png)



<font style="color:rgba(0, 0, 0, 0.9);">在为测量引入现象类型后，患者可以有许多测量，但是针对某一种现象类型而言，患者就只有一个测量。例如John Smith身高1米75，在上述模型中，该描述信息整个代表一个测量，其中，患者是John Smith，现象类型是身高，数量是1米75。</font>



<font style="color:rgba(0, 0, 0, 0.9);">那么为什么现象类型属于知识级，测量属于操作级呢？《分析模式》给出了一条建模原则：“操作级中的对象会经常发生变化，它们的配置由很少发生变化的知识级来约束。”这是</font>**从变化的角度**<font style="color:rgba(0, 0, 0, 0.9);">来区分的。操作级中的“测量”可以被定义成多种多样的测量，但知识级的“现象类型”却是可以穷举的。因此这里提到的“变化”表达的并非类型的变化，而是对象值的变化。</font>



<font style="color:rgba(0, 0, 0, 0.9);">领域概念中存在一些定性的描述，例如医疗观察模型中的血型A现象、汽车分类观察模型中的汽车油量不足现象，它们都是在系统中确确实实存在的客观事实，不会因为观察是否建立而消亡，像这样的定性描述放到知识级中，可以按照规则来使用它们。这是</font>**从领域概念的性质**<font style="color:rgba(0, 0, 0, 0.9);">来区分的。</font>



<font style="color:rgba(0, 0, 0, 0.9);">回到电商系统的促销策略模型，促销可以被定义为多种多样，但促销产品与促销类型在促销领域中却是可以穷举的，因此促销应该被定义在操作级，而促销产品与促销类型则属于知识级。当然，各自级别内部的属性自然也会归入到各自的级别中，正如数量之于测量，在促销策略模型中，有效时段就属于促销的属性，因此有效时段也属于操作级的概念。</font>



<font style="color:rgba(0, 0, 0, 0.9);">促销活动属于操作级，因为它类似案例中的测量概念，针对某一种促销活动类型而言，一次促销只有一个促销活动。为了应对操作级对象（促销活动）的变化，驱动我们引入了知识级的促销活动类型（Activity Type）概念。</font>



<font style="color:rgba(0, 0, 0, 0.9);">从领域概念的性质看，促销类型为折扣（Discount）是一种定性描述，券类型为现金券也是一种定性描述，因此促销类型和券类型属于知识级。那么，促销规格为“满200元减40元”是一种定性描述吗？——不是。虽然一旦定义了这样的规格，它确实是一种不变的事实，但它却是附着在促销规则上，一旦促销规则失效或者被删除，这样的规格就没有存在的意义了。因此促销规则与规格应属于操作级的概念。</font>



<font style="color:rgba(0, 0, 0, 0.9);">每个促销都有属于自己的类别（Label），这个类别是促销的一种定性描述，属于操作级对象。在计算促销优惠时，不同类别的商品会分别计算，同一类别则可以兼容，这相当于分类汇总。对于促销而言，如果我们将一个具体的促销实例视为一个实体，在计算促销优惠时，同一实体的促销是互斥的，不同实体的促销可以叠加组合，也可以按照优先级（Priority）。这个优先级属于促销的属性。优先级可以在配置促销策略时事先配置，也可以由买家指定，例如买家在购买商品时，出现了多种促销叠加的情况，买家就可以根据具体的购买情况选择最适合自己的促销，这时用户指定的优先级要高于事先配置的优先级。</font>



<font style="color:rgba(0, 0, 0, 0.9);">与优先级属性相同，我们还需要为“促销”概念引入“状态”属性，例如标记该促销对象的状态为“未使用”、“已使用”和“过期”。同一个促销不能被用户无限使用，又或者需要给定一个有效期。其中，“已使用”和“过期”都表达了促销实例的无效状态。显然，这个“状态”属性应该属于知识级。再以拼多多为例，刚才提到的优惠券Bug就是促销的“状态”属性未能在使用后设置为“已使用”状态；又或者说在用户使用该促销优惠时，不曾检查促销的“状态”属性，仅允许在“未使用”状态下才是有效可用的。</font>



<font style="color:rgba(0, 0, 0, 0.9);">因此，我们引入分析模式中的建模原则与模式，可以获得如下的分析模型：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162246780-4f5d9f15-e0e2-4a11-8bde-a8a6a31d5a09.png)

### <font style="color:rgba(0, 0, 0, 0.9);">对分析模型的验证</font>


<font style="color:rgba(0, 0, 0, 0.9);">我们可以结合实际的业务场景验证获得的促销分析模型。以京东商城为例，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162246730-82a9b0bb-4c71-475f-85ad-9e05cead1b9e.png)



<font style="color:rgba(0, 0, 0, 0.9);">上图给出了两种促销类别（Label）：联合促销活动与玩具元旦特惠。以玩具元旦优惠类别为例，</font>**促销（Promotion）**<font style="color:rgba(0, 0, 0, 0.9);">为“跨店铺满减”。该促销的</font>**活动类型（Activity Type）**<font style="color:rgba(0, 0, 0, 0.9);">包括适用店铺（值为“跨店铺”）、适用品种（值为“玩具”）。</font>**促销产品（Promotion Product）**<font style="color:rgba(0, 0, 0, 0.9);">为优惠（Special Offer），</font>**促销产品类型（Product Type）**<font style="color:rgba(0, 0, 0, 0.9);">为满减（Reward），</font>**规则（Rule）**<font style="color:rgba(0, 0, 0, 0.9);">为金额阈值规则，</font>**规格（Specification）**<font style="color:rgba(0, 0, 0, 0.9);">为满99.00元减。图中的两种玩具都属于同一个促销类别，因此在计算满减时，这两个商品是可以叠加的。对应的分析模型为：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162248508-37708ed3-295e-42a1-bbd3-85a7f9e12150.png)

<font style="color:rgba(0, 0, 0, 0.9);">我们再来看另外一个促销场景：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162248718-12a6f7e0-84b9-4f5d-af33-17e895c4b9dc.png)



<font style="color:rgba(0, 0, 0, 0.9);">上图展现的促销场景包含了多种促销，它们的促销类别（Lebel）皆为京东自营，因此在进行优惠计算时，这些商品是可以叠加的。这里包含的促销实体包括：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">活动类型（Activity Type）之适用店铺为京东自营，促销产品为券（Coupon），促销产品类型为满减（Reward），优惠规则为金额阈值，规格分别为满49减6、满158减20、满258减30、满388减50等。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">活动类型（Activity Type）之适用店铺为京东自营，适用商品为自营晨光指定商品，促销产品为券（Coupon），促销产品类型为满减（Reward），优惠规则为金额阈值，规格为满98减10。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">活动类型（Activity Type）之适用店铺为京东自营，促销产品为优惠（Special Offer），促销产品类型为包邮（Free Shipping），优惠规则为金额阈值，规格为满99。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">活动类型（Activity Type）之适用店铺为京东自营，促销产品为优惠（Special Offer），促销产品类型为换购（Trade-in），优惠规则为金额阈值，规格为满30。</font>



<font style="color:rgba(0, 0, 0, 0.9);">在促销模型中，这些促销实体就是一个个促销，在实现时，体现为多个促销实例，这些促销实例可以通过促销活动的“适用商品”活动类型，作用到同一件商品，形成这种促销优惠的叠加。</font>



<font style="color:rgba(0, 0, 0, 0.9);">目前给出的促销模型考虑还不全面。一方面这取决于它适用的哪种电商应用场景，例如淘宝与京东的促销策略就不相同，有的电商仅仅支持虚拟商品，相关的促销领域逻辑就有所不同了。另一方面，该模型本身还未考虑如何与计算订单金额、支付以及退换货这些业务相结合。总之业务约复杂，模型也就变得相应的复杂，但同时也要学会利用抽象将模型化繁为简，又或者在模型表达中用不同的视图表达不同的概念，尽量让模型变得精简而直观，同时又不会缺少关键的领域概念。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">2019年1月25日</font>

# <font style="color:rgba(0, 0, 0, 0.9);">识别实体与值对象的特征</font>
<font style="color:rgba(0, 0, 0, 0.9);">甄别实体与值对象非常重要，正确与否会直接影响聚合的设计。</font>

## <font style="color:rgb(85, 85, 85);"></font><font style="color:rgba(0, 0, 0, 0.9);">聚合是边界</font>


<font style="color:rgba(0, 0, 0, 0.9);">在DDD中，聚合是实体与值对象的边界。一个聚合对外代表了一个完整的领域概念，遵循面向对象设计的基本原则，聚合内部往往由多个细小的高内聚领域概念组成。聚合内部的领域模型形成了一棵树，树的根必须是实体，可以称之为是</font>**聚合根（Aggregate Root）**<font style="color:rgba(0, 0, 0, 0.9);">，当然，也可以称之为</font>**根实体（Root Entity）**<font style="color:rgba(0, 0, 0, 0.9);">，它是聚合的唯一入口或出口。例如订单聚合定义了</font>`<font style="color:rgba(0, 0, 0, 0.9);">Order</font>`<font style="color:rgba(0, 0, 0, 0.9);">根实体，它就是订单聚合的唯一代言人。</font>



<font style="color:rgba(0, 0, 0, 0.9);">在一个限界上下文的所有领域模型（实体和值对象）中，按照关系的强弱与概念的完整性，将其划分为多个聚合，就好像草原部落由一个个蒙古包构成了松散的聚居社群一般。</font>



<font style="color:rgba(0, 0, 0, 0.9);">考虑到值对象与实体的差异，倘若需要管理它们的生命周期，则值对象不可能脱离聚合的边界单独存在。这就意味着，当我们要识别领域模型的聚合时，</font>**实体与值对象之间的强弱关系并不会影响到对聚合边界的界定**<font style="color:rgba(0, 0, 0, 0.9);">。只要实体与值对象之间存在关系，无论关系强弱，该值对象都必须与存在关系的实体放在同一个聚合。如果一个值对象与多个实体之间存在关系，要么说明多个实体都属于一个聚合；要么意味着该值对象需要复制为多份，放到不同的聚合中，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162279824-250dcae0-1cef-41cd-a3f7-387ae67c6eeb.png)



<font style="color:rgba(0, 0, 0, 0.9);">如此一来，对于聚合边界的识别，就变成了</font>**对实体关系强弱的判断**<font style="color:rgba(0, 0, 0, 0.9);">。只要我们正确地甄别了实体与值对象，在识别聚合时，就可以不再考虑值对象，如此就能降低识别的难度。</font>

## <font style="color:rgb(85, 85, 85);">限界</font><font style="color:rgba(0, 0, 0, 0.9);">上下文的影响</font>


<font style="color:rgba(0, 0, 0, 0.9);">虽然我们知道实体与值对象之间的本质差异在于是否具备唯一的身份标识（identity），然而许多时候，这一差异仍然显得似是而非。更何况，实体与值对象的定义并非绝对，在不同的上下文，同一个领域概念也可能定义为不同的设计类型。例如下图所示的钞票一枚：</font>



![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162279822-787df790-4abb-4816-b4cd-3dc6032415a5.png)



<font style="color:rgba(0, 0, 0, 0.9);">在购买上下文，买卖双方只关注钞票的面值与货币类型，只要值相等，即可认为是同一个对象，因而需定义为值对象；在印钞上下文，每张钞票都具有一个唯一的标识，即使同为100元的人民币，只要ID不同，也会认为是不同的对象，故而定义为实体。因此，要正确地甄别实体与值对象，需要结合具体的上下文。</font>

## <font style="color:rgb(85, 85, 85);"></font><font style="color:rgba(0, 0, 0, 0.9);">识别的特征</font>


<font style="color:rgba(0, 0, 0, 0.9);">即便如此，仍然缺乏相对客观的判断标准。为此，我总结了如下几个特征。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">相等性</font>


<font style="color:rgba(0, 0, 0, 0.9);">甄别实体与值对象，可以首先从</font>**相等性**<font style="color:rgba(0, 0, 0, 0.9);">进行判断。只要一个领域模型对象的属性值相等，就认为是同一个对象，应优先考虑建模为值对象；否则，需要为领域模型对象定义唯一标识，并建模为实体。</font>



**注意：**<font style="color:rgba(0, 0, 0, 0.9);">在进行相等性判断时，不能将作为唯一标识的ID视为领域模型的属性。</font>



<font style="color:rgba(0, 0, 0, 0.9);">例如地址领域概念，只要其属性值国家、省份、城市、街道与邮政编码相等，就可以认为是同一个地址，应将</font>`<font style="color:rgba(0, 0, 0, 0.9);">Address</font>`<font style="color:rgba(0, 0, 0, 0.9);">类定义为值对象。对于大家耳熟能详的订单领域概念，显然需要为其分配一个唯一的订单编号，因为理论上可能存在除订单编号外其他属性都相同的两个不同订单，应将</font>`<font style="color:rgba(0, 0, 0, 0.9);">Order</font>`<font style="color:rgba(0, 0, 0, 0.9);">定义为实体。</font>



<font style="color:rgba(0, 0, 0, 0.9);">然而，在对相等性进行判断时，可能出现ID与属性存在一种隐含的对应关系。例如，出版行业中作为正规出版物的图书，具有唯一的ISBN号，它相当于是图书领域概念的ID，所以</font>`<font style="color:rgba(0, 0, 0, 0.9);">Book</font>`<font style="color:rgba(0, 0, 0, 0.9);">应定义为实体。可在对</font>`<font style="color:rgba(0, 0, 0, 0.9);">Book</font>`<font style="color:rgba(0, 0, 0, 0.9);">相等性进行判断时，也可以不通过ISBN进行相等性判断，基本上，只要书名、作者（译者）、出版社、价格、出版日期、版次、页数、字数等属性值相同，也可以认为是同一本书，那是否意味着可以将</font>`<font style="color:rgba(0, 0, 0, 0.9);">Book</font>`<font style="color:rgba(0, 0, 0, 0.9);">定义为值对象呢？</font>



<font style="color:rgba(0, 0, 0, 0.9);">显然，在进行相等性判断时，考虑的属性越多，就会出现多个组合的属性形成一种“隐藏”的唯一标识特征，有一些体现业务规则的ID，自身就是根据属性值来定义的。例如，航班的唯一标识就可以根据承运公司二字码、航班号、起降机场三字码与执飞日期来决定。通过唯一标识固然可以决定是否同一个航班，根据映射的多个属性值，也可以判断相等性。这会让人在甄别实体与值对象时，显得摇摆不定。例如，腾讯会议的会议号是</font>`<font style="color:rgba(0, 0, 0, 0.9);">Meeting</font>`<font style="color:rgba(0, 0, 0, 0.9);">的身份标识，在比较会议的相等性时，倘若我们考虑了除会议号之外的其他属性，如会议名称、会议类型、开始时间、结束时间、创建人、创建时间等属性，不一样可以确定会议的相等性吗？</font>



<font style="color:rgba(0, 0, 0, 0.9);">因此，除了判断相等性，还需考虑</font>**不变性**<font style="color:rgba(0, 0, 0, 0.9);">。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">不变性</font>


<font style="color:rgba(0, 0, 0, 0.9);">Eric Evans建议将值对象定义为不变的类，实则是因为根据值判等的值对象就应该具有不变性。仍以购买上下文的钞票为例，</font>`<font style="color:rgba(0, 0, 0, 0.9);">50元+50元=100元</font>`<font style="color:rgba(0, 0, 0, 0.9);">，这100元与原来的50元是另一张不同的钞票：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162279822-b6205107-6fdb-459a-84c7-c92a03953c7b.png)



<font style="color:rgba(0, 0, 0, 0.9);">反之，一个对象除了ID，其余属性值都可以修改，不需要创建一个新的对象，就可以认为该领域对象是可变的，应考虑定义为实体。如前所述的</font>`<font style="color:rgba(0, 0, 0, 0.9);">Meeting</font>`<font style="color:rgba(0, 0, 0, 0.9);">对象，只要</font>`<font style="color:rgba(0, 0, 0, 0.9);">meetingId</font>`<font style="color:rgba(0, 0, 0, 0.9);">值不变，如会议名称、会议类型、开始时间、结束时间这样的属性值即使发生了天翻地覆的变化，我们也认为它是同一个会议。显然，应将</font>`<font style="color:rgba(0, 0, 0, 0.9);">Meeting</font>`<font style="color:rgba(0, 0, 0, 0.9);">定义为实体。</font>



<font style="color:rgba(0, 0, 0, 0.9);">再考虑一个典型的订单聚合：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162279844-5d21c3bb-6b3f-41d9-9937-bb797e0367de.png)



<font style="color:rgba(0, 0, 0, 0.9);">为什么我们要将订单聚合中的</font>`<font style="color:rgba(0, 0, 0, 0.9);">OrderItem</font>`<font style="color:rgba(0, 0, 0, 0.9);">定义为实体？如果不考虑ID属性，只要</font>`<font style="color:rgba(0, 0, 0, 0.9);">orderId</font>`<font style="color:rgba(0, 0, 0, 0.9);">、</font>`<font style="color:rgba(0, 0, 0, 0.9);">product</font>`<font style="color:rgba(0, 0, 0, 0.9);">与</font>`<font style="color:rgba(0, 0, 0, 0.9);">quantity</font>`<font style="color:rgba(0, 0, 0, 0.9);">值相同，完全可以认为是同一个订单项。然则，订单项的</font>`<font style="color:rgba(0, 0, 0, 0.9);">quantity</font>`<font style="color:rgba(0, 0, 0, 0.9);">值是可以更改的，更改了数量的订单项也不会认为是不同的订单项。订单项的可变性决定了它应该定义为实体。</font>



<font style="color:rgba(0, 0, 0, 0.9);">为何要将</font>`<font style="color:rgba(0, 0, 0, 0.9);">OrderItem</font>`<font style="color:rgba(0, 0, 0, 0.9);">的</font>`<font style="color:rgba(0, 0, 0, 0.9);">Product</font>`<font style="color:rgba(0, 0, 0, 0.9);">属性定义为值对象呢？要知道，该</font>`<font style="color:rgba(0, 0, 0, 0.9);">Product</font>`<font style="color:rgba(0, 0, 0, 0.9);">类型还定义了</font>`<font style="color:rgba(0, 0, 0, 0.9);">productId</font>`<font style="color:rgba(0, 0, 0, 0.9);">属性，既然具有身份标识，不应该定义为实体吗？因为在订单上下文中，商品的</font>`<font style="color:rgba(0, 0, 0, 0.9);">productId</font>`<font style="color:rgba(0, 0, 0, 0.9);">来自于商品上下文的商品ID，在订单聚合中，可以将</font>`<font style="color:rgba(0, 0, 0, 0.9);">productId</font>`<font style="color:rgba(0, 0, 0, 0.9);">视为</font>`<font style="color:rgba(0, 0, 0, 0.9);">Product</font>`<font style="color:rgba(0, 0, 0, 0.9);">类的属性值。只要</font>`<font style="color:rgba(0, 0, 0, 0.9);">productId</font>`<font style="color:rgba(0, 0, 0, 0.9);">、</font>`<font style="color:rgba(0, 0, 0, 0.9);">name</font>`<font style="color:rgba(0, 0, 0, 0.9);">和</font>`<font style="color:rgba(0, 0, 0, 0.9);">price</font>`<font style="color:rgba(0, 0, 0, 0.9);">值相同，就可以认为是同一个商品，且它们的值是不变的。这正是将</font>`<font style="color:rgba(0, 0, 0, 0.9);">Product</font>`<font style="color:rgba(0, 0, 0, 0.9);">定义为值对象的原因所在。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">独立性</font>


<font style="color:rgba(0, 0, 0, 0.9);">即使考虑了相等性和不变性，仍有一种例外情形，那就是考虑</font>**独立性**<font style="color:rgba(0, 0, 0, 0.9);">特征。值对象作为实体的属性必定附属于实体，不能单独存在；如果一个领域对象既满足了相等性，又满足了不变性，可定义为值对象；可是，如果它单独存在，且需要管理其生命周期，就需要将这样的类“升级”为实体。</font>



<font style="color:rgba(0, 0, 0, 0.9);">考虑考勤上下文的假期领域概念。由于中国农历假期的缘故，每年都需要配置新的假期。假期概念对应的</font>`<font style="color:rgba(0, 0, 0, 0.9);">Holiday</font>`<font style="color:rgba(0, 0, 0, 0.9);">类定义为：</font>

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1704162279833-48e7e953-daf0-4eeb-8f1e-b9ca08857be8.png)



<font style="color:rgba(0, 0, 0, 0.9);">显然，该类的所有属性值相等，即可认为是同一个假期，一旦修改了假期的值，也可以认为是不同的假期，即</font>`<font style="color:rgba(0, 0, 0, 0.9);">Holiday</font>`<font style="color:rgba(0, 0, 0, 0.9);">类同时满足相等性和不变性，应定义为值对象。可是，在考勤上下文的领域模型中，</font>`<font style="color:rgba(0, 0, 0, 0.9);">Holiday</font>`<font style="color:rgba(0, 0, 0, 0.9);">类是完全独立的，不依附于其他任何实体，而它也需要管理生命周期。这时，就应遵循独立性特征，将其“升级”为实体。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">优先级</font>


<font style="color:rgba(0, 0, 0, 0.9);">以上三个特征并无重要性排列，需综合考虑。如果仍然无法判断，就遵循</font>**优先级**<font style="color:rgba(0, 0, 0, 0.9);">原则：优先将领域概念建模为值对象。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">2021年7月16日</font>

# <font style="color:rgba(0, 0, 0, 0.9);">教会你何时定义领域服务</font>
<font style="color:rgba(0, 0, 0, 0.9);">若遵循基于面向对象设计范式的领域驱动设计，并用以应对纷繁复杂的业务逻辑，则强调领域模型的充血设计模型已成为社区不争事实。我将Eric提及的战术设计要素如Entity、Value Object、Domain Service、Aggregate、Repository与Factory视为</font>**设计模型**<font style="color:rgba(0, 0, 0, 0.9);">。这其中，只有Entity、Value Object和Domain Service才能表达领域逻辑。</font>



<font style="color:rgba(0, 0, 0, 0.9);">为避免贫血模型，在封装领域逻辑时，考虑设计要素的顺序为：</font>

```plain
Value Object -> Entity -> Domain Service
```



<font style="color:rgba(0, 0, 0, 0.9);">切记，我们必须将Domain Service作为承担业务逻辑的最后的救命稻草。之所以把Domain Service放在最后，是因为我太清楚领域服务的强大“魔力”了。开发人员总会有一种惰性，很多时候不愿意仔细思考所谓“职责（封装领域逻辑的行为）”的正确履行者，而领域服务恰恰是最便捷的选择。</font>



<font style="color:rgba(0, 0, 0, 0.9);">就我个人的理解，</font>**只有满足如下三个特征的领域行为才应该放到领域服务中**<font style="color:rgba(0, 0, 0, 0.9);">：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">领域行为需要多个领域实体参与协作</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">领域行为与状态无关</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">领域行为需要与外部资源（尤其是DB）协作</font>



<font style="color:rgba(0, 0, 0, 0.9);">假设某系统的合同管理功能允许客户输入自编码，该自编码需要遵循一定的编码格式。在创建新合同时，客户输入自编码，系统需要检测该自编码是否在已有合同中已经存在。针对该需求，可以提炼出两个领域行为：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">验证输入的自编码是否符合业务规则</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">检查自编码是否重复</font>



<font style="color:rgba(0, 0, 0, 0.9);">在寻找职责的履行者时，我们应首先遵循“</font>**信息专家模式**<font style="color:rgba(0, 0, 0, 0.9);">”，即“拥有信息的对象就是操作该信息的专家”，因此可以提出一个问题：领域行为要操作的数据由谁拥有？针对第一个领域行为，就是要确认谁拥有自编码格式的验证规则？有两个候选：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">拥有自编码信息的“合同(Contract)”对象</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">体现自编码知识概念自身的“自编码（CustomizedNumber）”对象</font>



<font style="color:rgba(0, 0, 0, 0.9);">我倾向于定义CustomizedNumber值对象，将该检测规则封装其内，并在构造函数中对其进行验证。在领域驱动设计中，值对象往往用于封装这些基础概念。由于自定义的类型可以封装领域行为，就可以有效地实现职责的“分治”，实现对象的协作。</font>



<font style="color:rgba(0, 0, 0, 0.9);">若要检查自编码是否重复，则需要从数据库中查找，这就需要通过Repository与DB协作。基于前面总结的三个特征，则该职责应该分配给一个领域服务，例如DuplicatedNumberChecker。</font>



<font style="color:rgba(0, 0, 0, 0.9);">从职责分配的角度看，实体Contract又或者值对象CustomizedNumber才应该是承担该职责的合理选择。为何我却定义了这么一条例外原则呢？究其原因，就是在领域驱动设计中，我们应尽量保证实体与值对象的纯粹性，尤其不应该依赖于Repository（资源库）。继续深挖根本原因，是因为</font>**实体与值对象的生命周期是由Repository管理的**<font style="color:rgba(0, 0, 0, 0.9);">。倘若被管理的实体对象还依赖了Repository，就要求该实体对应的Repository在管理实体对象的生命周期的同时，还需要管理它与Repository的依赖，这并不合理。值对象在一个聚合（Aggregate)边界之内，道理相同。</font>



<font style="color:rgba(0, 0, 0, 0.9);">举例来说，假设Contract是聚合根，如果将检查重复编码的职责分配给该实体对象（或值对象CustomizedNumber），内部就需要依赖ContractRepository。然而，Contract的获取也是通过Repository得到，在基础设施层对ContractRepository的实现时，其实</font>**并不知道该如何管理二者之间的依赖**<font style="color:rgba(0, 0, 0, 0.9);">。如果Contract实体还要依赖其他Repository，就更不可能了。</font>

```java
public class ContractRepositoryImpl implements ContractRepository {
    public Contract contractById(Identity contractId) {
        //这里并不知道Contract对象需要注入ContractRepository对象自身
    }
}
```



<font style="color:rgba(0, 0, 0, 0.9);">若真要解决此依赖管理问题，较简单的做法是为Contract提供一个</font>`<font style="color:rgba(0, 0, 0, 0.9);">setContractRepository()</font>`<font style="color:rgba(0, 0, 0, 0.9);">的依赖注入方法。不过，当Contract是通过Repository来获得时，如Spring、Guice之类的DI框架都无法注入这一依赖，因而需要显式调用，这就会引入对Repository具体实现的耦合。这样的耦合放在领域层，会导致本来单纯的领域层内核依赖了外部资源。倘若将这种具体耦合往外推，例如推到应用层，又会加重调用者的负担。</font>



<font style="color:rgba(0, 0, 0, 0.9);">领域服务则不存在此问题，因为它的生命周期不是由Repository管理。如下的领域服务定义是合情合理的：</font>

```java
public class DuplicatedNumberChecker {

    private ContractRepository repository;

    public boolean isDuplicate(CustomizedNumber number) {
        return repository.existsNumber(number);
    }
}
```



<font style="color:rgba(0, 0, 0, 0.9);">我们在分配领域逻辑时，领域服务是最轻易也是最便宜的首选。这会导致领域服务的泛滥，长此以往，对领域层的开发又会走向“贫血模型”的老路。所谓“服务”本身就是一个抽象概念。越抽象就越显得包容并蓄。例如定义一个OrderService，那么所有和订单有关的逻辑都可以往这个服务里面塞，而诸如Order之类的实体对象终归有不少限制，分配职责时需得思虑再三。因此，倘若在设计与开发时对职责的分配不加约束，所谓的“职责分治”就不过是一句空话罢了。</font>



<font style="color:rgba(0, 0, 0, 0.9);">归根结底，主流的领域驱动设计在战术层面考察的其实是面向对象的设计能力。我认为，所谓面向对象设计，核心就是</font>**角色**<font style="color:rgba(0, 0, 0, 0.9);">、</font>**职责**<font style="color:rgba(0, 0, 0, 0.9);">与</font>**协作**<font style="color:rgba(0, 0, 0, 0.9);">。在分配职责时，应考虑将</font>**数据与行为封装在一起**<font style="color:rgba(0, 0, 0, 0.9);">，这是面向对象设计的首要原则。</font>



<font style="color:rgba(0, 0, 0, 0.9);">为了避免程序员把领域服务当做一个“筐”，什么逻辑都往里面装，除了需要提高团队成员面向对象的设计能力，并加强代码评审之外，还有一个方法，就是对领域服务加以约束。</font>



<font style="color:rgba(0, 0, 0, 0.9);">没有任何语言可以在DDD设计要素上施加约束。Mat Wall与Nik Silver在对Guardian.co.uk网站推行DDD时的实践值得我们借鉴。他们在文章《</font>[<font style="color:rgba(0, 0, 0, 0.9);">演进架构中的领域驱动设计</font>](http://www.infoq.com/cn/articles/ddd-evolving-architecture)<font style="color:rgba(0, 0, 0, 0.9);">》中建议：</font>

> <font style="color:rgba(0, 0, 0, 0.9);">为了对付这一行为，我们对应用中的所有服务进行了代码评审，并进行重构，将逻辑移到适当的领域对象中。我们还制定了一个新的规则：任何服务对象在其名称中必须包含一个动词。这一简单的规则阻止了开发人员去创建类似于ArticleService的类。取而代之，我们创建 ArticlePublishingService和ArticleDeletionService这样的类。推动这一简单的命名规范的确帮助我们将领域逻辑移到了正确的地方，但我们仍要求对服务进行定期的代码评审，以确保我们在正轨上，以及对领域的建模接近于实际的业务观点。</font>
>



<font style="color:rgba(0, 0, 0, 0.9);">其实，这一别具一格的约束形式其实与服务的本质是一脉相承的，即服务应代表无状态的领域行为，甚至可以说领域服务是领域层面用例的体现。</font>



<font style="color:rgba(0, 0, 0, 0.9);">这一实践可能会导致更多细粒度的领域服务产生，但更有可能的结果是，当我们在创建一个新的领域服务时，可能会考虑暂时停下来，想一想，要分配给这个新服务的领域逻辑是否有更好的去处呢？即使因为该逻辑可能牵涉到多个领域实体，又或者需要与Repository协作而不得不放入到领域服务中，似乎也可以考虑将领域逻辑中与实体（或值对象）数据强相关的内容”摘“出来，分配到合适的地方，保证职责分配的合理均衡。</font>**和谐的协作机制**<font style="color:rgba(0, 0, 0, 0.9);">是好的面向对象设计。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">2018年5月11日</font>

# <font style="color:rgba(0, 0, 0, 0.9);">如何分辨领域服务与应用服务</font>
<font style="color:rgba(0, 0, 0, 0.9);">判断什么时候应该定义领域服务，什么时候应该定义应用服务，一个根本的判断依据是看</font>**需要封装的职责是否与领域相关**<font style="color:rgba(0, 0, 0, 0.9);">。</font>

## <font style="color:rgb(85, 85, 85);"></font><font style="color:rgba(0, 0, 0, 0.9);">横切关注点</font>


<font style="color:rgba(0, 0, 0, 0.9);">在应用服务中，我们往往需要和如下逻辑进行协作：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">消息验证</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">错误处理</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">监控</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">事务</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">认证与授权</font>



<font style="color:rgba(0, 0, 0, 0.9);">在《领域驱动设计模式、原理与实践》一书中，将以上内容视为</font>**基础架构问题**<font style="color:rgba(0, 0, 0, 0.9);">。这些关注点与具体的业务逻辑无关，且在整个系统中，可能会被诸多服务调用（以便于重用），因此可以认为这些关注点为</font>**横切关注点**<font style="color:rgba(0, 0, 0, 0.9);">。</font>

![](https://cdn.nlark.com/yuque/0/2024/jpeg/859018/1704162346749-e94f271a-7f37-46d9-b080-144e77e53bd2.jpeg)



<font style="color:rgba(0, 0, 0, 0.9);">从AOP的角度看，所谓“横切关注点”就是那些在职责上是内聚的，但在使用上又会散布在所有对象层次中，且与所散布到的对象的核心功能毫无关系的关注点。与“横切关注点”对应的是“核心关注点”，就是与系统业务有关的领域逻辑。例如订单业务是核心关注点，插入订单时的事务管理则是横切关注点。</font>



<font style="color:rgba(0, 0, 0, 0.9);">横切关注点与核心关注点是分离的，因此与具体的业务无关。于是，我们可以得到应用服务设计的第一条原则：</font>**与横切关注点协作的服务应被定义为应用服务**<font style="color:rgba(0, 0, 0, 0.9);">。</font>

## <font style="color:rgb(85, 85, 85);">整洁架构</font>


<font style="color:rgba(0, 0, 0, 0.9);">如果参考Robert Martin的Clean Architecture以及Cockburn的六边形架构，我们可以将分层架构的应用层对应到Clean Architecture内核中的Use Case层，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/jpeg/859018/1704162346745-fd524e6f-0ae5-4aaf-ac77-b86cb3b25859.jpeg)



<font style="color:rgba(0, 0, 0, 0.9);">据上图，Robert Martin认为Use Case层封装了“Application Business Rules”。我们在分析建模时，一个Use Case往往代表一个完整的业务场景。</font>



<font style="color:rgba(0, 0, 0, 0.9);">对外部的客户而言，DDD的应用层代表了与客户协作的应用服务，接口表达的其实是业务的含义。DDD分层架构的主要目的是要将业务复杂度与技术复杂度分离，应用层扮演的正是这样的一条分界线。从设计模式的角度讲，应用层的应用服务就是一个Facade：对外，它提供代表Use Case的整体应用；对内，它负责整合领域层的领域逻辑与其他基础架构层面的横切关注点。应用服务封装的业务含义，其实仅仅是一个转手的买卖，并不真正具有领域逻辑。因此可以得到应用服务设计的第二条准则：</font>**不包含领域逻辑的业务服务应被定义为应用服务**<font style="color:rgba(0, 0, 0, 0.9);">。</font>

## <font style="color:rgb(85, 85, 85);"></font><font style="color:rgba(0, 0, 0, 0.9);">与领域的交互</font>


<font style="color:rgba(0, 0, 0, 0.9);">第二条设计准则容易造成困惑。虽然单个领域行为确定无误地属于领域逻辑，然而将多个领域行为组合起来的协调行为，算不算是领域逻辑呢？例如对于“下订单”用例而言，如果我们在各自的领域对象中定义了如下行为：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">验证订单是否有效</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">提交订单</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">移除购物车中已购商品</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">发送邮件通知买家</font>



<font style="color:rgba(0, 0, 0, 0.9);">这些行为的组合正好满足了“下订单”这个完整用例的需求，同时也为了保证客户调用的简便性，我们需要对这四个领域行为进行封装。由于这些行为可能牵涉到不同的领域对象，因此只能定义为服务。那么，这个服务应该是应用服务，还是领域服务？</font>



<font style="color:rgba(0, 0, 0, 0.9);">《领域驱动设计模式、原理与实践》一书将这种封装认为是</font>**与领域的交互**<font style="color:rgba(0, 0, 0, 0.9);">。该书作者给出了自己的一个判断标准：</font>

> <font style="color:rgba(0, 0, 0, 0.9);">决定一系列交互是否属于领域的一种方式是提出“这种情况总是会出现吗？”或者“这些步骤无法分开吗？”的问题。如果答案是肯定的，那么这看起来就是一个领域策略，因为那些步骤总是必须一起发生。然而，如果那些步骤可以用若干方式重新组合，那么可能它就不是一个领域概念。</font>
>



<font style="color:rgba(0, 0, 0, 0.9);">但我认为这种判断标准并不准确，至少并非充分必要条件。也就是说，可以分开的领域行为组合在一起未必一定就是应用服务；反过来，一个应用服务封装的领域行为组合也未必一定具有高内聚性。</font>



<font style="color:rgba(0, 0, 0, 0.9);">如果这个判断标准不成立，在牵涉到领域逻辑的协调与交互时，领域逻辑与应用服务的边界就变得非常模糊了。一种观点是在微服务架构中，由于一个Bounded Context的粒度变得越来越小，且代表了跨进程的物理边界，使得区分领域服务与应用服务变得不再那么重要了。换言之，因为微服务的粒度较小，又有着严格的边界控制，业务复杂度与技术复杂度二者的混合产生的负面影响也变得越来越小。</font>



<font style="color:rgba(0, 0, 0, 0.9);">然而，我们不能轻言妥协。只要在微服务边界内依然采用了DDD设计过程，则提炼出一个专门的应用层仍有必要。结合我对DDD的认识，我觉得可以</font>**给应用服务做如下边界定义**<font style="color:rgba(0, 0, 0, 0.9);">：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">与横切关注点进行协作的只能是应用服务</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">若应用服务要与领域交互，则尽可能将与横切关注点无关的纯领域行为往领域服务下推</font>



<font style="color:rgba(0, 0, 0, 0.9);">基于这个定义，以前面的“下订单”用例为例，对这四个领域行为的封装就应该放在领域服务中（关于邮件通知功能是否属于领域服务，后面有深入讨论）。倘若封装在领域服务中的整体逻辑还需要事务管理，又或者在执行下订单任务之前，需要进行身份认证与授权，则需要将这些逻辑的整合放到应用服务中。</font>

## <font style="color:rgb(85, 85, 85);"></font><font style="color:rgba(0, 0, 0, 0.9);">纠结的横切关注点</font>


<font style="color:rgba(0, 0, 0, 0.9);">假设这个定义是切实可行的，可以作为判断一个服务是否为应用服务的标准，则需要先明确什么是“横切关注点”。前面已经明确给出了“横切关注点”的定义，且说明它应该与业务逻辑无关。但是在判断横切关注点以及整合横切关注点时，除了前面提到的事务、监控、身份验证与授权没有争议之外，DDD社区对如下关注点普遍存在困惑与纠结。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">日志</font>


<font style="color:rgba(0, 0, 0, 0.9);">毫无疑问，日志属于横切关注点的范畴。然而，倘若将日志功能仅仅放在应用层，又可能无法准确详细地记录操作行为与错误信息。很多语言都提供了基础的日志框架，将日志混杂在领域对象中，会影响领域的纯粹性，也带来了系统与日志框架的耦合，除非采用AOP的方式。目前看来，这是一种编码取舍，即倾向于代码的纯粹性，还是代码的高质量。我个人还是更看重代码的质量，尤其是丰富的日志内容还有助于运维时的排错，因此建议将对日志共的调用放在领域服务中，算是上述应用服务边界定义的特例。</font>



<font style="color:rgba(0, 0, 0, 0.9);">当然，这个划分并非排他性的。在应用服务中，同样需要调用日志功能，这是记录的信息与粒度与领域服务不尽相同罢了。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">验证</font>


<font style="color:rgba(0, 0, 0, 0.9);">如果是验证外部客户传递过来的消息，例如对RESTful服务的Request请求的验证，则该验证功能属于横切关注点，对它的调用就应该放在应用服务边界。如果验证逻辑属于领域范畴，例如验证订单有效性，这种验证体现的是一种业务规则，则验证逻辑的实现就应该放在领域层，对验证逻辑的调用也应该属于领域对象，包括领域服务。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">分布式通信</font>


<font style="color:rgba(0, 0, 0, 0.9);">微服务缩小了架构设计上的物理边界，使得分布式通信变得更为常见。对于分布式通信的实现毫无疑问属于基础设置层，但在很多情况下，在当前领域中，需要通过分布式通信去访问别的领域提供的服务接口。例如针对“下订单用例”，假设订单、购物车、库存属于不同的微服务，那么在验证订单有效性时，就需要分布式调用库存提供的服务；在提交了订单后，需要分布式调用购物车提供的服务。</font>



<font style="color:rgba(0, 0, 0, 0.9);">这种调用属于对横切关注点的调用吗？</font>**显然不是。**<font style="color:rgba(0, 0, 0, 0.9);">因为从抽象层面讲，这个调用其实是一个业务行为；从实现层面讲，又属于基础设施的技术内容。因此，正确的做法是在领域层定义一个抽象的服务接口，然后通过依赖注入的方式注入到领域服务中。微服务框架Spring Cloud的Feign就支持这种形式的协作。</font>



<font style="color:rgba(0, 0, 0, 0.9);">针对这种分布式通信，Martin Fowler的建议是将消息协议的转换部分（包括验证）放在Gateway模块，而将对外部服务的调用放在Http Client模块中，如下图所示：</font>

![](https://cdn.nlark.com/yuque/0/2024/jpeg/859018/1704162346770-7f212ac3-1317-4af8-97bb-6dd6a70df2af.jpeg)



<font style="color:rgba(0, 0, 0, 0.9);">从分层的角度讲，Gateway与HTTP Client两个模块都应该属于基础设施层，但代表外部服务业务的接口，应该定义在领域层中。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">异常处理</font>


<font style="color:rgba(0, 0, 0, 0.9);">与领域逻辑有关的错误与异常，应该以自定义异常形式表达业务含义，并被定义在领域层。此外，如果该异常表达了业务含义，那么在领域层中，可以将异常定义为Checked Exception，以保证业务的健壮性。由于该异常与业务有关，即使被定义在方法接口中，也不存在异常对接口的污染，即可以将异常视为接口契约的一部分。但是，在领域服务中，不应该将与业务无关的Checked Exception定义在领域服务的方法中，否则就会导致业务逻辑（领域）与技术实现（基础设施）的混合。</font>



<font style="color:rgba(0, 0, 0, 0.9);">在应用层中，应尽可能保证应用服务的通用性，因而需要在应用服务中将与业务有关的自定义异常转换成标准格式的异常，例如统一定义为ApplicationException，然后在message或cause中包含具体的业务含义。因此，针对异常处理，只有这部分与业务无关的处理与转换功能，才属于横切关注点的范畴，并放在应用层中，其余异常处理逻辑都属于领域层。</font>

### <font style="color:rgba(0, 0, 0, 0.9);">通知</font>


<font style="color:rgba(0, 0, 0, 0.9);">通知关注点包括邮件通知、短信通知等功能。对于通知服务的实现，由于需要用到邮件或短信网关等具体技术，因此实现细节属于基础设施层。但是，对通知功能的调用，究竟算不算领域行为，却存在着争议。</font>



<font style="color:rgba(0, 0, 0, 0.9);">由于身份验证服务确定属于应用服务，因此我们可以对比身份验证服务与通知服务，或许能从二者的区别中发现蛛丝马迹。分为如下三个角度去对比：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">DDD的设计角度：通知服务属于Support SubDomain，而身份验证服务则属于Generic SubDomain。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">微服务的设计角度：在微服务架构中，通知服务与身份验证服务相同，都属于Infrastructure Service的范畴。从这个角度讲，似乎应该将通知功能视为关注点。不同之处在于，身份验证服务通常会在服务网关中被调用，且实现方式都是被定义为一个filter，放到对Request进行处理的管道上。通知服务则不同，总是与具体业务绑定在一起，只是它的应用范围更加广泛，不特定在某个具体的业务。</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">用例的设计角度：我们通常将身份验证视为主用例的包含用例（include use case），而将通知服务视为主用例的扩展用例（extend use case）。</font>



<font style="color:rgba(0, 0, 0, 0.9);">显然，通知服务与身份验证服务都具有一定的通用性，但本质上又存在一定的区别。</font>



<font style="color:rgba(0, 0, 0, 0.9);">此外，客户对通知服务的调用可能还存在变化，例如针对不同的业务场景，有的需要邮件通知，有的需要短信通知，有的需要组合两种形式。因此，通知服务体现了某种似是而非的朦胧感：</font>

+ <font style="color:rgba(0, 0, 0, 0.9);">与领域相关，但并非核心领域</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">实现可能存在变化</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">往往被实现为单独的服务</font>
+ <font style="color:rgba(0, 0, 0, 0.9);">通知服务自身可能与主业务强相关</font>



<font style="color:rgba(0, 0, 0, 0.9);">因为这一点朦胧感，我们不能武断地认为对通知服务的调用一定应该放在领域服务或应用服务。我个人倾向于</font>**将调用通知服务的逻辑放在应用服务中，除非通知服务自身可能与主业务强相关**<font style="color:rgba(0, 0, 0, 0.9);">。例如在“下订单”用例中，假设通知逻辑为：当订单总额达到实现设置的阈值时，应采用邮件通知和短信通知两种形式通知买家发货，否则仅采用邮件通知。这时，通知服务自己形成了业务逻辑，且与下订单主业务直接相关，那么，对通知服务的调用就应该被定义在领域服务中。</font>

<font style="color:rgba(0, 0, 0, 0.9);"></font>

<font style="color:rgba(0, 0, 0, 0.9);">2018年3月18日</font>

# 领域服务可以调用Repository接口吗
领域服务可以调用Repository（以下统一称资源库）接口吗？这个问题在我看来，至今没有一个让所有人信服的标准答案。我自然也不敢妄自尊大，以为自己就能破解这个谜题，或者定下铁律，让所有DDD的开发者都来响应我的号召。但讨论这个问题会非常有价值，因为想要刨根问底把这个问题的本质辨析清楚，需要搞清楚在DDD战术设计中非常重要的三个概念区分：

+ 领域服务与聚合各自的职责究竟是什么？
+ 领域服务与应用服务之间的区别是什么？
+ 资源库的本质到底是什么？



将这个问题推而广之，可进一步提出：领域服务可以调用访问基础设施的接口吗？结合事件来探讨，则需要考虑事件溯源对事件的存储、发布和订阅。如此一来，除了实体与值对象，这个问题实际上覆盖了几乎所有的DDD战术设计模式，且牵涉到分层架构对各个层的定义和职责划分。毫不夸张的说，**弄懂了这个问题，你就几乎弄懂了DDD一半以上的知识。**



这一价值就太大了。必须回答这个问题，即便不能找出标准答案，也希望在寻找的路途上收获更多的DDD知识。

## 追本溯源，明确概念
要回答这个问题，得先弄清楚什么是领域服务。



# <font style="color:rgba(0, 0, 0, 0.9);">为什么我们需要正确地领域建模</font>
在领域驱动设计过程中，**正确地进行领域建模**是至为关键的环节。如果我们没有能够从业务需求中发现正确的领域概念，就可能导致职责的分配不合理，业务流程不清晰，出现没有任何领域行为的贫血对象，甚至做出错误的设计决策。

## <font style="color:rgb(85, 85, 85);"></font>最初的实现


在一个结算系统中，业务需求要求导入一个结算账单模板的Excel文档，然后通过账单号查询该模板需要填充的变量值，生成并导出最终需要的结算账单。结算账单有多种，例如内部结算账单等。不同账单的模板并不相同，需要填充的变量值也不相同。



团队确实进行了领域建模，发现了如下的几个领域概念以及对应的服务和资源库对象：

+  InternalSettlementBill 
+  InternalSettlementBillRepository 
+  TemplateReplacement 
+  BaseBillReviewExportTemplate 
+  InternalSettlementBillService 
+  BillReviewService 



为了方便大家对这个设计有直观认识，我先贴出这些关键类型的实现代码：

```java
package settlement.domain;

import lombok.Data;

@Data
public class InternalSettlementBill {
    private String billNumber;
    private String newAndOldBillNumber;
    private String flightIdentity;
    private String flightNumber;
    private String flightRoute;
    private String scheduledDate;
    private String passengerClass;
    private List<Passenger> passengers;
    private String serviceReason;
    private List<CostDetail> costDetails;
    private BigDecimal totalCost;
}

public interface InternalSettlementBillRepository {
    InternalSettlementBill queryByBillNumber(String billNumber);
}

package settlement.infrastructure.file;

import lombok.data;
import lombok.AllArgsConstructor;

@Data
@AllArgsConstructor
public class TemplateReplacement {
    private int rowIndex;
    private int cellNum;
    private String replaceValue;
}

pakcage settlement.domain;

import settlement.infrastructure.file.TemplateReplacement;

abstract class BaseBillReviewExportTemplate<T> {
    public final List<TemplateReplacement> queryAndComposeTemplateReplacementsBy(String billNumber) {
        T t = queryFilledDataBy(billNumber);
        return composeTemplateReplacements(t);
    }

    protected abstract T queryFilledDataBy(String billNumber);
    protected abstract List<TemplateReplacement> composeTemplateReplacements(T t);
}

pakcage settlement.domain;

import settlement.infrastructure.file.TemplateReplacement;
import org.springframework.stereotype.Service;
import javax.annotation.Resource;

@Service
public class InternalSettlementBillService extends BaseBillReviewExportTemplate<InternalSettlementBill> {
    @Resource
    private InternalSettlementBillRepository internalSettlementBillRepository;

    @Override
    protected InternalSettlementBill queryFilledDataBy(String billNumber) {
        return internalSettlementBillRepository.queryByBillNumber(billNumber);
    }

    @Override
    protected List<TemplateReplacement> composeTemplateReplacements(InternalSettlementBill t) {
        List<TemplateReplacement> templateReplacements = new ArrayList<>();
        templateReplacements.add(new TemplateReplacement(0, 0, t.getNewAndOldBillNumber()));
        templateReplacements.add(new TemplateReplacement(1, 0, t.getFlightIdentity()));
        templateReplacements.add(new TemplateReplacement(1, 2, t.getFlightRoute()));
        return templateReplacements;
    }
}

package settlement.domain;

import settlement.infrastructure.file.FileDownloader;
import settlement.infrastructure.file.PoiUtils;
import settlement.infrastructure.file.TemplateReplacement;

import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import javax.annotation.Resource;
import javax.servlet.http.HttpServletResponse;

@Service
public class BillReviewService {
    private static final String DEFAULT_REPLACE_PATTERN = "@replace";
    private static final int DEFAULT_SHEET_INDEX = 0;

    @Value("${file-path.bill-templates-dir}")
    private String billTemplatesDirPath;

    @Resource
    private PoiUtils poiUtils;
    @Resource
    private FileDownloader fileDownloader;
    @Resource
    private InternalSettlementBillService internalSettlementBillService;
    @Resource
    private ExportBillReviewConfiguration configuration;
    public void exportBillReviewByTemplate(HttpServletResponse response, String billNumber, String templateName) {
        try {
            String className = fetchClassNameFromConfigBy(templateName);
            List<TemplateReplacement> replacements = templateReplacementsBy(billNumber, className);

            HSSFWorkbook workbook = poiUtils.getHssfWorkbook(billTemplatesDirPath + templateName);
            poiUtils.fillCells(workbook, DEFAULT_SHEET_INDEX, DEFAULT_REPLACE_PATTERN, replacements);

            fileDownloader.downloadHSSFFile(response, workbook, templateName);
        } catch (Exception e) {
            logger.error("Export bill review by template failed, templateName: {}", templateName);
            e.printStackTrace();
        }
    }

    private List<TemplateReplacement> templateReplacementsBy(String billNumber, String className) {
        switch (className) {
            case "InternalSettlementBill":
                return internalSettlementBillService.queryAndComposeTemplateReplacementsBy(billNumber);
            default:
                return null;
        }
    }

    private String fetchClassNameFromConfigBy(String templateName) throws Exception {
        for (ExportBillReviewConfiguration.Item item : configuration.getItems()) {
            if (item.getTemplateName().equals(templateName)) {
                return item.getClassName();
            }
        }
        throw new Exception("can not found className by templateName in configuration file");
    }
}

package settlement.web.controllers;

import settlement.domain.*;
import settlement.web.model.ExportBillReviewRequest;
import org.springframework.web.bind.annotation.*;
import javax.annotation.Resource;
import javax.servlet.http.HttpServletResponse;

@RestController
@RequestMapping("/bill-review")
public class BillReviewController {
    @Resource
    private BillReviewService billReviewService;

    @PostMapping("/export-template")
    public void exportBillReviewByTemplate(HttpServletResponse response, @RequestBody ExportBillReviewRequest request) {
        billReviewService.exportBillReviewByTemplate(response, request.getBillNumber(), request.getTemplateName());
    }
}
```

在这些类中，领域层的`InternalSettlementBill`表达的是“内部结算账单”领域概念，显然，如代码所示，这个对象是一个典型的贫血对象。`BaseBillReviewExportTemplate`类是一个抽象类，`InternalSettlementBillService`是继承它的子类。团队开发人员运用了模板方法模式，`BaseBillReviewExportTemplate`是获取各种结算账单的`TemplateReplacement`的一个抽象，因为开发人员发现这个过程是通用的：

+  通过billNumber查询结算账单 
+  根据结算账单的值组装导出账单需要的模板替换对象 

## <font style="color:rgb(85, 85, 85);"></font>提炼领域知识


`BaseBillReviewExportTemplate`是一个领域服务，但它其实有一个很糟糕的命名，让人无法看懂它到底承担了什么职责？从命名看，它蕴含了多个概念：bill、review、export、template。究竟要做什么？是账单评阅的导出模板？还是导出账单评阅的模板？它代表了模板的名词概念，还是代表导出的领域行为？真是让人丈二和尚摸不着头脑。其实，阅读其代码实现，发现这个类要做的不过就是获得结算账单的所谓“模板替换（TemplateReplacement）”对象罢了？

`TemplateReplacement`表达的是什么概念呢？通过和团队成员沟通需求，结合代码我梳理出要实现的业务逻辑：

+  用户首先导入一个结算账单模板的Excel工作薄； 
+  Excel工作薄模板中对应的单元格中定义了一些变量值；系统需要从数据库中读取结算账单的信息，然后基于结算账单信息中的值去替换定义在模板中的这些变量； 
+  导出替换了变量值的Excel工作薄。 



显然，替换模板中的变量值是我们期望完成的行为，其本质其实应该是一个模板变量：`TemplateVariable`。这个对象属于领域层的领域概念，不应该被定义在基础设施层。



如此，`BaseBillReviewExportTemplate`这个服务的命名就真可以说是名实不副了，不如更名为`BaseBillTemplateVariablesComposer`。但仔细看它的实现，我发现它不过就是通过一个Repository获得结算账单，再用结算账单中的对应值去组装模板变量。这个组装模板变量的行为放在这个服务中合适吗？遵循“信息专家模式”，`InternalSettlementBill`自身就具备了组装模板变量的信息，它才是承担组装职责的最佳专家啊！于是，我们可以转移职责：

```java
package settlement.domain;

@Data
public class InternalSettlementBill {
    private String billNumber;
    private String newAndOldBillNumber;
    private String flightIdentity;
    private String flightNumber;
    private String flightRoute;
    private String scheduledDate;
    private String passengerClass;
    private List<Passenger> passengers;
    private String serviceReason;
    private List<CostDetail> costDetails;
    private BigDecimal totalCost;

    public List<TemplateVariable> composeVariables() {
        return Lists.newArrayList(
            new TemplateVariable(0, 0, this.newAndOldBillNumber()),
            new TemplateVariable(1, 0, this.flightIdentity()),
            new TemplateVariable(1, 2, this.flightRoute())
        );
    }
}

```

由于不同的结算模板都提供了不同的模板变量，我们就可以为其定义一个抽象的结算模板类型：

```java
package settlement.domain;

public interface SettlementBill {
    List<TemplateVariable> composeVariables();
}

package settlement.domain;

public class InternalSettlementBill implements SettlementBill {}
```

在转移了组装模板变量的职责后，我已经看不出`BaseBillTemplateVariablesComposer`这个服务还有什么存在必要了！是的，它还承担了调用Repository去获得结算账单的职责，但在转移了组装模板变量的职责后，这个服务已经被弱化为只剩下查询职责了。这个查询结算账单的职责不是Repository提供的么？再对这个查询功能做一次封装有何意义？所以，在`InternalSettlementBill`摆脱“贫血对象”的身份后，看起来很酷的模板方法模式就变得没有任何价值了！

## <font style="color:rgb(85, 85, 85);"></font>保持清晰的领域服务


再来看服务`BillReviewService`服务。从实现内容看，它才是真正负责导出结算账单的服务。这个服务的类名既含糊，实现代码又混乱，看起来它根本就不是一个纯粹的业务服务，因为它将业务逻辑与技术实现搅在了一起：既有Excel工作薄的获取，又有通过poi框架实现对单元格数据的填充，还有文件的下载，同时还通过结算账单获得了需要填充的模板变量值。

之所以会出现如此混乱的局面，除了没有有效地将技术实现与业务逻辑通过抽象去隔离之外，**最关键的还是没有正确地建立领域模型**。实际上，这里的**结算账单模板**不正是我们要操作的领域对象吗？实际上，我们要完成的业务功能是**填充以及导出结算账单模板，而不是填充工作薄的单元格，自然也不是下载工作薄文件**。所谓的“工作薄”概念，其实是实现层面的细节。

为保障设计的纯粹性，我们理当将**结算账单模板**定义为一个POJO类型的领域实体对象。即使需要将其导出为Excel工作薄，我们也可以令其持有数据，然后再将数据写入到工作薄。但是，由于结算账单模板的部分内容是通过模板文件直接导入的，除了需要替换的模板变量值之外，其余内容无需重新写入。如果硬要将其定义为纯粹的领域对象，就需要记录账单所有值在工作薄中的坐标，以便于在生成模板文件时正确地填充值；然而，这个模板的部分值在工作薄文件中已经存在了，再做一次无谓的填充就显得多余了。故而，**我们需要做一个设计妥协**，直接将poi框架的`HSSFWorkbook`作为结算账单模板对象内部持有的属性。让领域层依赖poi框架使得我们的领域模型不再纯粹，但为了技术实现的便利性，偶尔退让一步，也未为不可，只要我们能守住底线：**保持系统架构的清晰层次**。

一旦将工作薄对象赋予结算账单模板对象，则模板自身就不再有多种结算账单类别，因为它们的区别在于workbook。因此，我们没有必要为各种结算账单定义对应的模板对象，只需一个`SettlementBillTemplate`即可：

```java
package settlement.domain;

import org.apache.poi.hsf.usermodel.*;

public class SettlementBillTemplate {
    private HSSFWorkbook workbook;
    private int sheetIndex;
    private String replacePattern;

    public SettlementBillTemplate(HSSFWorkbook workbook) {
        this(workbook, 0, "@replace");
    }

    public SettlementBillTemplate(HSSFWorkbook workbook, int sheetIndex, String replacePattern) {
        this.workbook = workbook;
        this.sheetIndex = sheetIndex;
        this.replacePattern = replacePattern;
    }
}
```



既然`SettlementBillTemplate`已经拥有了工作薄对象，为何不将填充模板变量值的功能赋予它呢？

```java
public class SettlementBillTemplate {
    public void fillWith(SettlementBill bill) {
        HSSFSheet sheet = hssfWorkbook.getSheetAt(sheetIndex);
        bill.composeVariables().foreach( v -> {
            HSSFCell cell = sheet.getRow(v.getRowIndex()).getCell(v.getCellNum());
            String cellValue = cell.getStringCellValue();
            String replaceValue = v.getReplaceValue();
            if (replaceValue == null) {
                logger.warn("{} -> {} 替换值为空，未从数据库中查出相应字段值", cellValue, replaceValue);
                continue;
            }
            logger.info("{} -> {}", cellValue, replaceValue);

            if (cellValue.toLowerCase().contains(replacePattern)) {
                cell.setCellValue(cellValue.replace(replacePattern, replaceValue));
            } else {
                cell.setCellValue(replaceValue);
            }
        });
    }
}
```



现在，组装模板以及模板变量的工作已经完成，剩下的就是导出模板了。那么，谁该拥有导出模板的能力呢？虽然要导出的数据是`SettlementBillTemplate`拥有的，但**它并不具备读取与下载工作薄文件的能力**，既然如此，就只能将其放到领域服务。**你看，我在分配表达领域逻辑的职责时，是将领域服务排在最后的顺序。**

在此之前，我们还需要分离业务逻辑与技术实现。什么是业务逻辑？组装模板变量，组装模板以及导出模板都是业务逻辑，而读/写工作薄文件则是技术实现。既然如此，工作薄文件的读写职责就应该分配给基础设施层，然后在interfaces模块中定义它们的抽象接口。**注：**改进后的代码采用的代码结构皆以我的推荐为准。例如下面的接口定义是放在interfaces/file包中，实现放在gateways/file包中：

```java
package settlement.interfaces.file;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;

public interface WorkbookReader {
    HSSFWorkbook readFrom(String templateName);
}
public interface WorkbookWriter {
    void writeTo(HSSFWorkbook workbook, String targetPath);
}

package settlement.gateways.file;
import settlement.interfaces.file.WorkbookReader;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;

public class ExcelWorkbookReader implements WorkbookReader {}

package settlement.gateways.file;
import settlement.interfaces.file.WorkbookWriter;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;

public class ExcelWorkbookWriter implements WorkbookWriter {}
```

## <font style="color:rgb(85, 85, 85);"></font>解决资源库多态的问题
还有一个问题没有解决，就是不同的结算账单是通过不同的Repository获得的。虽然模板已经没有类型的区别了，但用组装模板的模板变量值确实是不相同的。我们需要根据传入的`templateName`决定获得什么样的结算账单对象。但是，我们之前已经为`InternalSettlementBill`定义了对应的Repository，且它被定义为一个接口。是否可以将这个接口作为服务的属性，交给依赖注入去注入实现呢？例如：

```java
public class SettlementBillTemplateExporter {
    @Resource
    private InternalSettlementBillRepository repository;
}
```

这是不对的。因为采用这样的定义，就意味着`SettlementBillTemplateExporter`服务只能查询`InternalSettlementBill`。要解决这个问题，似乎可以为资源库查询所有结算账单的行为定义一个统一接口，如`SettlementBillFinder`接口。然而，这一改进还是不能解决问题，因为决定实例化哪个Repository，是由调用者传递的`templateName`决定的。

在进行领域驱动设计时，为了隔离业务逻辑与技术实现，一般建议对技术实现尽可能做抽象，例如定义抽象的Repository接口，然后再利用依赖注入（Dependency Injection）完成对具体实现的注入。当我们使用框架来完成依赖注入时，就要求领域层的领域对象包括Repository、Service等对象都将由IoC框架来管理生命周期。这些IoC框架在带来依赖管理的便利时，也给我们的设计施加了一些约束。

一种解决办法是为资源库引入静态工厂：

```java
package settlement.repositories;

public interface SettlementBillFinder {
    SettlementBill settlementBillBy(String billNumber);
}

package settlement.repositories;

public interface InternalSettlementBillRepository extends SettlementBillFinder {
    // other methods;
}

package settlement.domain;
import settlement.repositories.SettlementBillFinder;
import settlement.gateways.persistence.InternalSettlementBillMapper;

public class SettlementBillFinderFactory {
    public static SettlementBillFinder create(String templateName) {
        switch (templateName.toLowerCase()) {
            case "internal": 
                return new InternalSettlementBillMapper();
            // 其余分支略
        }
    }
}
```

然而，这样的设计是有问题的，因为它破坏了各层的职责。如上所示的`SettlementBillFinderFactory`是一个静态工厂，它需要创建具体的资源库对象，就意味着它依赖了基础设施层的类，即放在gateways/persistence中的InternalSettlementBillMapper类，而工厂自身却属于领域层。倘若采用这种做法的话，前面运用的依赖注入方法就变得没有意义了。**在领域驱动设计的实现时，我们确实需要时时刻刻保持谨慎，防守住因为某种实现原因导致对整洁架构的破坏。**

要做到这一点，可以考虑使用工厂方法模式，为工厂再定义一个抽象，转而将实现放到基础设施层。例如：

```java
package settlement.domain;

public interface SettlementBillFinderFactory {
    SettlementBillFinder create();
}
```

可惜，这样一个多态的工厂让我们又走回了老路，因为需要调用者根据`templateName`决定使用哪一个具体工厂！这与通过`templateName`确定选择使用哪一个Repository又有何区别呢？反而引入了不必要的间接。



如果使用Spring来管理依赖注入，有一种做法是在服务中定义一个`HashMap<String, String>`，其中key值对应模板名，value值对应`SettlementBillFinder`实现子类的类名，然后在配置文件中配置这些映射信息。当服务传入一个`templateName`时，在这个hashmap中搜索获得的子类类型，然后利用反射来创建这些类。这一方法看起来保证了可扩展性，但实在太繁琐，太复杂，且反射的使用也在一定程度影响了性能。



有两种更简单的办法：

+  让Repository的实现子类自行判断：如果我们将结算账单视为一个领域概念，就应该为其只抽象一个`SettlementBillRepository`。即无需为每种结算账单提供专有的资源库抽象。在定义Repository的查询方法时，将`templateName`与`billNumber`都视为查询的条件，然后在实现类中根据`templateName`去查询不同的表，获得不同的结算账单领域对象。这个方法胜在简单，但较为死板不易扩展。 
+  采用惯例优于配置（CoC）：依然将`templateName`作为服务方法的参数，也依旧提供一个`SettlementBillRepository`抽象，但在基础设施层为每个结算账单提供一个实现，且实现类遵循命名规则，即以`{templateName}`名字（单词首字母大写）为前缀，后缀统一为`SettlementBillRepository`，这样就可以基于规则组装类的类型名，再通过反射创建资源库对象。这一方法胜在能扩展，但依旧引入了反射。 



这里我选择使用最简单的第一种方案，于是导出服务就变为：

```java
package settlement.domain;
import settlement.repositories.SettlementBillRepository;
import settlement.interfaces.file.WorkbookReader;
import settlement.interfaces.file.WorkbookWriter;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;

import javax.servlet.http.HttpServletResponse;

public class SettlementBillTemplateExporter {
    @Service
    private WorkbookReader reader;    
    @Service
    private WorkbookWriter writer;
    @Repository
    private SettlementBillRepository repository;
    
    public void export(HttpServletResponse response, String templateName, String billNumber) {
        SettlementBill bill = repository.settlementBillBy(templateName, billNumber);
        SettlementBillTemplate template = new SettlementBillTemplate(reader.readFrom(templateName));
        template.fillWith(bill);
        writer.writeTo(response, template, templateName);
    }
}
```

## <font style="color:rgb(85, 85, 85);"></font>尽可能保证领域层的整洁
事情还未结束，因为在领域服务的方法中出现了“恼人”的`HttpServletReponse`，它属于servlet包的核心对象。在干净的领域层中，怎么能容忍它的出现呢？（当然poi框架的依赖算是例外，前面已经分析过。）仔细分析，我发现在导出逻辑的实现中，其实仅仅用到了`HttpServletResponse`对象的`getOutputStream()`方法，返回的`OutputStream`对象则是JDK中`java.io`库中的一个类。既然如此，我们可以在领域层为这一需求提供一个抽象，例如定义接口`OutputStreamProvider`：

```java
package settlement.domain;
import java.io.OutputStream;

public interface OutputStreamProvider {
    OutputStream getOutputStream();
}
```

现在的领域服务就可以使用在领域层中自定义的`OutputStreamProvider`抽象。此外，还得加上一些异常处理：

```java
package settlement.domain;
import settlement.domain.exceptions.*;
import settlement.repositories.SettlementBillRepository;
import settlement.interfaces.file.WorkbookReader;
import settlement.interfaces.file.WorkbookWriter;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;

public class SettlementBillTemplateExporter {
    @Service
    private WorkbookReader reader;    
    @Service
    private WorkbookWriter writer;
    @Repository
    private SettlementBillRepository repository;
    
    public void export(OutputStreamProvider streamProvider, String templateName, String billNumber) {
        try {
            SettlementBill bill = repository.settlementBillBy(templateName, billNumber);
            SettlementBillTemplate template = new SettlementBillTemplate(reader.readFrom(templateName));
            template.fillWith(bill);
            writer.writeTo(streamProvider, template, templateName);
        } catch (DownloadTemplateFileException | OpenTemplateFileException ex) {
            throw new TemplateFileFailedException(ex.getMessage(), ex);
        }
    }
}
```

应用服务的定义就变得简单了：

```java
package settlement.application;
import settlement.domain.SettlementBillTemplateExporter;
import settlement.domain.OutputStreamProvider;
import settlement.domain.exceptions.TemplateFileFailedException;

public class SettlementBillAppService {
    @Service
    private SettlementBillTemplateExporter exporter;
    
    public void exportByTemplate(OutputStreamProvider streamProvider, String templateName, String billNumber) {
        try {
            exporter.export(streamProvider, templateName, billNumber);
        } catch (TemplateFileFailedException ex) {
            throw new ApplicationException("Failed to export settlement bill file.", ex);
        }
    }
}
```



对应的，控制器的实现修改为：

```java
package settlement.gateways.controllers;
import settlement.application.SettlementBillAppService;
import settlement.gateways.controllers.model.ExportBillReviewRequest;
import java.io.OutputStream;
import javax.servlet.http.HttpServletResponse;

@RestController
@RequestMapping("/bill-review")
public class BillTemplateController {
    @Resource
    private SettlementBillAppService settlementBillService;

    @PostMapping("/export-template")
    public void exportBillReviewByTemplate(HttpServletResponse response, @RequestBody ExportBillReviewRequest request) {
        exportService.exportByTemplate(response::getOutputStream, request.getTemplateName(), request.getBillNumber());
    }
}
```

## <font style="color:rgb(85, 85, 85);"></font>代码的层次结构


如上代码的层次结构为：

```plain
settlement
    - application
        - SettlementBillAppService
    - domain
        - SettlementBill
        - TemplateVariable
        - InternalSettlementBill
        - SettlementBillTemplate
        - SettlementBillTemplateExporter
        - OutputStreamProvider
        - exceptions
            - TemplateFileFailedException 
            - DownloadTemplateFileException
            - OpenTemplateFileException
    - repositories（persistence技术实现的抽象）
        - SettlementBillRepository
    - interfaces（技术实现层面的抽象）
        - file
            - WorkbookReader
            - WorkbookWriter
    - gateways（包含技术实现层面）
        - persistence
            - SettlementBillMapper
        - file
            - ExcelWorkbookReader
            - ExcelWorkbookWriter
        - controllers
            - BillTemplateController 
            - model
                - ExportBillReviewRequest
```

## <font style="color:rgb(85, 85, 85);"></font>总结


通过以上对代码的逐步演化，我们就此可以发现原来代码的诸多问题。这些问题往往是许多领域驱动设计新手容易犯的错误，包括：

+  未能正确地表达领域知识 
+  贫血的领域模型 
+  层次不清，对DDD的分层架构理解混乱 
+  领域服务与应用服务概念混乱 
+  业务逻辑与技术实现纠缠在一起 



回归这些问题的原点，其实还是在于**团队没有正确地进行领域建模**。如果还要继续深究，则在于**团队没有为领域建立统一语言**。我们看前面对模板导出业务的分析，每一个步骤都没有正确表达业务逻辑，因而获得的领域对象也是不正确的。又由于没有建立统一语言，导致对类和方法的命名都不能很好地体现领域概念，甚至导致某些表达领域概念的类被错误地放在了基础设施层。当我们在运用面向对象编程范式来实现领域驱动设计时，对OO思想的理解偏差与知识缺乏也反映到了代码的实现上，尤其是对“贫血模型”的理解，对职责分配的认知，都会直接反映到代码层面上。

最后，如果团队成员没有清晰地理解分层架构各层的含义，以及为何要引入分层架构，就无法守住分层架构各层的边界，最后就会导致业务复杂度与技术复杂度的混搭。若系统简单还好说，一旦系统的业务复杂度增加带来系统规模的扩大，不紧守架构层次的边界，就可能导致我们事先建立的分层架构名存实亡，代码变成大泥球，重新回归到太初的混沌世界。



2018年7月17日

# 从面向对象设计到领域驱动设计
本文通过一个简单的案例阐述什么是正确的面向对象设计，而通常所讲的面向对象设计，其实只是营造了一个理想的对象世界。在面对现实问题时，领域驱动设计提出了解决方案，通过在战略模式中运用限界上下文，在战术模式中运用聚合，有效地控制了业务复杂度，让设计变得合情合理。

## <font style="color:rgb(85, 85, 85);"></font>最初的版本
下图列出超市收银员的第1个版本：

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1684069688142-73c906ba-f450-42e9-8073-7021725eaf0f.png)

这一设计违背了面向对象设计原则：

+ 迪米特法则：Cashier不应该直接访问Wallet对象
+ 信息专家模式：访问Wallet的行为应该分配给拥有Wallet的Customer对象

迪米特法则认为两个对象若要产生调用关系，需要满足：

+ 一个对象是另一个对象方法的参数
+ 一个对象是另一个对象的属性
+ 一个对象被另一个对象创建

可认为这样的两个对象是一对好朋友，而朋友的朋友呢，则认为是陌生人。迪米特法则认为：“**不要和陌生人通话**”，所以陌生人之间不允许出现调用关系。如代码所示，Customer作为Cashier中charge()方法的参数，二者为朋友；Wallet作为Customer的属性，二者为朋友；——但朋友的朋友并非朋友，所以Cashier不能绕开Customer直接访问Wallet，如下图所示：

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1684070130042-64a10b15-4b1a-4842-805e-31a52e39aba7.png)

同理，根据信息专家模式，**拥有信息的对象是操作该信息的专家**，既然Customer拥有Wallet，就该将操作Wallet的方法分给它。

## <font style="color:rgb(85, 85, 85);"></font>重构的版本
通过提取方法和转移方法，对Cashier和Customer开展重构，可得到如下图所示的第2个版本：

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1684070295094-6d2e9523-0c64-4e5c-82ed-003299b49347.png)

注意，不仅位于Cashier的大部分职责通过提取为pay()方法转移到Customer，原实现中对钱包中的钱的判断，即条件表达式：

```java
myWallet.getTotalMoney() >= payment
```

也被提取为isEnough()方法，转移到了Wallet，真正实现了职责的合理分配。

重构后的版本满足了面向对象设计原则。Wallet是Customer的隐私，重构后的版本保护了Customer的隐私；对Wallet的操作并非Cashier希望关注的细节，设计时，应该让调用者了解的知识越少越好，设计的接口也更友好。

## <font style="color:rgb(85, 85, 85);"></font>对象世界的问题
版本2的代码看起来很美好，只可惜，它创造的不过是一个理想的对象世界。

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1684070781837-8e240760-333d-4c26-b9a7-9f0ab6b00aae.png)

计算机并非永远都在运行，也不会拥有无限的内存空间，因而我们不能只考虑对象在内存空间中的引用与协作。我将其称之为**领域对象的哲学三问题**：

+ 我是谁：对象代表什么身份，它拥有的信息是完整的吗？
+ 从哪里来：对象诞生自何处？
+ 到哪里去：对象消亡了，会回到哪里？

由此引出领域对象的现实问题：

+ 问题一：领域模型对象如何与数据库协作？
+ 问题二：领域模型对象的加载以及对象间的关系该如何处理？
+ 问题三：领域模型对象在身份上是否存在泾渭分明的差别？
+ 问题四：领域模型对象彼此之间如何能弱依赖地完成状态的变更通知？

## <font style="color:rgb(85, 85, 85);"></font>引入领域驱动战术设计模式
领域驱动设计通过引入实体、值对象、聚合、资源库（Repository）与工厂、领域服务和领域事件七种角色解决以上所说的现实问题。

领域对象通过聚合作为边界形成一个个独立的整体领域概念，并交由资源库和工厂管理其生命周期。聚合内的实体与值对象有其不同身份，前者通过定义唯一标识支持生命周期管理时对实体的识别与跟踪。当各个聚合被加载到内存后，聚合之间只能通过根实体建立关系，也可以通过领域事件通知彼此状态的变更。如下图所示：

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1684070900437-31337198-4c3b-4563-b01c-0bf5340c5d14.png)

因为计算机能力所限，我们无法营造一个理想的大而全的对象世界，领域驱动设计则提供一种设计上的妥协，**以聚合作为设计约束**，将整个对象设计划分为一个个小而美的村落，每个村落就像一个小的桃花源，实体与值对象之间能做到“黄发垂髫并怡然自乐”，不受外界环境的干扰。

以超市收银员为例，受到现实世界的影响，Cashier与Customer等对象需要持久化到数据库。遵循领域驱动设计模式，可将Cashier与Customer定义为两个不同的聚合，而Wallet作为值对象放入Customer聚合内部。两个聚合都有属于自己的资源库，并通过领域服务实现聚合、资源库之间的协作。如下图所示：

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1684071418363-d11e817d-850c-4a1c-bbf5-0ad799672ceb.png)

领域服务CashierService对外担任收银的职责，实际上，它只是一个控制者或者协调者，通过资源库加载各自的聚合到内存后，彼此即可友好协作了：

```java
public class CashierService {
    private CashierRepository cashierRepo;
    private CustomerRepository custRepo;
    
    public void charge(String cashierId, String custId, float payment) {
        Cashier cashier = cashierRepo.cashierOf(cashierId);
        Customer customer = custRepo.customerOf(custId);
        cashier.charge(customer, payment);
    }
}
```

除了引入领域服务和资源库，领域对象的定义与协作与第2个版本的代码完全一致。不同之处在于，现有设计清晰地明确了Wallet属于Customer聚合的一部分，根据领域驱动设计的要求，**并不允许聚合外部的对象直接访问聚合的非根元素**，如此则有效避免了第1个版本出现的问题。

这就是引入领域驱动战术设计模式之后的第3版。领域逻辑形成一种三权分立的态势：

+ 信息操作权-聚合：持有静态业务数据，并执行操作这些数据的领域行为
+ 对象生命权-资源库：管理聚合的生命周期
+ 领域控制权-领域服务：在聚合与领域服务之上对外提供相对完整的领域行为，对内控制聚合之间的协作，以及聚合和资源库之间的协作

**聚合的边界构成聚合内和聚合外两个不同的世界。**聚合内维持了理想的对象世界，聚合内的实体与值对象都在内存中，可以遵循面向对象设计原则，自如地实现行为之间的协作。

## <font style="color:rgb(85, 85, 85);"></font>引入领域驱动战略设计模式
理想很丰满，现实很骨感。一旦我们把超市收银员这一系统的规模扩大，就需要从架构层面考虑更大的独立边界。这是控制规模复杂度最有效的手段，即分而治之。

**领域驱动设计提出的分而治之策略就是划分限界上下文。**如果我们将Cashier和Customer划分到两个不同的限界上下文，它们彼此之间就需要完全隔离，否则就会造成**大泥球似的单体系统**。

为了清晰地界定各自边界，在降低耦合的同时完成彼此的协作，**一种有效手段是为限界上下文引入菱形对称架构模式**。如此一来，下游限界上下文与上游限界上下文之间的协作，就只能**通过下游的南向网关向上游的北向网关发起调用**，从而得到最终版即第4版的超市收银员：

![](https://cdn.nlark.com/yuque/0/2023/png/859018/1684072459524-f232a6e6-97b3-40d5-bdc0-5d8331186c7f.png)

相较第3版而言，第4版变得更加复杂，除了已有的对象之外，还引入了北向网关的远程服务和本地服务，以及南向网关的端口和适配器。

**两个限界上下文之间的协作有着严格的规定**，CashierService不能跨过限界上下文直接访问CustomerRepository，而是通过自身南向网关的端口CustomerClient发起对上游的调用。

虽然结构变得更加复杂，但我们看待问题不能脱离现实。在做出这一设计决策之前，我们给出一个前提，就是超市收银员系统的规模扩大了，不仅需求变得越来越复杂，导致领域模型更加庞大，负责开发它的团队规模也扩大了，需要多个团队互相协作、并行开发。倘若我们只是从限界上下文的层次看待上图，每个限界上下文的内部依旧简单。

领域驱动设计的聚合与限界上下文都是**通过引入边界为设计添加了约束**。这些约束看起来让设计者变得束手束脚，却能够以一种森严的纪律防止架构和代码的腐化，确保系统的架构保持清晰，并具有一致的面貌，即便随着需求的日益增长，依然能够保持对架构的控制力。



2023年5月15日

# 函数范式与领域建模
## 函数范式


REA的Ken Scambler认为函数范式的主要特征为：模块化（Modularity），抽象化（Abstraction）和可组合（Composability）。这三个特征可以帮助我们编写**简单**的程序。



通常，为了降低系统的复杂度，都需要将系统分解为多个功能的组成部分，每个组成部分有着清晰的边界。**模块化**的编码范式需要支持实现者能够轻易地对模块进行替换，这就要求模块具有隔离性，避免在模块之间出现太多的纠缠。函数范式以“函数”为核心，作为模块化的重要组成部分。函数范式要求函数均为没有副作用的纯函数（pure function）。在推断每个函数的功能时，由于函数没有产生副作用，就可以不考虑该函数当前所处的上下文，形成清晰的隔离边界。这种相互隔离的纯函数使得模块化成为可能。



函数的**抽象**能力不言而喻，因为它本质上是一种将输入类型转换为输出类型的转换行为。任何一个函数都可以视为一种转换(transform)，这是对行为的最高抽象，代表了类型（type）之间的某种动作。极端情况下，我们甚至不用考虑函数的名称和类型，只需要关注其数学本质：`f(x) = y`。其中，x是输入，y是输出，f就是极度抽象的函数。



函数范式领域模型的核心要素为代数数据类型（Algebraic Data Type, ADT）和纯函数。代数数据类型表达领域概念，纯函数表达领域行为。由于二者皆被定义为不变的、原子的，因此在类型的约束规则下可以对它们进行组合。**可组合**的特征使得函数范式建立的领域模型可以由简单到复杂，利用组合子来表现复杂的领域逻辑。

## 代数数据类型


代数数据类型借鉴了代数学中的概念，作为一种函数式数据结构，体现了函数范式的数学意义。通常，代数数据类型不包含任何行为。它利用**和类型（Sum Type）**来展示相同抽象概念的不同组合，使用**积类型（Product Type）**来展示同一个概念不同属性的组合。



和与积是代数中的概念，它们在函数范式中体现了类型的两种组合模式。和就是加，用以表达一种类型是它的所有子类型之和。例如表达时间单位的TimeUnit类型：

```scala
sealed trait TimeUnit

case object Days extends TimeUnit
case object Hours extends TimeUnit
case object Minutes extends TimeUnit
case object Seconds extends TimeUnit
case object MilliSeconds extends TimeUnit
case object MicroSeconds extends TimeUnit
case object NanoSeconds extends TimeUnit
```



**说明：**由于Java并非真正的函数式语言，较难表达一些函数式特性，因此，本节内容的代码使用Scala语言作为示例。



在上述模型中，`TimeUnit`是对时间单位概念的一个抽象。定义为和类型，说明它的实例只能是以下的任意一种：Days、Hours、Minutes、Seconds、MilliSeconds、MicroSeconds或NanoSeconds。这是一种逻辑或的关系，用加号来表示：

```plain
type TimeUnit = Days + Hours + Minutes + Seconds + MilliSeconds + MicroSeconds + NanoSeconds
```



积类型体现了一个代数数据类型是其属性组合的笛卡尔积，例如一个员工类型：

```scala
case class Employee(number: String, name: String, email: String, onboardingDate: Date)
```



它表示Employee类型是`(String, String, String, Date)`组合的集合，也就是这四种数据类型的笛卡尔积，在类型语言中可以表达为：

```scala
type Employee = (String, String, String, Date)
```



也可以用乘号来表示这个类型的定义：

```plain
type Employee = String * String * String * Date
```



和类型和积类型的这一特点体现了代数数据类型的组合（combinable）特性。代数数据类型的这两种类型并非互斥的，有的代数数据类型既是和类型，又是积类型，例如银行的账户类型：

```scala
sealed trait Currency
case object RMB extends Currency
case object USD extends Currency
case object EUR extends Currency

case class Balance(amount: BigDecimal, currency: Currency)

sealed trait Account {
  def number: String
  def name: String
}

case class SavingsAccount(number: String, name: String, dateOfOpening: Date) extends Account
case class BilledAccount(number: String, name: String, dateOfOpening: Date, balance: Balance) extends Account
```



代码中的`Currency`被定义为和类型，`Balance`为积类型。`Account`首先是和类型，它的值要么是`SavingsAccount`，要么是`BilledAccount`；同时，每个类型的Account又是一个积类型。



代数数据类型与对象范式的抽象数据类型有着本质的区别。前者体现了数学计算的特性，具有**不变性**。使用Scala的`case object`或`case class`语法糖会帮助我们创建一个不可变的抽象。当我们创建了如下的账户对象时，它的值就已经确定，不可改变：

```scala
val today = Calendar.getInstance.getTime
val balance = Balance(10.0, RMB)
val account = BilledAccount("980130111110043", "Bruce Zhang", today, balance)
```



数据的不变性使得代码可以更好地支持并发，可以随意共享值而无需承受对可变状态的担忧。**不可变数据是函数式编程中实践的重要原则之一**，它可以与纯函数更好地结合。



代数数据类型既体现了领域概念的知识，同时还通过和类型和积类型定义了约束规则，从而建立了严格的抽象。例如类型组合`(String, String, Date)`是一种高度的抽象，但它却丢失了领域知识，因为它缺乏类型标签，如果采用积类型方式进行定义，则在抽象的同时，还约束了各自的类型。和类型在约束上更进了一步，它将变化建模在一个特定数据类型内部，并限制了类型的取值范围。和类型与积类型结合起来，与操作代数数据类型的函数放在一起，然后利用模式匹配来实现表达业务规则的领域行为。



我们以Robert Martin在《敏捷软件开发》一书中给出的薪资管理系统需求为例，利用函数范式的建模方式来说明代数数据类型的优势。需求描述如下：

> 公司雇员有三种类型。一种雇员是钟点工，系统会按照雇员记录中每小时报酬字段的值对他们进行支付。他们每天会提交工作时间卡，其中记录了日期以及工作小时数。如果他们每天工作超过8小时，超过部分会按照正常报酬的1.5倍进行支付。支付日期为每周五。月薪制的雇员以月薪进行支付。每个月的最后一个工作日对他们进行支付。在雇员记录中有月薪字段。销售人员会根据他们的销售情况支付一定数量的酬金（Commssion）。他们会提交销售凭条，其中记录了销售的日期和数量。在他们的雇员记录中有一个酬金报酬字段。每隔一周的周五对他们进行支付。
>



我们现在要计算公司雇员的薪资。从需求看，我们需要建立的领域模型是雇员，它是一个**积类型**。注意，需求虽然清晰地勾勒出三种类型的雇员，但实则它们的差异体现在**收入**的类型上，这种差异体现为**和类型**不同的值。于是，可以得到由如下代数数据类型呈现的领域模型：

```scala
// ADT定义，体现了领域概念
// Amount是一个积类型，Currency则为前面定义的和类型
calse class Amount(value: BigDecimal, currency: Currency) {
  // 实现了运算符重载，支持Amount的组合运算
  def +(that: Amount): Amount = {
    require(that.currency == currency)
    Amount(value + that.value, currency)
  }
  def *(times: BigDecimal): Amount = {
    Amount(value * times, currency)
  }
}

// 以下类型皆为积类型，分别体现了工作时间卡与销售凭条领域概念
case class TimeCard(startTime: Date, endTimeDate)
case class SalesReceipt(date: Date, amount: Amount)

// 支付周期是一个隐藏概念，不同类型的雇员支付周期不同
case class PayrollPeriod(startDate: Date, endDate: Date)

// Income的抽象表示成和类型与乘积类型的组合
sealed trait Income
case class WeeklySalary(feeOfHour: Amount, timeCards: List[TimeCard], payrollPeriod: PayrollPeriod) extends Income
case class MonthlySalary(salary: Amount, payrollPeriod: PayrollPeriod) extends Income
case class Commission(salary: Amount, saleReceipts: List[SalesReceipt], payrollPeriod: PayrollPeriod)

// Employee被定义为积类型，它组合的Income具有不同的抽象
case class Employee(number: String, name: String, onboardingDate: Date, income: Income)
```



在定义了以上由代数数据类型组成的领域模型之后，即可将其与领域行为结合起来，例如计算每个雇员的收入。由于`Income`被定义为和类型，它表达的是一种逻辑或的关系，因此它的每个子类型（称为ADT变体）都将成为模式匹配的分支。和类型的组合有着确定的值（类型理论的术语将其称之为inhabitant），例如`Income`和类型的值为3，则模式匹配的分支就应该是3个，这就使得Scala编译器可以检查模式匹配的穷尽性。如果模式匹配缺少了对和类型的值表示，编译器都会给出警告。倘若和类型增加了一个新的值，编译器也会指出所有需要新增ADT变体来更新模式匹配的地方。针对`Income`积类型，可以利用模式匹配结合业务规则对它进行解构，代码如下所示：

```scala
def calculateIncome(employee: Employee): Amount = employee.income match {
  case WeeklySalary(fee, timeCards, _) => weeklyIncomeOf(fee, timeCards)
  case MonthlySalary(salary, _) => salary
  case Commision(salary, saleReceipts, _) => salary + commistionOf(saleReceipts)
}
```



`calculateIncome()`是一个纯函数，它利用模式匹配，针对`Employee`的特定`Income`类型计算雇员的不同收入。

## 纯函数


在函数范式中，往往使用纯函数（pure function）来表现领域行为。所谓“纯函数”，就是指没有副作用（side effects）的函数。《Scala函数式编程》认为常见的副作用包括：

+ 修改一个变量
+ 直接修改数据结构
+ 设置一个对象的成员
+ 抛出一个异常或以一个错误终止
+ 打印到终端或读取用户的输入
+ 读取或写入一个文件
+ 在屏幕上绘画



例如，读取花名册文件对内容进行解析获得收件人电子邮件列表的函数为：

```scala
def parse(rosterPath: String): List[Email] = {
    val lines = readLines(rosterPath)
    lines.filter(containsValidEmail(_)).map(toEmail(_))
}
```



代码中的`readLines()`函数需要读取一个外部的花名册文件，这是引起副作用的一个原因。该副作用为单元测试带来了影响。要测试`parse()`函数，就需要为它事先准备好一个花名册文件，增加了测试的复杂度。同时，该副作用使得我们无法根据输入参数推断函数的返回结果，因为读取文件可能出现一些未知的错误，如读取文件错误，又或者有其他人同时在修改该文件，就可能抛出异常或者返回一个不符合预期的邮件列表。



要将`parse()`定义为纯函数，就需要分离这种副作用，函数的计算结果就不会受到任何内部或外部过程状态改变的影响。一旦去掉副作用，调用函数返回的结果就与直接使用返回结果具有相同效果，二者可以互相替换，这称之为“引用透明（referential transparency）”。引用透明的替换性可以用于验证一个函数是否是纯函数。假设客户端要根据解析获得的电子邮件列表发送邮件，解析的花名册文件路径为`roster.txt`。假定解析该花名册得到的电子邮件列表为：

```scala
List(Email("liubei@dddcompany.com"), Email("guanyu@dddcompany.com"))
```



如果`parse()`是一个纯函数，就需要遵循引用透明的原则，则如下函数调用的行为应该完全相同：

```scala
// 调用解析方法
send(parse("roster.txt"))

// 直接调用解析结果
send(List(Email("liubei@dddcompany.com"), Email("guanyu@dddcompany.com")))
```



显然并非如此。后者传入的参数是一个电子邮件列表，而前者除了提供了电子邮件列表之外，还读取了花名册文件。函数获得的电子邮件列表不是由花名册文件路径决定的，而是由读取文件的内容决定。读取外部文件的这种副作用使得我们无法根据确定的输入参数推断出确定的计算结果。要将`parse()`改造为支持引用透明的纯函数，就需要分离副作用，即将产生副作用的读取外部文件功能推向`parse()`函数外部：

```scala
def parse(content: List[String]): List[Emial] = 
    content.filter(containsValidEmail(_)).map(toEmail(_))
```



现在，以下代码的行为就是完全相同的：

```scala
send(parse(List("liubei, liubei@dddcompany.com", "noname", "guanyu, guanyu@dddcompany.com")))

send(List(Email("liubei@dddcompany.com"), Email("guanyu@dddcompany.com")))
```



这意味着改进后的`parse()`可以根据输入结果推断出函数的计算结果，这正是引用透明的价值。**保持函数的引用透明，不产生任何副作用，是函数式编程的基本原则。**如果说面向对象设计需要将依赖尽可能向外推，最终采用依赖注入的方式来降低耦合；那么，函数式编程思想就是要利用纯函数来隔离变化与不变，内部由无副作用的纯函数组成，纯函数将副作用向外推，形成由不变的业务内核与可变的副作用外围组成的结构：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706588528734-eb891235-d079-4320-b68b-1dacbc304668.png)



具有引用透明特征的纯函数更加贴近数学中的函数概念：没有计算，只有转换。转换操作不会修改输入参数的值，只是基于某种规则把输入参数值转换为输出。输入值和输出值都是不变的（immutable），只要给定的输入值相同，总会给出相同的输出结果。例如我们定义`add1()`函数：

```scala
def add1(x: Int):Int => x + 1
```



基于数学函数的转换（transformation）特征，完全可以翻译为如下代码：

```scala
def add1(x: Int): Int => x match {
  case 0 => 1
  case 1 => 2
  case 2 => 3
  case 3 => 4
  // ...
}
```



我们看到的不是对变量x增加1，而是根据x的值进行模式匹配，然后基于业务规则返回确定的值。这就是纯函数的数学意义。



引用透明、无副作用以及数学函数的转换本质，为纯函数提供了模块化的能力，再结合高阶函数的特性，使纯函数具备了强大的组合（combinable）特性，而这正是函数式编程的核心原则。这种组合性如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706588528744-eed35aff-e191-49e8-ad16-85cf1ccb7700.png)



图中的`andThen`是Scala语言提供的组合子，它可以组合两个函数形成一个新的函数。Scala还提供了`compose`组合子，二者的区别在于组合函数的顺序不同。上图可以表现为如下Scala代码：

```scala
sealed trait Fruit {
  def weight: Int
}
case class Apple(weight: Int) extends Fruit
case class Pear(weight: Int) extends Fruit
case class Banana(weight: Int) extends Fruit

val appleToPear: Apple => Pear = apple => Pear(apple.weight)
val pearToBanana: Pear => Banana = pear => Banana(pear.weight)

// 使用组合
val appleToBanana = appleToPear andThen pearToBanana
```



组合后得到的函数类型，以及对该函数的调用如下所示：

```plain
scala> val appleToBanana = appleToPear andThen pearToBanana
appleToBanana: Apple => Banana = <function1>

scala> appleToBanana(Apple(15))
res0: Banana = Banana(15)
```



除了纯函数的组合性之外，函数式编程中的Monad模式也支持组合。我们可以简单地将一个Monad理解为提供bind功能的容器。在Scala语言中，bind功能就是`flatMap`函数。可以简单地将`flatMap`函数理解为是`map`与`flattern`的组合。例如，针对如下的编程语言列表：

```plain
scala> val l = List("scala", "java", "python", "go")
l: List[String] = List(scala, java, python, go)
```



对该列表执行map操作，对列表中的每个元素执行`toCharArray()`函数，就可以把一个字符串转换为同样是Monad的字符数组：

```plain
scala> l.map(lang => lang.toCharArray)
res7: List[Array[Char]] = List(Array(s, c, a, l, a), Array(j, a, v, a), Array(p, y, t, h, o, n), Array(g, o))
```



`map`函数完成了从`List[String]`到`List[Array[Char]]`的转换。对同一个列表执行相同的转换函数，但调用`flatMap`函数：

```plain
scala> l.flatMap(lang => lang.toCharArray)
res6: List[Char] = List(s, c, a, l, a, j, a, v, a, p, y, t, h, o, n, g, o)
```



`flatMap`函数将字符串转换为字符数组后，还执行了一次拍平操作，完成了`List[String]`到`List[Char]`的转换。



然而在Monad的真正实现中，`flatMap`并非`map`与`flattern`的组合，相反，`map`函数是`flatMap`基于unit演绎出来的。因此，Monad的核心其实是`flatMap`函数：

```scala
class M[A](value: A) { 
    private def unit[B] (value : B) = new M(value) 
    def map[B](f: A => B) : M[B] = flatMap {x => unit(f(x))} 
    def flatMap[B](f: A => M[B]) : M[B] = ... 
} 
```



`flatMap`和`map`以及`filter`往往可以组合起来，实现更加复杂的针对Monad的操作。一旦操作变得复杂，这种组合操作的可读性就会降低。例如，我们将两个同等大小列表中的元素项相乘，使用`flatMap`与`map`的代码为：

```scala
val ns = List(1, 2)
val os = List(4, 5)
val qs = ns.flatMap(n => os.map(o => n * o))
```



这样的代码并不好理解。为了提高代码的可读性，Scala提供了for-comprehaension。它本质上是Monad的语法糖，组合了flatMap、map与filter等函数；但从语法上看，却类似一个for循环，这就使得我们多了一种可读性更强的调用Monad的形式。同样的功能，使用for-comprehaension语法糖就变成了：

```scala
val qs = for {
    n <- ns
    o <- os
} yield n * o
```



这里演示的for语法糖看起来像是一个嵌套循环，分别从ns和os中取值，然后利用yield生成器将计算得到的积返回为一个列表；实质上，这段代码与使用`flatMap`和`map`的代码完全相同。



在使用纯函数表现领域行为时，我们可以让纯函数返回一个Monad容器，再通过for-comprehaension进行组合。这种方式既保证了代码对领域行为知识的体现，又能因为不变性避免状态变更带来的缺陷。同时，结合纯函数的组合子特性，使得代码的表现力更加强大，非常自然地传递了领域知识。例如，针对下订单场景，需要验证订单，并对验证后的订单进行计算。验证订单时，需要验证订单自身的合法性、客户状态以及库存；对订单的计算则包括计算订单的总金额、促销折扣与运费。



在对这样的需求进行领域建模时，我们需要先寻找到表达领域知识的各个原子元素，包括具体的代数数据类型和实现原子功能的纯函数：

```scala
// 积类型
case class Order(id: OrderId, customerId: CustomerId, desc: String, totalPrice: Amount, discount: Amount, shippingFee: Amount, orderItems: List[OrderItem])

// 以下是验证订单的行为，皆为原子的纯函数，并返回scalaz定义的Validation Monad
val validateOrder : Order => Validation[Order, Boolean] = order =>
    if (order.orderItems isEmpty) Failure(s"Validation failed for order $order.id") 
    else Success(true)

val checkCustomerStatus: Order => Validation[Order, Boolean] = order => 
    Success(true)

val checkInventory: Order => Validation[Order, Boolean] = order => 
    Success(true)

// 以下定义了计算订单的行为，皆为原子的纯函数
val calculateTotalPrice: Order => Order = order => 
    val total = totalPriceOf(order)
    order.copy(totalPrice = total)

val calculateDiscount: Order => Order = order => 
    order.copy(discount = discountOf(order))

val calculateShippingFee: Order => Order = order =>
    order.copy(shippingFee = shippingFeeOf(order))
```



这些纯函数是原子的、分散的、可组合的，接下来就可以利用纯函数与Monad的组合能力，编写满足业务场景需求的实现代码：

```scala
val order = ...

// 组合验证逻辑
// 注意返回的orderValidated也是一个Validation Monad
val orderValidated = for {
    _ <- validateOrder(order)
    _ <- checkCustomerStatus(order)
    c <- checkInventory(order)
} yield c

if (orderValidated.isSuccess) {
    // 组合计算逻辑，返回了一个组合后的函数
    val calculate = calculateTotalPrice andThen calculateDiscount andThen calculateShippingFee
    // 返回具有订单总价、折扣与运费的订单对象
    // 在计算订单的过程中，订单对象是不变的
    val calculatedOrder = calculate(order)

    // ...
}
```

## 函数范式与领域模型


遵循函数范式建立领域模型时，代数数据类型与纯函数是主要的建模元素。代数数据类型中的和类型与积类型可以表达领域概念，纯函数则用于表达领域行为。它们都被定义为不变的原子类型，然后再将这些原子的类型与操作组合起来，满足复杂业务逻辑的需要。这是函数式编程中面向组合子（combinator）的建模方法，它与面向对象的建模方法存在思想上的不同。



面向对象的建模方法是一种**归纳法**，通过分析和归纳需求，找到问题域并逐级分解问题，然后通过对象来表达领域逻辑，并以职责的角度分析这些领域逻辑，按照角色把职责分配给各自的对象，通过对象之间的协作实现复杂的领域行为。面向组合子的建模方法则是一种**演绎法**，通过在领域需求中寻找和定义最基本的原子操作，然后根据基本的组合规则将这些原子类型与原子函数组合起来。



因此，函数范式对领域建模的影响是全方位的，它与对象范式看待世界的角度迥然不同。对象范式是在定义一个完整的世界，然后以上帝的身份去规划各自行使职责的对象；函数范式是在组合一个完整的世界，它就像古代哲学家一般，看透了物质的本原而识别出不可再分的原子微粒，然后再按照期望的方式组合这些微粒来创造世界。故而，采用函数范式进行领域建模，关键是组合子包括组合规则的设计，既要简单，又要完整，还需要保证每个组合子的正交性，如此才能对其进行组合，互不冗余，互不干涉。这些组合子，就是前面介绍的代数数据类型和纯函数。



通过前面给出的案例，我们发现函数范式的领域模型颠覆了面向对象思想中“贫血模型是坏的”这一观点。事实上，函数范式的贫血模型不同于结构范式和对象范式的贫血模型。结构范式是将过程与数据分离，这些过程实现的是一个完整的业务场景，由于缺乏完整的封装性，因而无法控制对过程与数据的修改对其他调用者带来的影响。对象范式要求将数据与行为封装在一起，就是为了解决这一问题。函数范式虽然建立的是贫血模型，但它的模块化、抽象化与可组合特征降低了变化带来的影响。在组合这些组合子时，通过引入高内聚松耦合的模块对这些功能进行分组，就能避免细粒度的组合子过于散乱，形成更加清晰的代码层次。



Debasish Ghosh总结了函数范式的基本原则，用以建立更好的领域模型：

+ 利用函数组合的力量，用小函数组装成一个大函数，获得更好的组合性。
+ 纯粹，领域模型的很多部分都由引用透明的表达式组成。
+ 通过方程式推导，可以很容易地推导和验证领域行为。



不止如此，根据代数数据类型的不变性以及对模式匹配的支持，它还天生适合表达领域事件。例如地址变更事件，就可以用一个积类型来表示：

```java
case class AddressChanged(eventId: EventId, customerId: CustomerId, oldAddress: Address, newAddress: Address, occurred: Time)
```



我们还可以用和类型对事件进行抽象，这样就可以在处理事件时运用模式匹配：

```java
sealed trait Event {
    def eventId: EventId
    def occurred: Time
}

case class AddressChanged(eventId: EventId, customerId: CustomerId, oldAddress: Address, newAddress: Address, occurred: Time) extends Event
case class AccountOpened(eventId: EventId, Account: Account, occurred: Time) extends Event

def handle(event: Event) = event match {
    case ac: AddressChanged => ...
    case ao: AccountOpened => ...
}
```



函数范式中的代数数据类型仍然可以用来表示实体和值对象，但它们都是不变的，二者的区别主要在于是否需要定义唯一标识符。聚合的概念仍然存在，如果使用Scala语言，往往会为聚合定义满足角色特征的trait，这样就可以使得聚合的实现通过混入多个trait来完成代数数据类型的组合。由于资源库（Repository）会与外部资源进行协作，意味着它会产生副作用，因此遵循函数式编程思想，往往会将其推向纯函数的外部。在函数式语言中，可以利用柯里化（Currying，又译作咖喱化）或者Reader Monad来推迟对资源库具体实现的注入。



主流的领域驱动设计往往以对象范式作为建模范式，利用函数范式建立的领域模型多多少少显得有点“另类”，因此我将其称之为非主流的领域驱动设计。这里所谓的“非主流”，仅仅是从建模范式的普及性角度来考虑的，并不能说明二者的优劣与高下之分。事实上，函数范式可以很好地与事件驱动架构结合在一起，这是一种**以领域事件作为模型驱动设计的驱动力**思想。针对事件进行建模，则任何业务流程皆可用状态机来表达。状态的迁移，就是命令（command）或者决策（decision）对事件的触发。我们还可以利用事件风暴（Event Storming）帮助我们识别这些事件，而事件的不变性特征又可以很好地与函数式编程结合起来。



如果采用命令查询职责分离（CQRS）模式，那么在命令端，将由命令与事件组成一系列异步的非阻塞消息流。这种对消息的认识，恰好可以与响应式编程（Reactive Programming）结合起来。诸如ReactiveX这样的响应式编程框架在参考了迭代器模式与观察者模式的基础上，结合了函数式编程思想，以事件处理的形式实现了异步非阻塞处理，在满足系统架构灵活性与伸缩性的同时，提高了事件处理的响应能力。



显然，围绕着不变的事件为中心，包括响应式编程、事件风暴、事件溯源与命令查询职责分离模式都可以与函数范式有效地结合起来，形成一种事件模型驱动设计(Event Model Driven Design, EDDD)方法。与事件驱动架构不同，事件模型驱动设计可以算是领域驱动设计的一种分支。作为一种设计方法学，它的实践与模式同样涵盖了战略设计与战术设计等多个层次，且可以与领域驱动设计的模式如限界上下文、领域事件、领域服务等结合起来。在金融、通信等少数领域，已经开始了对这种建立在函数范式基础之上的领域驱动设计的尝试，与它们相关的知识可以写成厚厚的一本大书，在这里就不再赘述了。

# ZenUML与服务驱动设计
在《[解构领域驱动设计](https://item.jd.com/10035002181202.html)》书中的领域建模阶段，我提出了以**业务服务**为核心进行设计与建模的方法——**服务驱动设计**。通过该方法可以在静态的领域设计模型基础之上，以业务服务规约为基础，通过分析需求，对业务服务进行任务分解，获得以子任务构成的任务树。这棵树以业务服务为根，组合任务为枝，原子任务为叶，既体现了业务服务的执行过程，又进行了适度的封装，建立了一定的封装层次。



一旦获得了子任务树，即可对树中的每一个子任务进行职责分配，根据其特点分别分配给远程服务、本地服务、领域服务、聚合、端口。它们是构成限界上下文的主要对象角色，我将其称之为“角色构造型”，可以和我提出的**菱形对称架构**结合：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1705722670038-b57e4b0a-158c-4c7c-b382-01d78d5b36a8.png)

分配的过程可以呈现为序列图，作为动态的领域设计模型，它与静态的领域设计模型共同组成领域设计模型。然则，绘制序列图总是不太方便，于是，我提出了编写序列图脚本的方法。以提交订单业务服务为例，分解获得的子任务树为：

![](http://zhangyi.xyz/service-driven-design-and-zenuml/task-tree.jpg)



根据职责分配的规则，业务服务分配给远程服务与本地服务，组合任务分配给领域服务，原子任务分配给聚合或端口，就可以编写出如下的序列图脚本：

```java
OrderController.placeOrder(placingOrderRequest) {  // 业务服务对应远程服务
    OrderAppService.placeOrder(placingOrderRequest) {//应用服务的方法体现服务价值
        OrderService.placeOrder(order) { // 领域服务对应组合任务，避免领域逻辑泄露到应用服务
            OrderService.validate(order) { // 领域服务对应组合任务
                Order.validate();   // 聚合承担原子任务
                InventoryCheckingClient.check(order); // 客户端端口指向库存上下文的边界服务
            }
            OrderRepository.save(order); // 资源库端口操作订单数据表
            ShoppingCartService.removeItems(customerId,cartItems) { // 领域服务对应组合任务
                ShoppingCartRepository.cartOf(customerId); // 资源库端口操作购物车数据表
                ShoppingCart.removeItems(cartItems);  // 聚合承担原子任务
                ShoppingCartRepository.save(shoppingCart); // 资源库端口操作购物车数据表
            }
        }
        OrderPlacedPublisher.publish(orderPlacedEvent); // 发布者端口发布订单已提交的应用事件
    }
}
```



序列图脚本的创意并非我的创举，而是[ZenUML](https://zenuml.com/)给予我的启发。我还在ThoughtWorks的时候，我的Sponser肖鹏正在打磨这个工具。我们二人都认同UML的序列图对于领域建模与设计颇有助力。一方面，序列图这一可视化方式可以提供给设计者一些特征，用于甄别设计的坏味道；另一方面，绘制序列图时，是由外向内逐层递进的，可以更好地站在调用者的角度去思考设计，消息的定义也会产生一种驱动力。我在为GitChat编写领域驱动设计课程时，就想到了这一工具，它提供的脚本语法非常接近Java语法，于是，我就采用拿来主义，将其搬到我的文章里，在融入业务服务、菱形对称架构、角色构造型后，组成了服务驱动设计，其完整过程如下图所示：

![](http://zhangyi.xyz/service-driven-design-and-zenuml/sdd.jpg)



在《解构领域驱动设计》一书即将出版前，我准备修改[针对菱形对称架构提供的一个案例](https://gitee.com/agiledon/diamond)，预备在代码库中增加提交订单的序列图脚本。忽然想起之前与肖鹏交流时，他曾提及ZenUML已经为IntelliJ IDEA开发了插件。果然在Settings -> Plugins中找到了ZenUML的插件：

![](http://zhangyi.xyz/service-driven-design-and-zenuml/zenuml-plugin.png)



它的使用方式非常简单，在安装了该插件后，你可以在代码库的任意位置（建议在项目根目录下定义一个文件夹），新建一个扩展名为`.zen`的文件，然后在文件内根据语法编写序列图脚本，工具就可以自动生成序列图了：

![](http://zhangyi.xyz/service-driven-design-and-zenuml/zenuml-script-sequence.png)



在上图右上方的View工具栏上，还可以切换视图类型，从左到右依次为：

+ 仅显示编辑器：此时只会显示时序图脚本
+ 显示编辑器和预览：如上图所示，同时显示时序图脚本和预览的时序图效果
+ 仅显示预览：此时只会显示序列图
+ 在浏览器中打开



如果将ZenUML工具运用到服务驱动设计方法中，即可在领域设计建模阶段尝试通过IDE建模，分析需求后，尝试编写序列图脚本，然后对照生成的序列图对脚本进行调整。调整的成本很低，完全可以随时修订。一旦确定了最终的序列图，即可按照测试驱动开发的流程，优先为聚合承担的原子任务和组合任务编写测试用例，通过测试驱动出该业务服务的实现代码。



ZenUML的功能当然不限于此，在驱动出最终的实现代码后，也可以将真实代码转换为序列图。例如在IntelliJ IDEA中，打开已经实现好的远程服务类`OrderController`，将光标移到要生成序列图的方法体内，右键弹出快捷菜单，即可看到如下的菜单项：

![](http://zhangyi.xyz/service-driven-design-and-zenuml/zenuml-menu.png)



选择该菜单项，就会自动生成序列图脚本与对应的序列图，生成的文件为`buffer{n}.zen`：

![](http://zhangyi.xyz/service-driven-design-and-zenuml/zenuml-generated.png)



如果你不喜欢它默认提供的呈现样式，也可以到Languages & Frameworks中找到ZenUML，添加CSS规则，以改变呈现样式：

![](http://zhangyi.xyz/service-driven-design-and-zenuml/zenuml-css.jpg)



ZenUml除了[Web APP](https://app.zenuml.com/)之外，还提供了[Confluence插件](https://marketplace.atlassian.com/apps/1218380/zenuml-sequence-diagram)，以便于我们编写设计文档。不出意料之外，它也为主流的浏览器提供了扩展，例如，在Microsoft Edge浏览器中可找到ZenUML Sequence扩展，安装后，工具栏会出现它的图标，打开，即可输入序列图脚本生成序列图：

![](http://zhangyi.xyz/service-driven-design-and-zenuml/zenuml-explorer.png)



真的是太方便了！ZenUML简直就是为服务驱动设计量身定做的。至于该怎么实践服务驱动设计，在《解构领域驱动设计》书中你可以找到答案。该如何使用ZenUML？那就太简单了，它的脚本语法基本和Java相同，使用也非常简单，无论是通过浏览器还是IDE，实际去使用一下，很快就能理解它的价值。



如果你的开发流程和开发工具中需要序列图，也可以直接在系统中把ZenUML作为一个前端库进行集成。目前已经有多家企业在自己的构建流程中集成了ZenUML。某国内企业在构建过程中使用ZenUML在文档中嵌入序列图；某国外企业则开发了Python转ZenUML工具，从代码直接生成序列图。ZenUML的文本转序列图的功能以免费的形式发布在[npm](https://www.npmjs.com/package/vue-sequence)上面。ZenUML开发者提供（有限的）免费技术支持。



2021年8月15日

# DDD的基础设施到底在哪里
Eric Evans对常见的三层架构做了优化，形成专属DDD的分层架构，如下图所示：

![](https://cdn.nlark.com/yuque/0/2022/png/859018/1663921201376-5b409f42-835c-4b14-9a81-8b8c8639ab1b.png)

Eric对基础设施层（Infrastructure Layer）的定义为：“为上面各层提供通用的技术能力：为应用层传递消息，为领域层提供持久化机制，为用户界面层绘制屏幕组件，等等。基础设施层还能够通过架构框架来支持4个层次间的交互模式。”

从DDD的分层架构看，领域层对基础设施层产生了依赖，这违背了依赖倒置原则：上层模块不应该依赖于下层模块，而应该依赖于下层模块的抽象。所以，Vernon在《实现领域驱动设计》中，将上图所示的分层架构修改为下图的结构：

![](https://cdn.nlark.com/yuque/0/2022/png/859018/1663921758611-770d5df9-5af5-48c0-9ed6-aeca488a72c9.png)

基础设施层挪到了最上面，领域层没有任何依赖，就能让领域层更加纯粹，不再受到外界变化的影响。然而，事与愿违，领域层依旧有必须依赖基础设施层的理由，例如，领域层的领域服务就必然需要访问数据库，这一功能属于基础设施层的职责。

该如何处理领域层与基础设施层的关系？Eric的解决方式是引入Repository模式。他选择将Repository的接口放到领域层，实现放到基础设施层。如此一来，领域服务对Repository接口的调用就属于同层之间的依赖，而实现则交给了依赖注入，由其在运行时将实现逻辑绑定到领域服务，如此就解除了领域层与基础设施层的耦合。

如果将Repository对领域对象的操作视为对对象集合的操作，将Repository放到领域层也就顺理成章了。可是对于一个业务系统而言，领域层不仅仅需要访问数据库，如果需要访问消息队列传递消息呢，需要访问文件呢，需要网络通信呢？难道要将所有访问外部资源的接口都归属到领域层吗？这明显不合理。

Eric提出分层架构的主要目的是为了分离领域层，实现业务和技术的正交。实现该目标的最佳途经莫过于分离基础设施层的接口与实现，如此也恰好满足依赖倒置原则。菱形对称架构的南向网关之所以分为端口和适配器，原因就在此。

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1705378190542-576af1f6-f933-4911-8413-c349495e32b1.png)

逻辑上，端口和领域层彼此分离，但由于二者存在双向依赖，在物理上，需要它们部署在一起。而适配器和端口则可以分开，以满足接口与实现分离的设计要求。

按照Eric对基础设施层的定义，北向网关的远程服务也属于基础设施的一种。分层架构的应用层对应于北向网关的本地服务层。菱形对称模式彻底改变了DDD分层架构的定义，更接近整洁架构和六边形架构，属于内外分层的表现形式。

菱形对称架构也可体现为分层架构形式：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1705378233660-bfbf5f38-6aa0-47e3-b213-6577563e6a73.png)

菱形对称架构是为DDD的限界上下文量身定做。由于限界上下文是业务能力的纵向切分，在其边界内，不仅包含领域层，也包含了网关层，甚至其逻辑边界还包含它要访问的数据库。若回到基础设施的语义，也就认为限界上下文包含基础设施层。

倘若基础设施只为当前限界上下文服务也就罢了，一旦有别的限界上下文也需要调用，又该如何处理？

在讨论此问题之前，有必要明确DDD的基础设施层究竟包含哪些内容。注意，DDD的基础设施并不等同于云计算IaaS层对应的基础设施，它是一种隐喻，代表了支撑领域逻辑的基础功能，同样由当前开发团队编码实现，通常用于封装对外部资源的访问。

常见的外部资源包括：

+ 数据库
+ 缓存
+ 设备
+ 外部接口
+ 消息队列

由于访问基础设施的调用者是领域层，因此，不要将操作外部资源的框架与其混为一谈。这一定义与Eric对基础设施层的定义略有不同，但我认为才是正解。

以订单上下文为例。南向网关访问数据库的基础设施可以是`OrderRepository`端口和适配器，但它显然不是Hibernate或MyBatis这样的ORM框架；访问Kafka的基础设施可以是`OrderPlacedPublisher`端口和适配器，而不是spring-kafka框架；至于对上游限界上下文的访问，更是如此，不必多说。

弄清楚二者的区别，就可以深刻理解到：一个限界上下文内部的基础设施，往往带有当前限界上下文的业务含义，是相对专有的，实际上，很少存在跨限界上下文复用的可能。

一种特殊场景是Context Map的防腐层模式，它在菱形对称架构中体现为Client端口，用于封装对上游限界上下文或伴生系统外部接口的访问。如果上游限界上下文的北向网关服务会被多个下游访问，又需要引入防腐层隔离上游的变化，就存在多个限界上下文防腐层实现的重复。

为避免重复，常见的做法是将该防腐层升级为一个专有的限界上下文。一个典型例子是支付限界上下文。在电商系统中，支付系统属于目标系统之外的伴生系统。支付订单、发起退款，缴纳会员费等多个业务场景都需要调用支付系统。如果分别为其实现防腐层，就会在订单上下文、售后上下文与会员上下文中，散落着重复的支付适配逻辑，解决办法就是专门为其定义一个支付上下文。

我曾提到过，对于一个规模相对较大的目标系统而言，架构要考虑两个层次：

+ 系统上下文
+ 限界上下文

目前，限界上下文的基础设施问题已经给予澄清，那么，在系统层次，又该如何考虑？

由于限界上下文是业务能力的纵向切分，一个自治的限界上下文，就必须包含它所需要的完整的内容，如果将每个限界上下文都看做是一个独立的子系统，在系统层次似乎就没有基础设施的必要了。

我正是这般认为的，但恐怕一些人并不怎么认为。之所以存在分歧，是因为我们对基础设施的定义并未达成一致。

譬如说，有人认为，用户管理、组织管理与权限认证属于整个系统的基础设施；我却认为它们应该属于映射到通用子领域的限界上下文，在系统分层架构中，位于分层架构的公共基础层：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1705378411211-460cb112-c798-434f-becb-eb019a2391c3.png)

又有人认为，诸如Spring Cloud、Hibernate、Seata、Dubbo之类的框架属于整个系统都需要的基础设施，故而需要定义专门的基础设施层。如前所述，我认为它们并非DDD分层架构的基础设施层。

这里牵涉到对架构视图的理解。无论是DDD分层架构，还是我提出的系统分层架构与菱形对称架构，都属于应用逻辑架构的一部分。系统需要使用的框架根本就不在应用架构的范围内。如果要在架构中体现它们，应该放到技术架构。若要了解架构视图的详细内容，可以参考阅读我的系列文章《全面探索架构视图》。

最后，呼应标题。

DDD分层架构的基础设施并非技术架构中的框架或平台，而是限界上下文领域层需要调用的端口或适配器，它们位于限界上下文内部的南向网关，又或者基于复用的必要，被抽离出来形成单独的限界上下文。为避免与云平台或其他基础架构提及的基础设施混淆，我建议慎用这一术语。若要使用，需先明确其真正的含义，了解它包含的实际内容。



2022年9月24日

# 对CQRS的基础理解
CQRS由Greg Young提出，目前在DDD领域中被广泛使用。在我看来，它甚至可以被称为是一种架构风格，可以取得与MapReduce，REST同等的地位，对软件系统的整体架构产生重要影响。



CQRS即Command Query Responsibility Seperation（命令查询职责分离），其设计思想来源于Mayer提出的CQS（Command Query Seperation）。这种命令与查询的分离方式，可以更好地控制请求者的操作。查询操作不会造成数据的修改，因而它属于一种幂等操作，可以反复地发起，而不用担心会对系统造成影响。基于这种特性，我们还可以为其提供缓存，从而改进查询的性能。命令操作则与之相反，它会直接影响系统信息的改变。查询操作与命令操作对事务的要求也不一样。由于查询操作不会改变系统状态，因而，不会产生最终的数据不一致。从请求响应的角度来看，查询操作常常需要同步请求，实时返回结果；命令操作则不然，因为我们并不期待命令操作必须返回结果，这就可以采用fire-and-forget方式，而这种方式正是运用异步操作的前提。此外，对于大多数软件系统而言，查询操作发起的频率通常要远远高于命令操作。如上种种，都是将命令与查询进行分离的根本原因。



这就很好地阐释了我们为何需要运用CQRS模式，同时也说明了CQRS的适用场景。



只要充分理解了运用CQRS模式的意图，理解CQRS模式就变得容易了许多。下图是CQRS框架[AxonFramework](http://www.axonframework.org/)官方文档给出的CQRS架构图。 

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1705457743218-83082186-d0bf-4618-a1df-7bd9630977a4.png)



在这个架构图中，最核心的概念是Command、Event。以我的理解，CQRS模式的风格源头就是基于事件的异步状态机模型。抛开命令查询分离这一核心原则，这才是CQRS的基础内容。CQRS对设计者的影响，是将领域逻辑，尤其是业务流程，皆看做是一种领域对象状态迁移的过程。这一点与REST将HTTP应用协议看做是应用状态迁移的引擎，有着异曲同工之妙。这种观点（或设计视图）引出了Command与Event的概念。Command是系统中会引起状态变化的活动，通常是一种命令语气，例如注册会议RegisterToConference。至于Event，则描述了某种事件的发生，通常是命令的结果（但并不一定是直接结果，但源头一定是因为发送了命令），例如OrderConfirmed。我发现，这种事件更接近于一种事实，即某次数据改变的结果，是一种确定无疑已经发生的事实。这一思想直接引入了Event Source，并带来Audit（审计）的好处。而它更是与[Datomic数据库](http://www.datomic.com/)的设计哲学一脉相承。Datomic的设计哲学就是：“将数据(Data)看做是事实(Fact)。每个事实都是过去的痕迹，虽然这种过去可以遗忘，但却无法改变。”Event Source可以将这些事件的发生过程记录下来，使得我们可以追溯业务流程。 



Command和Event都有对应的Handler来处理。它们具有一个共同的特征，即支持异步处理方式。这也是为何在架构中需要引入Command Bus和Event Bus的原因。在UI端执行命令请求，事实上就是将命令（注意，这是一个命令对象，你完全将其理解为Command模式的运用。注意，命令的命名一定要恰如其分地体现业务的意图）发送到Command Bus中。Command Bus更像是一个调停者（Mediator），在接收到Command时，会将其路由到准确的CommandHandler，由CommandHandler来处理该命令。在Axon Framework中，Command Bus提供了dispatch()方法对命令进行分发。也就是说，在它的实现中，并没有对Command提供异步处理，而仅仅是完成路由的功能。不过，在我自己的框架实现中，我却将Command Bus看做是消息通道，而将Command Handler看做是该消息通道的侦听者。因此，我引入了队列来实现Command Bus。很难说明哪种方式更合理，这还要取决于业务模型。整体来看，后一个方案似乎有些重型了。不过，我现在并未引入消息队列，而是使用了Scala的Actor，从多线程的角度来实现CommandBus的异步模型，也可以说得过去。



Event的处理与之相似。Axon Framework同时支持同步和异步方式。从框架角度讲，提供更多的选择是一件好事。但基于CQRS模式的核心思想来看，如果对Command(包括Event)的处理未采用异步模型，它就没有发挥出足够的优势，此时采用CQRS，反而会增加设计难度，有些得不偿失。



在Command端，基本的处理流程是由UI发起命令请求，发送到CommandBus，并由它分发给对应的Command Handler来处理命令。Command Handler会与领域对象，特别是与Aggregation Root对象通信。在处理了相关的业务逻辑后，会触发Event。一方面，它会将Event放到Event Store中；另一方面，同时会将Event发送到Event Bus，再由Event Handler处理事件。根据Axon Framework的官方文档，Event Handler会负责更新数据源，从而保证查询端能够得到最新的数据。



然而，这一过程并不是这样简单。因为整个过程可能体现的是一个状态机。Command会导致状态的迁移，并在执行Aggregate的逻辑时，触发对应的Event。Event Handler在处理事件时，并不一定是这个业务过程的终点，它可能会发送引起下一个状态迁移的命令，从而形成一个不断迁移的过程，直至业务完全结束。这就需要我们在引入CQRS时，需要改变之前的设计思路，尽量从状态迁移的角度去理解业务逻辑。UML中的状态图是一个很好的分析工具。另外，它也带来一个挑战，就是事务。因为整个过程都涉及到数据状态的变化，当某个状态迁移出现问题时，要保证数据的最终结果是一致的。Axon Framework的解决方案是引入[Unit of Work模式](http://martinfowler.com/eaaCatalog/unitOfWork.html)。此外，在真正实现时，究竟是由Event Handler去更新数据源，还是交由Aggregate去完成，还有待考量。我倾向于由Aggregate委派给Repository来完成。从职责分配的角度来看，这种方式更为合理。因为与数据源打交道的逻辑绝对不能太过于分散，以免数据源的改变影响到整个领域层。在DDD中，持久逻辑都是被封装到Repository（在其内部，又会委派给基础设施层中提供数据访问的对象）。换言之，这种实践是符合DDD的设计思想的。

# 服务驱动设计案例实践
## 前言


### 缘起


在我写《解构领域驱动设计》一书时，真正确定“业务服务”名称，是在完成初次审稿的时候了。最初的名称叫“业务活动”，它是问题空间进行需求分析的基本业务单元。到了解空间，在进行领域设计建模时，我将其“改头换面”，称其为“服务场景”，由此有了“场景驱动设计”。



我认为这样的改头换面，会因为累积太多概念而让人茫然不知所措，在一次出行途中，我在脑海中揣摩这一套方法，灵光一闪，觉得可以将其统一命名为“业务服务”，并将其贯穿问题空间和解空间始终，形成一个完全围绕“业务服务”的整套设计过程，姑且可以称之为“**服务驱动设计**”。



编写业务服务时，需要遵循统一语言，并由领域专家和开发团队共同编写和维护，业务服务规约包含的就是领域知识，如此一来，所谓的“服务驱动设计”就完全属于**领域驱动设计**的范畴。



### 并非创新


之所以我要提出这个概念，并非要做什么“创新”，实则因为在Eric Evans的书中，压根就没有给出一个概念，以统一的格式体现领域知识。没有这样的概念，何谈领域驱动设计呢？



自然，需求的呈现方式业内已有成熟方案，例如用例，例如用户故事，例如特征，例如业务行为，例如测试用例。除了用户故事之外，这些呈现需求的方式实际上已经形成了对应的设计方案，即用例驱动设计（UDD）、特征驱动设计（FDD）、行为驱动设计（BDD）、测试驱动开发（TDD）。



它们与领域驱动设计一样，都是XDD家族的一员，但整个设计过程可以说是迥然不同（或许某些设计思想、设计理念与原则是相同的），各自形成了自己的一套设计方法体系与设计过程。



如果不为领域知识规定一套固定的形式，说起来，领域驱动设计就更能兼容并包，用例、用户故事、特征、业务行为、测试用例似乎都可以放到DDD这个“筐”中来。所以，这并非我引入“业务服务”的根本原因。我会在这个系列文章中细细道来。



### 这是一个系列


没错，这是一个系列文章。我期望利用一个相对完整的案例阐述整个服务驱动设计的过程。



服务驱动设计过程差不多是《解构领域驱动设计》中DDD参考过程模型的一个缩减版，全程围绕“业务服务”开展需求的分析、架构设计与建模。整体过程如下图所示：



![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakAXQXevG8gHHg7Q1K28FH1Ln48g2IlOetf6f1XKbyHN4wnB3kAVAYl4EJUaxGOoLZ1wmagcqlNRhQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



以业务服务为起点，通过业务服务识别限界上下文，同时，对业务服务进行细化，编写包含领域知识的业务服务规约。这属于领域驱动设计统一过程的全局分析阶段。



进入架构映射阶段。可以通过业务服务识别限界上下文，然后在限界上下文的基础上，通过业务服务规约绘制服务序列图，得到各个限界上下文的服务契约，包括服务契约的定义，确定上下文映射关系。由此进入领域建模阶段。



建模的起点仍然是业务服务。业务服务规约遵循了统一语言的原则表现领域知识，由此可以识别出领域概念，建立领域分析模型。在领域分析模型的基础上，通过识别实体、值对象，明确实体之间的关系，就可以设计出聚合，获得静态的领域设计模型。



服务契约属于菱形对称架构的北向网关，由菱形对称架构可以确定整个限界上下文的角色构造型，然后在静态领域设计模型和角色构造型的基础上绘制服务契约的序列图，获得以伪代码形式表现的序列图脚本。



最后，就可以根据业务服务规约中的验收标准识别出测试用例，开展测试驱动开发，逐步获得由产品代码和测试代码组成的领域实现模型。



这就是服务驱动设计的全过程！



### 技术部落案例


一个理想的DDD学习案例，需要具备以下特点：

+  没有业务知识的门槛，因为需要面对不同领域的读者 
+  系统复杂度不能太低，太低，就体现不出DDD的价值 
+  系统复杂度不能太高，太高，就很难通过系列文章完整体现 



我从Simon Brown的书《程序员必读之软件架构》(Software Architecture for Developers)中找到了一个符合以上条件的案例，即“技术部落”，有兴趣的同学可以在GitHub(或者Gitee)上搜索“techtribesje”，获得该案例的源代码。



简而言之，技术部落就是为IT人员打造的一个社交平台。



为了增加一定的复杂度，我对Simon的案例进行了调整。为方便理解，我为一些需求功能给出了模板产品作为参考。需求包括：

+  系统支持个人用户和企业用户 
+  每个用户都可以创建自己的部落，每个用户都可以申请称为部落的会员（类似知识星球） 
+  部落会员可以在部落中发表或分享文章 
+  部落会员可以在部落中提出问题或回答问题（类似知乎） 
+  部落会员可以在部落中组织线下活动（类似豆瓣） 
+  部落会员可以在部落中组织直播活动（类似抖音） 
+  个人用户可以发布求职信息，企业用户可以发布招聘信息（类似51Job） 



我承认这是一个大杂烩的杰出经典作品。但当我给出每个需求功能对应的Model产品时，大家是否有秒懂的感觉呢？显然，分析这样的项目，不会有业务的知识门槛。



Simon的案例给了我启发，但本系列文章却不会使用Simon书中的任何内容，也不会用到他提供的案例代码。我仅仅是披了“技术部落”这个外壳，内在做的是服务驱动设计的工作。



因为不是写书，所以本系列文章的内容会显得更为随意，其中，还会引入工作坊的部分成果，通过点评演练成果帮助读者更好的理解我所要讲述的知识点。



## 定义和识别业务服务


在我提出的领域驱动设计统一过程中，全局分析阶段主要输出的最小粒度需求分析单元就是业务服务，它在整个统一过程中扮演领域驱动力的关键角色。



那么，什么是业务服务呢？



### 业务服务的定义


我的书中是这样定义业务服务的：

> 它是角色主动向目标系统发起服务请求完成的一次完整的功能交互，体现了服务价值的业务行为。
>



该定义暗含了以下客观的判定标准：

+  服务请求必须是目标系统之外的角色发起的，角色包括用户、策略和伴生系统 
+  目标系统是一个黑盒子，因而其内部的交互细节是不可知的，整个功能交互是一个整体，就是一个独立的业务服务 



要注意的是，这里所谓“角色主动向目标系统发起服务请求”，实际是指角色向目标系统的后端发起请求，如此就可以将用户的UI操作隔离到业务服务之外。

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakA3o9MsZ498gLtPh7zRs12jOM86p9Mm1FjzYU7zT89F56LvyFTlC8qgGPfVOJ7se6Wpib4Std1wbwQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



虽说这一约束会让解决方案“入侵”到我们对问题的理解，但它带来的好处是不会混淆UI交互与业务行为。个人认为，DDD的限界上下文不会包含UI前端的内容，Eric Evans的著作也建议将UI与Domain隔离，更不用说在如今的架构中，前后端分离已经成为了必然选择。



定义中提到的角色包括三种：

+  用户（user）：是关心业务服务的人或组织（部门），通过执行某个操作触发服务请求，多数情况下，用户通过操作UI向后端发起服务请求。 
+  策略（policy）：是封装了业务规则的定时器，它就像一个小机器人，一旦满足业务规则就会主动触发，向目标系统发起服务请求。 
+  伴生系统（companion system）：属于目标系统之外的外部系统，并且是由该伴生系统向目标系统发起服务请求。 



定义中提到的“一次完整的功能交互”代表了业务服务执行的连续性。目标系统后端在收到角色发来的服务请求后，只要没有任何中断，这其间执行的任务都属于该业务服务的执行步骤，不能将其割裂开。至于是否存在中断，则需要结合具体的业务流程来判断。



描述业务服务时，通常采用动词短语来描述。可以认为业务服务是一种领域行为，属于领域知识的一部分，因此在描述时，需要遵循统一语言的原则。

### 一个小例子


再形象的文字描述，再简洁的术语定义，都不如给出实际例子让人更容易理解。



我们先牛刀小试一把，先看看一个最简单的例子。



我在机场想要蹭机场的Wifi，以便于节约我的流量，我选择加入机场免费Wifi时，系统弹出如下的界面：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704296945-4c424409-0db9-4fdd-b1b9-b5ec56095e45.png)



我们不考虑取号机的方式（因为我从来没有用过），只考虑如下流程：输入手机号，点击“获取验证码”，收到系统通过短信发送的验证码后，输入验证码，再勾选“我已阅读并接收《服务条款》”，点击“手机号登录”，通过认证后，我就可以免费使用机场的Wifi了。



按照我对业务服务的定义，这一流程包含几个业务服务呢？



答案——只有两个：

+  获取验证码 
+  登录 



诸如“输入手机号”、“输入验证码”、“勾选服务条款”等流程动作都是前端UI的操作，不是业务服务。“发送短信”属于目标系统黑盒内的执行细节，用户发起的请求是获取验证码，它的执行步骤包括：

+  验证手机号 
+  生成验证码 
+  发送短信 



业务服务包含执行步骤，而执行步骤不是一个完整的交互，不能识别为业务服务。



### 另一个例子


业务服务的识别并非一成不变，要视具体的业务流程而定，让我们看另外一个例子。



在文学平台中，用户希望申请成为驻站作者。他在平台上填好申请材料后，提交了材料。审批人在收到了申请人的申请材料，查询申请材料的信息后，完成审批。



根据这一业务流程，在下面呈现的业务服务图中，究竟是左图正确，还是右图正确？

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704325472-6e653839-4b44-42b1-80f6-88efb098353c.png)



谁是正确答案？仔细想一想！



或许你答对了。右图展示的业务服务才是正解！为什么？左图展示的业务服务有如下错误：

+  申请人虽然要申请成为驻站作者，但他向目标系统发起的却是提交申请材料的服务请求，返回的结果为提交成功或失败。如果将其定义为“申请驻站作者”，返回的结果就应该是申请通过或拒绝，而这实际上是由审批人发起审批请求的结果。 
+  业务服务的描述不符合统一语言。不应该是“审核”，而是“审批”。在企业管理中，审核代表的是建议权或咨询权，审批代表的是管理权或决策权。 



现在，让我们修改一下流程。我们为平台增加一些智能要素，申请人在提交了申请材料后，系统会根据事先设定的规则直接判断申请材料是否合格，然后完成申请材料的审批。



——这一流程中的业务服务有哪些呢？



只有一个，就是“申请驻站作者”！答对了吗？好好思考一下！



继续修改流程。我们让平台降低一点智能，申请人在提交了申请材料后，系统并不会即刻完成审批，但也不需要人工审批，而是在规定时间由系统进行批量审批。如此一来，业务服务就变成了：

+  申请人——提交申请材料 
+  审批策略——批量审批申请材料 



执行第二个业务服务的角色是策略。



### 实战演练


了解什么是业务服务了吗？是骡子是马，拉出来遛遛，来一个实战演练吧！



以在12306购火车票的流程为例，我们一起来识别购票流程中到底有多少业务服务。虽然流程稍显复杂，但是，如果读者能根据此案例进行实战演练，相信会有所收获。



要求识别出给定流程中的所有业务服务。业务服务的形式：角色+业务服务名称。其中，业务服务名称为动词短语。



购票流程开始。首先查看从成都到重庆的车票：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704415273-709804ab-f56e-4d9f-9f53-cc79331d1ff8.png)



查询获得的信息如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704433161-34e8fac5-3920-413b-bca9-c9b8a7639845.png)



选择其中一个班次，准备购票：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704449954-ff03942d-5610-4ae5-b06b-ad1051c7bdac.png)

选择乘车人：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704467385-f864c1d5-d8c8-4d7b-b39e-47abf9d4c31e.png)



从乘车人列表中选择乘车人，并选定座位：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704483945-4b4bdf37-93f2-4842-b7d7-41ed63f74a03.png)



提交订单。系统进行倒计时，要求在规定的30分钟内完成支付，否则就会取消订单：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704498472-0a51b90e-ec6f-4ead-a916-232b149618e2.png)



如果取消订单，系统会提示一天最多只能取消3次。如果点击“确定取消”，就会取消订单。

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704515549-1e369ba1-4d8e-4894-ab51-d90e75bd0b38.png)



如果选择支付，则需要选择支付渠道，然后提交支付：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704532250-d6db8db9-7c17-408c-8ae2-649ebf1e762b.png)



系统提示正在支付：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704553656-76986ee4-9940-4098-a9e4-fd577c0a9aa8.png)





支付成功后，显示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704571247-4940c97b-2406-4834-8ab6-d0fc2f834929.png)



支付成功后，可以查看订单信息：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706704588021-dac43b30-686b-446e-bc8f-1eabbb07235d.png)



整个流程到此结束。

### 识别业务服务的注意事项


业务服务的定义提供了相对客观的标准，可以帮助我们在没有歧义和争议下确定业务服务的粒度。



识别业务服务，需要注意：

+  不要将UI操作错认为业务服务 
+  不要将业务服务内部的执行步骤错认为业务服务 



#### 统一语言的作用


业务服务是对问题空间的描述，需要遵循统一语言，正确而一致地传递领域概念。显然，“用户”这一领域概念不足以准确地表达购票这一业务流程。



注意，业务服务的编写质量，会直接影响到领域建模的质量。



除了用户，供选择的对应领域概念包括：

+  旅客 
+  乘车人 
+  乘客 
+  购票人 
+  购票者 



从中可以看出统一语言的重要性。不同人根据自己对业务需求的理解，会给出不同的名称，如果含义相同，则需要明确一个统一的名称。当然，还需要确定对应的英文概念。



显然，旅客、乘客、乘车人表达了相同的概念，对应的英文都可以翻译为Passenger。购票人和购票者只是表达形式不同而已，也是同一个概念，可翻译为Buyer。



哪一个名称更合理？在当前这个业务场景下，Buyer显然要优于Passenger。如果你去咨询领域专家，领域专家一定会告诉你：购票的人不一定是乘客。



#### 不要受UI操作的影响
如果识别出如下业务服务：

+  选择车次、座位类型 
+  选择具体座位 



从其描述看，明显可知这些所谓的“业务服务”实则是用户在UI上执行的操作，按照业务服务的定义，不应包含在内。我个人建议，针对UI操作，最好在业务流程和UI原型图中去体现。



#### 对策略的理解


倘若识别出的业务服务列表中包含了：

+  查询策略+校验查询请求条件 
+  条件策略+组合条件匹配 
+  查询策略+校验乘客信息 
+  购票策略+扣减库存 



这是对策略定义理解错误导致的结果。



我定义的“策略”角色，可以理解为是封装了业务规则的定时器，它在条件满足时会自动触发，然后“**主动**”向目标系统发起服务请求。这也是我为何要借鉴事件风暴的“策略”概念，而不名以“系统”的原因——因为系统无处不在，策略却拥有“自我意识”，能够主动发起请求。



以“校验查询请求条件”为例，实际上它并非所谓的“查询策略”主动发起请求，而是购票人发起查询火车车次请求，目标系统在收到该请求后，执行的校验操作，它是被动的，该操作也不是“一次完整的功能交互”，而是属于“查询火车车次”业务服务内部的一个执行步骤。



目标系统是一个黑盒子，业务服务是站在目标系统之外来看待角色与目标系统的交互。因此，千万不要将执行步骤与业务服务混为一谈。



还有可能识别出如下业务服务：

+ 订单策略：监控订单有效时间



这同样误解了策略的含义。作为封装了业务规则的定时器，策略实际上已经具备了监控订单有效时间的职责，因而无需将这一职责单独识别为业务服务。



#### 注意现实世界的影响


许多人有可能识别出“查询车票”这一业务服务。实际上，该业务服务的命名受到了UI的影响，毕竟在UI上，按钮的名称就是“购买车票”。



我们要注意不要陷入“现实世界”的误区，在现实世界中描述的概念，不一定是正确合理的领域概念。购票人之所以使用12306 APP，其目的就是购买车票，所以在设计UI的呈现信息时，自然以考虑用户的体验为主。在查询时，自然也就命名为“查询车票”，但实际上，执行的并非对车票的查询，而是对列车班次的查询。真正准确的“车票”概念，是订单中为每一位乘客分配的乘车凭证。



有人会使用“车次”概念，或者“班次”概念。我不能给出正确答案，但必须注意这里实际有两个概念需要澄清：

+  从始发站到终点站这样一条完整的火车车次，究竟应该描述为什么概念？ 
+  从购票人选择的起点车站到终点车站，这些车站可能是始发站、终点站，也可能是过站，查询得到的班次信息，又该描述为什么概念？ 



以D1817动车为例，其始发站与终点站分别为成都东和广州南站，它表达的应该是车次概念。而购票人选择的车站（城市）信息为成都到重庆，也就是从成都东到重庆西，它只是整个车次的其中一段。完整车次和部分车次实际上是有区别的。例子中真正要查询的，其实是符合查询条件的部分车次信息。该用什么概念描述，以区分它和车次？——用班次吗？如果用班次，那就要清晰定义它和车次之间的差异（可能在一种特殊情形下，车次与班次重合）



与之相似，我们也要弄清楚订单、车票、座位与车次、班次的关系。这些知识点，同样牵涉到统一语言的运用。

#### 领域专家的重要性


有两个业务服务存疑，如果支付和出票是同步完成的，可以不需要出票策略，不过以自己的购票经验来看，支付成功和出票成功不是一定的，所以增加出票相关的业务服务。



如果支付完成后，即刻就会出票，那么出票就是其中一个执行步骤，二者可合并为一个业务服务，否则就需要分开。这充分证明了识别业务服务时，领域专家的重要性，也证明了开发团队需要和领域专家保持沟通的重要性！



**注意：**这里定义的目标系统是12306 APP，并非火车站自动售票的机器，因而将支付和出票设计为同步完成可能更合理一点。当然，如果要考虑应用服务器压力的问题，也可能调整为异步场景。



与之相似，在发起支付时，是否需要识别为这样的业务服务呢？

+  用户-发起支付 
+  外部支付系统-通知支付成功 
+  外部支付系统-通知支付失败 



确实需要取决于目标系统与支付系统的交互方式。如果在发起支付后，即刻返回，然后再等待支付系统的通知，那么这样的识别就是正确的，此时的支付系统就是我提到的”伴生系统“角色；否则就是一个业务服务，即“支付车费”。



不可否认，这里确实存在解决方案对问题空间的影响。但我认为，早一点甄别到这一问题，对于后期的设计与建模，其实是有好处的。即使采用用例形式，在深入用例的执行过程时，仍然面临相同的问题。



### 标准答案


显然，只要理解了业务服务的定义，在与领域专家进行了充分沟通后，对于识别出来的结果应该会较少分歧和争执吧！



基于两个前提：

+  支付与出票属于同步完成 
+  目标系统与支付系统的协作属于异步 



针对购票业务流程，我识别的业务服务包括：

+  购票人：查询站点 
+  购票人：查询班次 
+  购票人：查询乘车人（如果乘车人不存在，还需要增加“创建乘车人”业务服务） 
+  购票人：提交订单 
+  订单取消策略：取消订单 
+  购票人：取消订单 
+  购票人：查询支付渠道 
+  购票人：提交支付 
+  第三方支付系统：完成支付（这里假定支付失败为支付的失败场景，此外，出票会作为该业务服务的执行步骤） 
+  购票人：查询车票 



或许还可以识别出退票等业务服务。对于12306来说，当然有这些业务服务，不过，在我规定要识别的业务流程中，并没有包含退改签等业务，故而不包含在内。这就是为什么需要理清楚问题空间的重要性了！



## 业务服务的价值


### 为何引入业务服务


说回正题。对于需求分析，业界已经提出了不少有价值的方法，其中最广为人知的是用例和用户故事。前者是UDD（Use case Driven Design）的重要输入，也是UML的主要元素，后者由极限编程的缔造者Kent Beck提出，普遍用于敏捷软件开发的需求分析。



既然如此，我为何还要引入业务服务这一概念？两个因素：

+  用例和用户故事的层次和粒度难以确定，没有一个相对客观的标准 
+  从需求文档到设计和开发的转换成本过高 

#### 用例的问题


用例是有层次的。



用例（use case）是对一系列活动（包括活动变体）的描述；主体（subject）执行并产生可观察的有价值的结果，并将结果返回给参与者（actor）。如果将整个组织作为用例的主体，参与者就应该是组织外的角色，用例表现的就是该角色与组织之间的一次交互，此时的用例称为业务用例，代表了组织的本质价值；如果将目标系统作为用例的主体，参与者就变成了目标系统外的角色（人或者外部系统），此时的用例称为系统用例，表现的是角色与目标系统之间的一次交互，通过这种交互，参与者获得了目标系统提供的业务价值。如果再深入到用例层次，还可以体现高层用例和低层用例之间的包含关系与扩展关系，类似这样的包含用例和扩展用例作为子用例，可能只是主用例的一个执行步骤。



不同粒度的用例体现了不同的业务价值，当我们在谈论用例时，实际上需要明确用例的主体边界，恰恰对于这一点，并没有引起大多数需求分析人员的重视，交流中对用例的概念与粒度没有达成一致，从而产生各种标准不一的用例输出。



这并非用例的问题，但不可否认，它制造了正确理解用例的障碍。Cockburn就说：“编写者和读者经常把二者弄混，可能把系统行为放入业务用例中，也可能把业务操作归于系统用例。”



即便以系统用例而言，也因为目标不同而需建立不同的层次。Cockburn为其定义了三个层次：概要目标、用户目标与子功能。他分别用云朵/风筝、海平面、鱼/蛤给出各自层次的形象代表，下图是他给出的例子，来自他的著作《编写有效用例》。

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705111403-ab293040-9c0d-4ec9-9271-53c4f5d87c81.png)



这一分层的标准根据目标大小进行界定，我们可以将目标理解为用例对于Actor的价值。



即使各个层次的比喻非常生动而贴切，我们仍然无法就目标的大小或价值的高低做出一个相对客观的判断。



有兴趣的同学可以阅读Cockburn的这本经典著作，书中给出了大量的案例来区分不同目标的差异；然而就我的阅读体会来看，一方面为作者给出铁一般事实的案例而深深叹服，另一方面，在阅读完毕之后，回到自己要编写的用例时，仍有无从下手之叹。



究其原因，所谓分层的标准是一种跟着感觉走的经验之谈，而非一条条可以验证和检查的客观标准。例如Cockburn给出了如何测试海平面目标的原则：

+  由一个人，在一个地方，一次完成（2到20分钟）。 
+  执行者一完成操作，就可以愉快地离开。 
+  执行者（如果是雇员）在完成许多工作后可以要求加薪。 



这些原则显然不足以作为客观标准，教会我们如何确定用例的目标层次。即便Cockburn自己也说：“找出正确的目标层次是关于用例的一个最棘手的问题。”



#### 用户故事的问题


用户故事的划分有一个经典的INVEST原则。该原则由六个单词构成，分别为：

+  Independent：独立的 
+  Negotiable：可协商的 
+  Valuable：有价值的 
+  Estimable：可估算的 
+  Small：小的 
+  Testable：可测试的 



漂亮的原则！我发现那些漂亮的原则总是由多个单词构成，而每个单词的首字母又能组成一个漂亮的单词（玩的是什么英文把戏？）——例如UNIX哲学中著名的KISS原则，OO设计的SOLID原则，单元测试的FIRST原则，当然，还要加上这里的INVEST原则。



原则虽然漂亮，却不过是一句正确的漂亮话罢了。仔细理解这六个单词，你会发现它们都出于主观的判断。一旦缺乏客观的判断标准，就会陷入“凭经验”的泥坑中，团队成员也难以就需求的层次和粒度达成一致。



#### 需求文档的干扰


大多数软件企业对需求规格说明书都有较为标准的格式定义，然而格式却无法决定内容的质量。更何况，我们费心编写的需求规格说明书究竟是为谁撰写的呢？它对开发团队究竟产生了多少价值？



相较而言，用户故事未必形成非常严谨的需求文档，但敏捷提倡的交流与协作，可以让用户故事呈现的业务需求更好地传递给每一位开发人员。



无论用例，还是用户故事，它们都强调角色与目标系统之间的协作，却没有做进一步的规范和约束，使得许多需求分析人员在编写用例和用户故事时，往往会杂糅两个常见的干扰项：

+  线下流程 
+  UI界面操作 



以下文本来自《编写有效用例》中的案例，它是一个海平面用例，用例名为“通过网络购买股票”：

1．购买者选择通过万维网购买股票。

2．PAF从用户那里得到所用站点的名字（比如E*Trade，Schwab等）。

3．PAF与该站点建立网络连接，并保持控制权。

4．购买者在该站点上浏览并购买股票。

5．PAF截取站点的响应信息，并更新购买者的记录。

6．PAF向用户显示更新后的记录情况。



它清晰地呈现了用户通过网络购买股票的过程，但是开发人员却可能弄不清楚究竟有哪些操作过程才是目标系统需要考虑的，也弄不清楚这些操作过程有哪些是需要他实现的。在理清楚了这些过程与待实现任务的关系之后，他还要进一步思考，该定义多少服务API提供给前端开发人员，又该怎么提炼其中的领域概念，完成领域建模。



业务服务不会这样。因为我之所以定义该概念，本身是结合领域驱动设计提出的。



### 业务服务规约


我在[前面的文章](http://mp.weixin.qq.com/s?__biz=MzA4NTkwODkyMQ==&mid=2651257833&idx=1&sn=88ec32d237d98ad5b1a623eb567d39ef&chksm=8422973fb3551e298f9917d9ea12db779aea21df265db6a93dd759429abeec5c6b1fda0770a2&scene=21#wechat_redirect)提过：

> 所谓“角色主动向目标系统发起服务请求”，实际是指角色向目标系统的后端发起请求，如此就可以将用户的UI操作隔离到业务服务之外。
>



在领域驱动设计的背景下，业务服务是面向限界上下文的，为其编写的流程实际上是从限界上下文收到角色发送的服务请求后，需要依次执行的业务流程。



为了更好地阐述业务服务，我参考用例与用户故事的格式，给出了如下图所示的业务服务规约：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705244777-2e025320-d05f-49a3-8c18-48ef6ba76f27.png)



业务服务的名称采用动词短语形式，代表了一种领域行为，这一点和用例的要求一致。



对于业务服务的描述，我直接借用了描述用户故事的格式。一方面，这一格式要素直接涵盖了业务服务的角色与领域行为，另一方面还能促使编写人员思考它带来的服务价值。



我之引入触发事件，与业务服务的定义息息相关。该触发事件一定是由角色主动触发的，可以是用户点击UI的按钮，或者是策略满足了业务规则，又或伴生系统发起了对目标系统的调用。一旦触发了该事件，就会向限界上下文发起服务请求。



如此一来，对于业务服务的流程而言，一定是在收到服务请求之后开始执行的一系列连续的业务过程。因此，在业务服务的基本流程与替代流程中，根本不可能出现UI的操作，更不可能出现线下的流程。按照我的经验，业务服务执行流程的第一步，往往是对服务请求的验证。至于服务请求包含哪些内容，则可以认为是对应服务契约的输入参数。



验收标准的概念来自用户故事，通过它统一描述业务规则，同时，它也是需求分析人员、开发人员和测试人员三个角色就该业务服务达成一致共识的重要内容。



按照如上所述的格式，我们可以为“发布作品”功能编写一个业务服务规约。



**服务编号：**L0006

**服务名：**发布作品



**服务描述：**

作为作者

我想要发布我的作品

以便更多读者阅读我的作品



**触发事件：**

作者点击“发布文章”按钮



**基本流程：**

1．检查作品是否符合发布标准

2．对作品内容进行违规检查

3．发布作品

4．发送消息通知作品的订阅者



**替代流程：**

1a．如果作品不符合发布标准，提示“作品不符合发布标准”

2a．如果作品内容未通过违规检查，提示“作品内容包含敏感内容，禁止发布”

3a．如果作品发布失败，提示失败原因



**验收标准：**

1．作品标题字数不得超过50个字符（1个汉字为2个字符）

2．作品标题只能使用汉字、英文字符和数字

3．发布的作品必须包含标题、作品类型和作品内容，作品内容的字数不能少于300字

4．作品发布成功后，状态为“已发布”

5．作品的订阅者收到作品发布的通知

6．作品的订阅者可以阅读已发布的作品



理论上，应该由需求分析人员编写业务服务规约，同时，和测试人员共同完成业务服务规约的验收标准。业务服务规约呈现了领域知识，因此不要忘记了，每个词语的使用都要遵循“统一语言”的原则，即以正确的方式就每个领域概念、领域行为和领域规则在团队内达成一致。



### 业务服务的价值


在我的领域驱动设计统一过程方法中，产生设计驱动力的就是业务服务。业务服务体现了目标系统的领域知识，故而可以认为是以业务服务为核心的领域驱动设计，这实际上也弥补了Eric Evans在他的《领域驱动设计》一书中不曾提及需求分析的缺陷。



领域驱动设计讲究以“领域”为核心驱动力，居然没有阐述清楚到底该怎么获得以及如何呈现领域知识，逻辑上是讲不通的。



我定义的业务服务不止如此，它不仅是打通问题空间与解空间的桥梁，也是识别限界上下文时的主要输入；它不仅映射到解空间的服务契约上，还能帮助我们甄别限界上下文之间的关系；它包含的领域知识也成为了领域建模过程的重要参考，贯穿了整个领域建模过程。事实上，整个领域驱动设计统一过程的诸多实践与方法，都是围绕着业务服务来开展的。其价值如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705322296-307eaeb9-0bdd-4324-8437-9f9f9e1888d3.png)



业务服务的价值是从四个视角来阐述的。



从需求分析视角看，它的定义明确了识别业务服务的客观标准，理清了混淆不清的层次与粒度，并通过业务服务规约清晰地呈现了它蕴含的领域知识。这属于问题空间的范畴。



到了解空间，在领域驱动设计统一过程的架构映射阶段，可以利用业务服务自下而上地按照业务相关性识别限界上下文。在我的书中，将问题空间识别业务服务和解空间识别限界上下文，统称为“V型映射过程”，它涵盖了问题解决过程的两个方向：自上而下与自下而上，恰好完美地组成了一个V型。



业务服务强调执行的连续性，又突出了目标系统的边界，并由限界上下文来响应角色发起的服务请求，将其映射到解空间，站在服务设计视角，就是一个服务API，我将其称之为“服务契约”。它就是在架构角度为限界上下文定义的对外公开的接口，也是业务能力的设计体现。



进入领域建模阶段后，业务服务规约为领域分析建模寻找领域概念提供了重要参考，进行领域设计建模时，业务服务规约中的基本流程甚至直接成为任务分解的输入，如果在领域实现阶段采用了测试驱动开发，则业务服务规约中的验收标准还可以帮助我们识别和定义测试用例。



显然，业务服务在我提出的领域驱动设计统一过程中，简直无处不在！

## 阐释限界上下文


虽然前面提到业务服务规约。若要在细节层面传递领域知识，需要为业务服务编写业务服务规约；然而在全局分析阶段，一开始不必钻入细节，因为它之输出将作为架构映射阶段的重要输入。如果从分析阶段就沉入太多细节，就会陷入“分析瘫痪”，且无法帮助我们尽快获得合理的架构。



因此，我对业务服务的介绍就先告一个段落，让我们快速进入架构映射阶段。重要的，是我们要识别出限界上下文。



要识别限界上下文，需要了解限界上下文到底是什么？我的著作《解构领域驱动设计》用了大量篇幅来阐释限界上下文，因此，在这组系列文章中，我就仅列出浓缩的精华。



### 限界上下文的六个要素


首先是限界上下文的六个要素，我用一句话进行描述：

封装了**领域知识**的**领域对象**，在**知识语境**的界定下，扮演了不同的**角色**，执行了不同**活动**，共同对外公开内聚的**业务能力**。



这六个要素之间的关系体现为下图：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakAVv2L6FEicR0VJibx9DIpORLmTZt8GBoQVmClQp5PYEuib5atFeNgQr6lztpf7icdTpRUMzY3icTOSZEA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



限界上下文主要封装了提供领域知识的领域模型对象。在划分领域驱动设计的边界时，要根据领域知识的边界进行划分。在其内部，这些领域对象与基础设施提供的功能共同向外以服务形式提供各个完整的业务能力。



### 限界上下文的两个本质


限界上下文是解空间的子空间，它体现了如下两个本质：

+  限界上下文是领域模型的知识语境 
+  限界上下文是业务能力的纵向切分 

#### 领域模型的知识语境
如何理解“领域模型的知识语境”？我们可以想象一名伪装者穿行在不同的空间中，扮演了不同的角色，他的身份由其所处的空间决定。这个空间，就是我们进行讲述的知识语境。



可以换一个角度理解“盲人摸象”这则寓言。如下图所示，它隐含说明了在限界上下文的限定边界内，定义的领域模型虽然是局部的，但对于当前限界上下文而言，它就是整体。

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705623811-255bdb48-c5c1-4b22-9409-0e6dbd5e0a12.png)



在目标系统范围内，一个完整的领域概念就是一头大象，例如Customer的方方面面作为一个整体，Product的方方面面作为一个整体，它们都是完整的一头大象。但是，在限界上下文的团队里，人们看到的大象的局部，在他们眼中，不是局部，而是大象的整体。——是否有柏拉图洞穴理论的哲学观？谁又能看到现实的真相呢？



采用模块的设计观念观察大象，大象是一个唯一的整体：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705651563-b7cf7aa1-15e3-453a-a275-a6226bdca114.png)



采用限界上下文的设计观念观察大象，还是这个整体，但是在逻辑上被分为了不同的部分，受到知识语境的限制，每个团队都将自己看到的局部看作是整头大象，于是，在各个上下文中都定义了各自的Elephant，到了系统层次，它们通过唯一ID确定大象的身份，又共同组成一个整体。

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705666424-eba79e06-199d-46dd-8110-8f4b3f205280.png)



以Product为例，完整的Product属性有数十个，但在运输上下文，只需要了解Product与运输有关的属性，如shippingWidth、shippingHeight、inShippingBox等。此时，就应该在运输上下文定义一个Product类，它拥有这三个属性，在运输上下文中，它就是商品整体，也就是整头大象。



#### 业务能力的纵向切分


限界上下文是业务能力的纵向切分。



这一本质旗帜鲜明地说明了：

+  从领域维度对整个系统的解空间进行切分，如此形成端对端的纵向的领域特性 
+  限界上下文不止包含领域模型对象，还包括支持业务能力的基础设施 



与限界上下文相比，我们通常使用的“模块”概念就不同了，它的边界没有这么清晰，既可以横向切分，也可以纵向切分。由此方式定义的业务模块只定义了具有领域知识的领域模型对象，却无法对外提供完整的业务能力，它需要基础设施模块的支持。如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705691774-e78887b3-08a2-438a-9641-736865d45681.png)



限界上下文的边界由领域维度决定。不考虑粒度的差异，完全可以将限界上下文当作一个相对完整的子系统：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705704362-bed3f1ff-d307-4dbb-8cbb-2c88e5cf6bf4.png)



正所谓“麻雀虽小，五脏俱全”，如图看到的限界上下文虽然粒度更小，但它是功能相对完备的。这就解释了为何在进行微服务设计时需要借鉴领域驱动设计的思想。



模块的划分是做生日蛋糕的做法，即从实现的角度，先做好一层蛋糕，再添加巧克力，之后为其铺上奶油，最后点缀各色水果。

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705717791-3fe13ab3-c4d7-4069-81fd-5b66a10b2f5c.png)



限界上下文的划分是切生日蛋糕的做法，即从消费的角度，给每个人切一块蛋糕。理论上，不管切下的蛋糕有多小，都是相对完整的：蛋糕、巧克力、奶油和水果俱全。



如此切分的前提基于一个事实：大多数软件系统的需求变化，是根据领域维度进行变化的。要保证设计的架构具有演进性，不是要拒绝变化，而是要让变化产生的影响降到最低。故而，**架构设计需要顺应变化的方向**。



### 限界上下文的四个特征


一个设计良好的限界上下文必须满足自治性。限界上下文的自治特征如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705739358-f3da1dfd-36d6-48a3-bd2e-e1f8a18dde23.png)



简单总结这四个特征：

+  最小完备：就领域知识而言，它实际体现了领域模型的知识语境，即当前限界上下文需要的必备领域知识，必须分配给它，才能保证其最小的完整性。 
+  自我履行：一旦具有了最小完备性，限界上下文就拥有了“自我履行”的意识，在辅以边界内基础设施的支持，就能输出完整的业务能力，因此，它也体现了业务能力的纵向切分。 
+  稳定空间：限界上下文内部的领域层需尽量保持稳定，这就需要隔离外界变化对它产生的影响。引入抽象，即可达成此目的。 
+  独立进化：需求自身的变化会引起领域模型的修改和更新，可认为是领域模型的一种进化。如果说稳定空间是隔离外界的变化，那么，独立进化就是避免内部的变化影响外部。引入封装，即可达成此目的。 



### 菱形对称架构


与限界上下文自治特性对应的架构模式是我提出的“**菱形对称架构**”。



或许又有人说我“创新”何太急了。但我认为：在任何领域，我们都要敢于去创新。创新不一定要开天辟地，哪怕是一个小小的“新想法”，也不可否认其价值；创新也不一定要批判过去，哪怕是对现有成果的小小改进，也可视为技术的持续前进。至于什么是真创新，什么是伪创新，就要看以谁的标准而论了。



不可否认，菱形对称架构脱胎于六边形架构，思想则沿袭自整洁架构思想。与之不同的是，菱形对称架构是特别针对领域驱动设计的限界上下文提出的。



一句话形容菱形对称架构，可以总结为：**内外分离，南北对称**。整个架构模式如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705764406-fd989a65-09bb-404d-af71-f578da5caf28.png)



菱形对称架构的英文描述为Rhombic Symmetry Architecture(RSA)，也可以简称为菱形架构（Diamond Architecture）。



所谓“内外分离”，就是在菱形对称架构中，整个限界上下文被分为内部的领域层和外部的网关层。



内外分离的风格可以更好地隔离业务复杂度与技术复杂度。团队根据菱形对称架构编写代码时，一个基本的检查手段就是询问：我写的代码与领域逻辑有关吗？如果是，就放在内部的领域层；如果非，就放在外部的网关层。进行代码评审时，也可通过这一判断标准进行检查。



限界上下文内部的领域模型需要满足“最小完备”的自治特征，外部的网关层提供了业务能力需要的基础设施，满足了“自我履行”的自治特征。



所谓“南北对称”，就是南向网关和北向网关的对称，前者体现“抽象”思想，故而分为端口与适配器；后者体现“封装”思想，分为本地服务与远程服务。



为了更好地隔离领域层变化对外界的影响，外部的网关层就好似鸡蛋壳一般保护着鸡蛋，避免直接将领域模型裸露在外。因此，在引入本地服务与远程服务的同时，还需要引入一层消息对象，它建立了服务契约与领域模型之间的间接层。



通过引入南向网关，可以满足限界上下文“稳定空间”的自治特征；通过引入北向网关，可以满足限界上下文“独立进化”的自治特征。



如前所述，菱形对称架构很好地满足了限界上下文的四个自治特征。同时，它还遵循了**稳定****依赖原则**，该原则要求被依赖的元素（类、模块、服务）要稳定。这实际上是控制依赖复杂度的有效方法。



遵循该原则，菱形对称架构的南北网关分别体现为：

+  北向网关：参考Robert Martin提出的**整洁架构思想**，该思想认为内部要比外部更稳定，要满足稳定依赖原则，必须是外部依赖内部。北向网关定义的调用顺序由外向内依次为远程服务调用本地服务，本地服务调用领域层。 
+  南向网关：外部依赖内部在理论上是成立的，但在实际开发中一定会出现内部依赖外部，此时要遵循依赖倒置原则，内部不依赖于外部，而是依赖于外部的抽象。南向网关定义了端口和适配器，内部的领域对象如果要访问外部，只能访问抽象的端口。 



我之所以说菱形对称架构是特别针对领域驱动设计的限界上下文提出，还在于它直接反应了Eric Evans提出的上下文映射。同时，它也可以和分层架构映射起来，如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706705801232-b55b6085-04ac-4efa-9f42-4224e98ad5b8.png)



南向网关扩大了防腐层（ACL）的外延，从限界上下文的代码模型边界来看，不止是上游限界上下文，诸如数据库、文件、外部平台、消息队列都是它要防止腐化的内容。为此，我将访问数据库的抽象Repository放到了南向网关的端口层，与访问上游限界上下文的Client位于同等地位。对应领域驱动设计的分层架构，南向网关就是基础设施层。



北向网关就是开放主机服务（OHS）。由于Eric Evans强调应用层需为一个薄薄的层，不应包含领域逻辑，故而也可认为应用层的应用服务就是开放主机服务。然而就此二者，在Eric Evans的书中语焉不详，为保证概念的清晰性与一致性，我干脆将应用服务认为是进程内调用的本地服务，然后通过区分通信协议与设计模式，分别定义了不同的远程服务。对应领域驱动设计的分层架构，北向网关就是应用层。



开放主机服务需要定义发布语言（PL），以保证其稳定性。在菱形对称架构中，就是定义的消息。



如果为限界上下文引入了菱形对称架构，除了共享内核模式，如防腐层、开放主机服务与发布语言等上下文映射模式就已经包含了。至于为何不用分层架构，是因为我觉得像菱形对称架构这样内外分离的表现形式，可以更清晰地体现业务与技术的隔离。



关于菱形对称架构的定义与运用，有很多内容要谈，各位可以去阅读我的书籍《解构领域驱动设计》。当然，它也可以很简单，只要你理解了抽象与封装的思想，那就只需要记住这八个字即可：

**内外分离、南北对称**。



## 识别限界上下文


前面内容阐述了我对限界上下文的理解，概括为：

+  六要素：领域知识、领域对象、知识语境、角色、活动和业务能力 
+  两本质：领域模型的知识语境、业务能力的纵向切分 
+  四特征：最小完备、自我履行、稳定空间和独立进化 



有感于Eric Evans DDD中并没有提出与限界上下文相对应的架构模式，我在整洁架构和六边形架构的基础上提出了菱形对称架构，通过“内外分离、南北对称”的架构模式更好地保证限界上下文的自治性，从而促进架构的演进能力。



当然，也有人提到菱形对称架构有些抽象过度。我不否认这个问题，外部的网关层在隔离变化的同时，自然也引入了许多间接的成本。这本身就是一个it depends的问题。当限界上下文的领域模型相对稳定，自然也可以采用共享内核的方式，将领域模型的这层外壳直接去掉，结构会变得更简单一些。



不管是我提出的菱形对称架构，还是已有的整洁架构、洋葱架构、六边形架构，甚至是分层架构，它实际上都是“关注点分离”原则的体现，是施加到软件系统之上的一种约束规则。规则就是拿来打破的，谁规定一定需要遵循规则呢？前提在于，你有没有做出更佳判断的能力。



我提出领域驱动设计统一过程、业务服务、菱形对称架构，以及后面将要讲到的服务驱动设计，目的就是**固化**设计流程，将设计的门槛降低，让团队能够实施和落地DDD。自然，这种固化就不可避免会带来设计上某种程度的僵化。



因此，我的一贯主张为：

+  如果你的设计能力很棒，那就抛开规则对你的约束，前提是你能得到一个更佳的方案； 
+  否则，那就遵循规则，保证团队交付的质量能够“取乎上而得其中”。 



若设计分数满分为100分，没有人能得到满分，90分已是极佳。然则，90分虽好，在不制订约束规则的前提下，交给每个团队成员自行做决定，谁能保证得到高分？与其给出不及格的分数，还不如退而求其次，拿一个马马虎虎的80分，不是很好吗？



既然限界上下文如此重要，如何识别限界上下文就成了重中之重。



识别限界上下文当然不能拍脑袋凭经验，可许多内容又不得不借助经验。我给出的识别方法，无法做到像数学公式那样简单精准，只能适度降低经验在其中扮演的重要作用。



识别限界上下文，不仅仅要获得有哪些限界上下文。在给出的架构方案中，如果你只是画一些框图，说明这个系统有哪些限界上下文，其实对于开发团队而言，并没有价值。因为即便我们知道了有哪些限界上下文，团队也不明确这些限界上下文的职责，边界不清晰，带给设计的约束能力无形中就消失了。



我们必须在识别出限界上下文的同时，还需要明确问题空间中的业务服务与限界上下文之间的映射关系。



识别限界上下文不是一蹴而就的，需要经历多次迭代，也可能在识别之后还要经历不断的演化。识别的过程是一个动态的过程，大体上，需要从领域维度、技术维度和团队维度对限界上下文的边界进行校准。



### 领域维度


领域维度对限界上下文的识别，其实就是在问题空间获得业务服务，然后针对业务服务根据业务相关性对它们进行归类和归纳，获得业务主体，进而根据高内聚低耦合原则以及限界上下文的本质，进一步对业务主体的边界进行调整，获得初步的限界上下文。



从问题空间分析获得业务服务是一个自上而下的过程，对业务服务进行归类和归纳则是一个自下而上的过程，合起来，恰好形成一个V形，故而，我将这一识别限界上下文的过程称为“V形映射过程”：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751613665-191dbbf5-686c-46ac-ba10-37b9a6584e9c.png)



业务相关性分为语义相关性和功能相关性。



业务服务以动词短语形式表达，如果描述中包含了宾语，它通常就是一个名词。对名词概念进行分析，只要该名词概念相同或者相似，都可以认为它们具有语义相关性。如下业务服务的列表：

+  查询作品 
+  预览作品 
+  发布作品 
+  阅读作品 
+  收藏作品 
+  评价作品 
+  购买作品 



显然，它们都具有“作品”的语义，故而优先考虑将它们归类到一起。



所谓“功能相关性”，并非是指业务服务之间彼此存在功能的调用关系，因为根据业务服务的定义来看，不应该存在彼此互相调用的业务服务，所以这里提到的功能相关性，实际上指的是它们具有共同的业务目标。以下面的业务服务为例：

+  标记精彩内容 
+  撰写读书笔记 
+  评价作者 
+  加入书架 



它们具有共同的业务目标，都是为读者提供服务，故而可以考虑将其归类到一起。



完成归类后，再进行归纳。从同一个类别的业务服务中找到一个共同的特征，将该特征用一个简单的名词来表示。如果找不到共同特征，则说明之前的归类过于分散；如果需要多个名词表示，同样说明分类不合理，或者就是概括的特征抽象层次太低，需要建立更高的抽象。



有时候，针对两个不同的分类，在更高的抽象层次上，体现的是相同的特征，则可以将分类合并。例如以下业务服务：

+  建立读者群； 
+  加入读者群； 
+  发布群内消息； 



共同体现了“读者群”的语义。



以下业务服务：

+  实时聊天； 
+  发送离线消息； 
+  一对一私聊； 
+  发送私信； 



共同体现了聊天的业务目标。



但在更高的抽象层次上，它们其实都属于“社交”的范畴，可以将其放到同一个类别中，命名为“社交”：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751641050-66bdbcbc-abc6-4c01-8919-f1fe023889e0.png)



如此归类稍显粗糙，也未体现限界上下文的特征，故而我将其名为“业务主体”，之后还要根据亲密度和限界上下文的本质特点对业务主体进行调整。



亲密度是高内聚低耦合的体现。只要业务服务的归类分配合理，就应该满足“同一个业务主体的业务服务之间，其亲密度必然高于不同业务主体业务服务之间的亲密度”。如果做不到，只能说明分配的不合理，需要进一步调整。



得到调整后的业务主体及其内部的业务服务后，再结合统一语言，询问自己：

+  同一个业务主体内的业务服务中，语义上是否存在知识语境的冲突？ 
+  同一个业务主体内的业务服务共同表达了相关的业务能力了吗？ 



这正是根据限界上下文的本质进行的进一步甄别。



由此获得的限界上下文还未必正确，我归纳了四个设计原则用以检验限界上下文的识别是否合理，分别为：

+  单一抽象层次原则：识别出来的每个限界上下文在抽象层次上应该保持同一水平，不允许在抽象层次上出现彼此包含的情况 
+  奥卡姆剃刀原则：即“若无必要勿增实体”，这里所谓的“实体”，指的是限界上下文，也就是说，是否要分离出一个独立的限界上下文，需要给出充分的理由 
+  正交原则：多个限界上下文之间可以出现依赖，但不能出现不必要的重复，否则就违背了正交性 
+  最小惊讶法则：业务服务到限界上下文的映射应该是理所当然，限界上下文的名称和它要履行的业务能力也应该理所当然，如果对限界上下文的识别让人感到很惊讶，说明它存在不合理的地方，需要调整 



根据这四个原则对限界上下文一一进行校验和检查后，领域维度识别出的限界上下文就基本合理了。



### 技术维度


领域驱动设计识别限界上下文，一定是领域维度优先，否则谈什么领域驱动设计呢？根据领域维度识别出限界上下文后，再考虑技术因素。如果确实因为某种技术原因，要求将一些业务服务独立出来，也就相当于给奥卡姆剃刀原则提供了分离的理由。



例如，因为性能或高并发的质量属性需求，要求某些业务服务必须使用专门的资源；又例如因为安全级别的不同，针对某些业务服务提出了非常规的安全访问和控制要求，由于限界上下文是业务能力的纵向切分，其边界内实际上还包括对数据的管理，要满足安全要求，也只能将其单独分离。



由此，可以从技术维度单独分离出限界上下文。这可以认为是技术维度对领域维度的一种干扰，或者说是质量属性对业务需求的影响。考虑到限界上下文属于解空间的范畴，适度考虑技术实现因素，也是合理的行为。



### 团队维度


团队维度对限界上下文边界的影响，建立在“康威定律”的基础上。一个软件系统架构的组织结构应与开发该软件系统的团队组织结构保持一致，这已经成为大多数软件团队的共识。



一个软件团队到底该多大规模呢？Amazon的CEO Jeff通过形象的two pizzas' team给出了答案，也就是大概7人左右的规模。



不仅要保证团队的规模，针对开发限界上下文的团队而言，还要建立特性团队，即面向垂直领域特性的全功能团队。



将这三个团队原则结合起来，我们就建立了领域特性团队。它与限界上下文的关系如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751690578-a707a118-c611-4814-bf42-8cf7a59d47b8.png)



团队维度对识别限界上下文的约束是一个动态的过程，这恰好满足系统范围的特征，即它是在有限边界的界定下无限延申的范围。我们在识别限界上下文时，并不能保证已经识别出整个系统范围的所有业务服务，也不能保证未来不会发生需求的变化或扩充，既然需求要发生变化，限界上下文当然也可能变化。遵循康威定律，我们要保证团队的职责边界不要出现混乱，如此也就能保证限界上下文的边界不会因为变化导致混乱。



由此，可以总结出识别限界上下文的完整过程：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751703148-251bde59-ea90-4d97-afaf-a3228134b5ce.png)

### 工作坊演练


毫无疑问，以上总结的识别过程无法做到数学公式一般的准确和客观，它需要结合经验以及对业务的理解进行推演，方可得到不错的设计结果。这样的经验是没法通过文字传递给大家的。最好的方式，就是进行实际案例的演练。



终于轮到技术部落案例的闪亮登场了。在前面我已经介绍了该案例的业务背景。这里不妨再啰嗦一遍。



技术部落平台是为IT技术人员打造的一个社交和知识分享的平台：

+  每个用户都可以创建属于自己的部落，也可以申请加入到别人的部落，成为部落的会员 
+  只有部落的会员（包括创建人）才可以在部落中分享、发布文章、组织活动且发布活动信息、开展直播、提出问题、回答问题 
+  每个用户都可以在平台发布求职信息 
+  企业用户是付费用户，可以在平台发布招聘信息，平台也可以推荐人才给企业用户技术部落平台 



为了提升工作坊的演练效率，我已经识别出该平台的业务服务，并在processon上创建了业务服务列表的模型。下图展示了该列表的一部分：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751744142-a60ab308-731e-41f9-9a13-35d9da782ff8.png)



演练时，按照本文提到的识别过程，对业务服务进行归类和归纳，将各个业务服务放到限界上下文中，如下格式：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751801101-673266db-5191-495b-936d-0481dba33f05.png)

#### 业务相关性


识别限界上下文的第一步是按照业务相关性对业务服务进行归类和归纳，归纳后得到的内容可以将其称之为“业务主体”或者候选的限界上下文。业务相关性可以认为是领域维度的高内聚低耦合划分原则。



**问题1：技术实现影响边界判断**



识别限界上下文时，我们一定要注意识别的顺序：

+  领域维度 
+  技术维度 
+  团队维度 



这个顺序不能乱！之所以名为“领域驱动设计”，就在于它将领域作为设计的驱动力，因此，首要影响限界上下文边界的，不是技术维度，也不是团队维度，而是领域维度。



下图是识别的两个限界上下文：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751904196-d83834b8-4cfd-423d-9f40-32020826ad2a.png)



显然，这两个限界上下文是技术维度输出的结果。因为站在how to do的角度，它确实需要完成和微博与Github两个外部系统（我的书中将其称之为伴生系统）的集成。



让我们切换一下视角，单从领域维度来思考这两个业务服务：

+  获取微博动态 
+  获取GitHub账户最新提交记录 



虽然二者没有语义上的相关性，但从功能相关性角度看，二者其实提供了一个共同的业务目标：为用户提供更为丰富的个人信息。**不要让技术实现干扰你的判断**，显然，这两个业务服务更适合放在“用户上下文”。



**问题2：动词作为业务相关性判断依据**



业务服务由动词短语构成。如果动词短语包含了名词类型的宾语，则该名词往往体现了领域概念，可以作为语义相关性的判断标准。下图所示的限界上下文就是通过语义相关性获得的：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751933634-021013ad-7871-4a30-8787-0c15a767221e.png)



如果要使用业务服务的动词进行判断，**切忌不要以动词的语义相关性进行判断**。下图给出的限界上下文恰恰犯了这个错误：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751952766-e1df7a23-ef06-4a5a-be8b-3d942622ad43.png)



文章和部落上下文的获得确实符合语义相关性，而部落推荐、部落搜索与文章推荐上下文的获得，依据的就是动词相关性了。这一划分显然是不合理的。下图所示的划分结果犯了同样的错误：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751971079-40a979f5-c01e-4916-8663-a16e6d185298.png)



真要以动词相关性来划分限界上下文，那倒是简单了。所有的业务功能无外乎增删改查，难道我们该由此将每个系统都划分为增、删、改、查四个限界上下文吗？



判断动词的相关性，考虑的其实是它对应的领域行为向外输出的业务能力，也就是功能相关性需要判断的业务目标。



例如下图的直播上下文：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706751986534-de029913-458e-4f1d-87ef-f2215802dfbc.png)



为何要将以下没有任何语义相关性的业务服务放在同一个直播限界上下文？

+  打开摄像头 
+  关闭摄像头 
+  共享屏幕 
+  转移主持人 
+  发言 
+  打赏 



不还是因为它们都是在为直播功能服务吗？



根据动词相关性识别限界上下文的错误还有不少例子，例如一位读者识别出来的审批上下文与关注列表上下文，都是不合理的：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706752004655-c342ead7-dada-45be-82a2-3cff092d0951.png)



在归纳业务服务的共同特征时，应以名词作为候选限界上下文的名称。如果名称为动词，或动词形式的名词，就需检查和判断：我们是否错误地以动词作为业务相关性的判断依据了。



#### 亲密度


根据业务相关性的强弱对业务服务进行归类，实则遵循了“高内聚低耦合”原则。如果分配合理，必然遵循：**同一限界上下文内业务服务之间的亲密度一定要高于跨限界上下文间的业务服务**。若违背这一规律，说明业务服务的归类存在问题。



检查下图分配的业务服务：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706752031853-e13d88e7-a38d-4612-a648-322e17fe6f04.png)



毫无疑问，属于账户信息上下文的“查询积分”业务服务，与同一限界上下文其他业务服务的亲密度，显然不及它与礼品上下文业务服务之间的关系强度。



#### 限界上下文的本质特征


根据业务相关性对业务服务进行归类，不过是一种分类的方法，如果只限于此，划分出来的不过是按照功能进行分解的模块罢了。既然是识别限界上下文，自然要从限界上下文的本质特征着手。



如前所述，限界上下文的本质特征为：

+  领域模型的知识语境 
+  业务能力的纵向切分 



在检查我们识别出的限界上下文时，需要结合这两个本质特征作进一步甄别。



**领域知识的知识语境**



语义相关性体现了对领域知识的归类，然而限界上下文不仅如此，它还是领域概念的边界，通过它可以限定当前上下文的领域知识，避免领域概念在理解上的分歧与冲突，形成当前上下文的统一语言。



例如在技术部落平台中，用户、企业用户和会员有着不同的知识语境。其中，企业用户与之对应的是个人用户，它们都是用户的一种类型，在对用户进行身份管理时，应该一视同仁，区别只在于用户的属性不同，应该将它们都放在用户上下文。至于会员，表示该用户属于部落的会员，实际体现的是用户与部落之间的关系，与之相关的业务服务应该放在部落上下文。



倘若将用户上下文命名为账户上下文，这没有问题，但需要明确统一语言。例如账户代表的含义？不要将代表用户身份的账户与支付相关的账户混为一谈。



**业务能力的纵向切分**



分配在一起的业务服务应该对外提供相同或相似的业务能力。以下图为例：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706752105212-16d2d71c-ab8e-457b-9532-75c3ae2b63f2.png)



用户上下文对外提供的应该是用户身份认证与用户基本信息管理的业务能力。放在该限界上下文内部的以下业务服务则不然：

+  设置工作经历 
+  设置项目经历 
+  设置技能信息 
+  生成个人简历 



它们为个人简历提供了必要的领域知识，形成了与求职相关的业务能力。这些领域知识也只有在求职或招聘时才会使用到，因此，以上分配并不合理。



图中“关注活动”业务服务的分配也不合理，它主要违背了“亲密度”的原则，因为该业务服务与活动上下文的亲密度更高。



#### 验证原则


识别的限界上下文是否正确，分配的业务服务是否合理，还需要进一步通过我总结的验证原则进行验证。



**原则1：单一抽象层次原则**



如果识别合理，获得的限界上下文应该尽可能处于同一个抽象层次。不同层次的抽象可能导致限界上下文的含义互相包含。例如：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706752144888-77adc230-6e60-43cf-94fb-9643da1a712e.png)



即使部落推荐上下文和部落搜索上下文的识别是合理的，它也违背了单一抽象层次原则，因为部落上下文的抽象实际上已经涵盖了部落推荐和部落搜索的含义。



遵循单一抽象层次原则，还意味着我们在归纳业务服务时，需要适度的抽象，千万不要抽象过猛。下图归纳获得的限界上下文都是抽象过猛的反例：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706752160101-77145a43-c05f-40f6-95a8-82ac9c7183c4.png)



社交、工具、服务、互动、售后都是含义极为宽泛的通用概念，矛盾的是，如此抽象的限界上下文，却仅仅包含了数量极少的业务服务，如此大的反差，足以说明抽象层次的不合理。



有时候，又可能因为抽象不够导致概念的不一致。如下图所示：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706752175787-d7cdea85-4114-4d41-b977-1509b5b5e12f.png)



虽然抽象为招聘上下文，但其中包含的业务服务一部分提供了招聘的业务能力，另一部分则提供了求职的业务能力。显然，招聘这一抽象不足以涵盖整个限界上下文的业务服务。要将这些业务服务归类在一起，需要建立一个更高的抽象，例如工作或者人才，如此抽象就合理了。



**原则2：奥卡姆剃刀原则**



将奥卡姆剃刀原则翻译成能理解的中文，就是“若无必要勿增实体”。这里所谓的实体，当然是指限界上下文。也就是说，在切分限界上下文时，一定要有拆分的充足理由，如果没有理由，就应该优先考虑合并，避免因为增加太多不必要的限界上下文，从而增加架构的复杂度。



例如将直播室的业务服务单独剥离出来，定义了直播室上下文：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706752201553-2d79d30e-c256-46a1-971c-8d2954a583e2.png)



这样的细分有何依据呢？直播室和直播的差别又在哪里呢？如果直播室要分开，那么直播上下文的其他业务服务，如打开摄像头、关闭摄像头为何又不分开呢？



分开之前，还是先找一个能够自圆其说的理由吧！



**原则3：正交原则**



遵循正交原则，可以保证限界上下文之间不存在交叉或重叠的领域知识，如此就能将变化带来的影响降到最低。



如下图的活动上下文：

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706752229161-10cd3e88-b08a-4843-b457-6649e8611bd5.png)



该限界上下文有多个业务服务都与“报名”有关。报名不仅仅是体现了领域行为的动词，它同时还涵盖了与报名有关的领域知识，如报名通道、报名流程和报名的规则。



现在，直播上下文也有与报名有关的业务服务，如“报名参加直播”，如果二者都需要操作和报名相关的领域知识，就存在领域知识的重叠。要遵循正交原则，可以考虑单独定义一个报名上下文。



**说明：**虽然在中文中，报名通常解释为动词，但这里的上下文名称实际上并非使用报名的动词语义，如果翻译为英文，可以理解为是名词enrollment，而非动词enroll。



**原则4：最小惊讶法则**



识别出来的限界上下文，无论是限界上下文的名称，还是业务服务与限界上下文之间的关系，都要保证合理性，不能让人莫名惊讶。



例如，技术部落提供了提问、回答的功能，如果将这些业务服务归类在一起，将其命名为“问答”，就能让人一望而知其含义，如果非要将其命名为BBS或者论坛，就很容易让人产生误解了。



只要能够说明其含义，限界上下文的命名可以力求精简。如一位读者识别出了技术文章上下文和技术部落上下文，实际上，在技术部落平台这个大背景下，何必增加“技术”这个修饰词呢？更何况，技术部落上下文还很容易与技术部落平台混淆，不如直接命名为文章上下文与部落上下文。



仔细分析如下图识别出来的工具上下文，对照其名称，它包含的业务服务足够让人惊讶了。

![](https://cdn.nlark.com/yuque/0/2024/png/859018/1706752255113-a8edbd75-7e30-415c-9df8-41e28aa779a4.png)

限界上下文的名称一定要足以涵盖其内部所有业务服务的概念，做到观其名，就能大致推测出内部有哪些业务服务，而不应产生意外惊讶。上图的业务服务分配产生的不是惊喜，而是不可思议的惊诧，违背了最小惊讶法则。



以上分析了从领域维度识别限界上下文暴露的诸多问题，并一一做了解答。可以看到，我们并不满足于识别出限界上下文，还需要获得限界上下文与业务服务的映射关系，如此才能对后续的设计和建模工作产生指导作用。

#### 团队维度


根据康威定律，软件系统的架构应与开发该软件系统的团队结构保持一致，如此才能保证高效的沟通，并降低沟通的成本。

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakDzzSMlmibeYKZPBtpoo02GicPSg2oVvnvpkjpbateGnHicc2ZJNCAnLMcvmv0qLlXlYfBETx6CUzpMQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



虽说康威定律规定了团队与限界上下文之间的关系，然而在真正开发，哪有如此理想如意呢？因而我将二者关系总结为如下图所示的三种情形：

![](https://mmbiz.qpic.cn/mmbiz_png/d3Qa7X5fakDzzSMlmibeYKZPBtpoo02Gic1R5sichWiaRp4FM73o2ojTkZ1onWO9WnpwpTFkQn1qZODWoqKgq6Ngkw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



在我的《解构领域驱动设计》一书中详细介绍了何谓“领域特性团队”，这里不再赘述，但它确实是与领域驱动开发相匹配的团队组成结构。



上图可知，理想的映射关系是一对一，即一个限界上下文对应一个团队。由于限界上下文的边界首先取决于业务，则有可能出现个别限界上下文的工作内容较少，如果完全保持一对一的映射关系，可能导致团队的工作分配不均匀。如此，就可以调整为第二种情况，即一个领域特性团队负责开发多个限界上下文。



同理，由业务决定边界的限界上下文也可能非常大，一个满足2PTS（两个Pizzas）规模大领域特性团队无法完成这样复杂的限界上下文，那么，是否可以让多个领域特性团队负责一个大的限界上下文呢？答案是不能！因为这一做法会随着时间推移，由于跨团队交流成本的增加，导致限界上下文的开发出现问题。与其被动地受到多团队交流边界的影响，不如主动出击，根据团队边界对一个相对庞大的限界上下文进行调整。这就是团队纬度对限界上下文边界的影响。



以我们识别的技术部落为例，根据语义相关性和功能相关性可以识别出直播上下文，从业务角度看，它没有继续细分的必要。但要完成直播上下文的所有功能，可能需要一个超大的团队。我曾经为一家音乐媒体公司提供咨询服务，就我了解所知，该公司的直播平台团队规模达到两百多人，怎么可能让他们都工作在一个限界上下文？这时，就应该对直播上下文进行分解。



前面也提到一个原则，即“奥卡姆剃刀原则”，解释为“若无必要勿增实体”，现在，团队规模就是分解的足够理由了。



#### 技术纬度


技术纬度对限界上下文边界的影响，指的是系统的质量属性需求对限界上下文边界提出的要求，很多时候，也可以等同于是进一步确定限界上下文为微服务的依据。



这里需要先明确限界上下文与微服务的关系。二者之间的关系并无定论，毕竟Eric Evans在提出DDD时，并无微服务一说。不可否认，在微服务大行其道之时，社区如考古一般发现了DDD这套方法，借用了限界上下文这一概念作为识别微服务的依据。由此可以得出结论：如果选择了DDD帮助团队设计微服务，必然是限界上下文在先，微服务在后。



如此，仍不足以确定二者的关系。



个人认为，由于限界上下文仅限于逻辑边界，即使划分不合理，要调整起来仍然相对容易，微服务则不然，确定微服务边界时需要慎之又慎。如果没有划分微服务的绝对理由，我不建议贸然作出物理切分，而以保持限界上下文的边界为底线，只要限界上下文遵循了菱形对称架构，未来要演进为微服务，并不困难。此时的限界上下文更像是从单体迈向微服务的“中转站”，做到了“进可攻退可守”。



为了便于落地实践，我倾向于微服务的边界应大于或等于限界上下文的边界，这样定义的微服务，其实并不“微”，而是形成大小并不均衡的多个微服务。有的微服务就是一个限界上下文，有的微服务则可能包含多个限界上下文。



之所以允许这种不“微”的微服务存在，出于我的谨慎心理，不要急着让每个限界上下文都微服务化，而是考虑先定义一个规模相对大的“微服务”，其内部由多个限界上下文构成，直到有了让某个限界上下文成为微服务的充分理由，再考虑将该限界上下文拆分出来，演进为微服务。



成为微服务的充分理由，大致可以总结为：

+  资源独占性：如果需要为当前限界上下文分配单独的运行资源，则将其设计为微服务 
+  可伸缩性：为满足高并发、高性能、低延迟等质量属性，需要将当前限界上下文的资源进行单独伸缩，则将其设计为微服务 
+  安全性：若当前限界上下文的业务与数据需要单独的安全级别保障，则将其设计为微服务 
+  独立技术栈：若当前限界上下文运行的平台、开发语言等技术栈选择完全不同，则将其设计为微服务 
+  代码库版本：若当前限界上下文的版本更新周期具有独立性，则将其设计为微服务 



至于技术因素中的设计要素：复用和变化，只能影响限界上下文的边界，却不能成其为划分微服务的依据。例如，根据复用要求单独划分出来的限界上下文也可以以组件而非服务的形式部署，这也充分说明了限界上下文不一定等同于就是微服务。



回到技术部落这个案例。



前面提到不能将动词作为业务相关性的判断依据，例如不能将业务服务列表中与“搜索”有关的服务放在一起，也不能将“推荐”有关的服务放在一起。然而，如果考虑到与推荐有关的业务服务需要用到专门的推荐算法，为推荐算法提供支持的数据也不再来自各个由业务划分的限界上下文，而是以OLAP角度，通过ETL等方式将各个业务数据库的数据抽取到数据仓库中，同时还需要利用类似ELK这样的日志分析工具挖掘日志数据，则意味着推荐功能需要专有的技术实现，单独划分出一个推荐上下文就有了充分的理由。



一言以蔽之：如果说业务纬度是划分限界上下文的主要依据，则团队纬度和技术纬度则是校正限界上下文边界的考量因素，进一步，还可作为划分微服务的依据。



![](https://cdn.nlark.com/yuque/0/2023/png/859018/1703815757539-69cbab59-6fa2-4f7c-8cf5-e9e7824df0ef.png)

